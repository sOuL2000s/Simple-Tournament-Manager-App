<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ultimate Tournament Manager (Score7 Inspired)</title>
    <style>
        /* --- Global Styles & Variables --- */
        :root {
            --bg-color: #f4f7f6;
            --text-color: #333;
            --primary-color: #4CAF50;
            --primary-dark: #388E3C;
            --secondary-color: #2196F3;
            --accent-color: #FFC107;
            --border-color: #ddd;
            --card-bg: #fff;
            --input-bg: #f9f9f9;
            --shadow: 0 2px 5px rgba(0,0,0,0.1);
            --radius: 8px;
            --font-family: 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
        }

        body.dark-mode {
            --bg-color: #2c2c2c;
            --text-color: #e0e0e0;
            --primary-color: #66BB6A;
            --primary-dark: #43A047;
            --secondary-color: #64B5F6;
            --accent-color: #FFEB3B;
            --border-color: #555;
            --card-bg: #3a3a3a;
            --input-bg: #444;
            --shadow: 0 2px 5px rgba(0,0,0,0.3);
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: var(--font-family);
            background-color: var(--bg-color);
            color: var(--text-color);
            line-height: 1.6;
            transition: background-color 0.3s, color 0.3s;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        /* --- Layout --- */
        .container {
            max-width: 1200px;
            margin: 20px auto;
            padding: 0 20px;
            flex-grow: 1;
        }

        header {
            background-color: var(--primary-color);
            color: white;
            padding: 15px 20px;
            text-align: center;
            box-shadow: var(--shadow);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        header h1 {
            margin: 0;
            font-size: 1.8em;
        }

        .theme-toggle {
            background: none;
            border: none;
            color: white;
            font-size: 1.5em;
            cursor: pointer;
            padding: 5px;
            border-radius: var(--radius);
            transition: background-color 0.2s;
        }
        .theme-toggle:hover {
            background-color: rgba(255,255,255,0.2);
        }

        nav {
            background-color: var(--card-bg);
            box-shadow: var(--shadow);
            border-radius: var(--radius);
            margin-top: 20px;
            display: flex;
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
        }

        nav button {
            flex: 1;
            min-width: 120px;
            background: none;
            border: none;
            padding: 15px 20px;
            font-size: 1.1em;
            cursor: pointer;
            color: var(--text-color);
            transition: background-color 0.3s, color 0.3s;
            border-bottom: 3px solid transparent;
        }

        nav button:hover {
            background-color: var(--bg-color);
        }

        nav button.active {
            color: var(--primary-color);
            border-bottom-color: var(--primary-color);
            font-weight: bold;
        }

        .content-section {
            background-color: var(--card-bg);
            padding: 30px;
            border-radius: var(--radius);
            box-shadow: var(--shadow);
            margin-top: 20px;
        }

        /* --- Typography --- */
        h2, h3, h4 {
            color: var(--primary-color);
            margin-bottom: 15px;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 10px;
        }

        h2 { font-size: 1.8em; }
        h3 { font-size: 1.4em; }
        h4 { font-size: 1.2em; }

        /* --- Forms --- */
        .form-group {
            margin-bottom: 15px;
        }

        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: var(--text-color);
        }

        .form-group input[type="text"],
        .form-group input[type="number"],
        .form-group input[type="date"],
        .form-group input[type="time"],
        .form-group select,
        .form-group textarea {
            width: 100%;
            padding: 10px 12px;
            border: 1px solid var(--border-color);
            border-radius: var(--radius);
            background-color: var(--input-bg);
            color: var(--text-color);
            font-size: 1em;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .form-group input:focus,
        .form-group select:focus,
        .form-group textarea:focus {
            border-color: var(--primary-color);
            box-shadow: 0 0 0 2px rgba(var(--primary-color-rgb, 76, 175, 80), 0.2);
            outline: none;
        }

        .form-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
        }
        .checkbox-group input[type="checkbox"] {
            width: auto;
            margin-right: 5px;
        }

        /* --- Buttons --- */
        .btn {
            display: inline-block;
            padding: 10px 20px;
            border-radius: var(--radius);
            cursor: pointer;
            font-size: 1em;
            font-weight: bold;
            text-align: center;
            text-decoration: none;
            transition: background-color 0.2s, transform 0.1s;
            border: none;
        }

        .btn-primary {
            background-color: var(--primary-color);
            color: white;
        }
        .btn-primary:hover {
            background-color: var(--primary-dark);
            transform: translateY(-1px);
        }

        .btn-secondary {
            background-color: var(--secondary-color);
            color: white;
        }
        .btn-secondary:hover {
            background-color: #1976D2; /* Darker secondary */
            transform: translateY(-1px);
        }

        .btn-danger {
            background-color: #f44336;
            color: white;
        }
        .btn-danger:hover {
            background-color: #d32f2f;
            transform: translateY(-1px);
        }

        .btn-outline {
            background-color: transparent;
            color: var(--primary-color);
            border: 2px solid var(--primary-color);
        }
        .btn-outline:hover {
            background-color: var(--primary-color);
            color: white;
            transform: translateY(-1px);
        }

        .btn-group {
            display: flex;
            gap: 10px;
            margin-top: 20px;
            flex-wrap: wrap;
        }

        /* --- Lists & Cards --- */
        .tournament-list {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
        }

        .tournament-card {
            background-color: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: var(--radius);
            padding: 20px;
            box-shadow: var(--shadow);
            transition: transform 0.2s, box-shadow 0.2s;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .tournament-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 4px 10px rgba(0,0,0,0.15);
        }

        .tournament-card h3 {
            margin-top: 0;
            margin-bottom: 10px;
            border-bottom: none;
            padding-bottom: 0;
            color: var(--primary-color);
        }

        .tournament-card p {
            margin-bottom: 8px;
            font-size: 0.95em;
        }

        .tournament-card .status {
            display: inline-block;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 0.8em;
            font-weight: bold;
            margin-top: 10px;
        }

        .status.upcoming { background-color: var(--secondary-color); color: white; }
        .status.active { background-color: var(--primary-color); color: white; }
        .status.completed { background-color: #9E9E9E; color: white; }

        .no-data {
            text-align: center;
            padding: 40px;
            font-style: italic;
            color: var(--text-color);
            opacity: 0.7;
        }

        /* --- Tournament Detail Specifics --- */
        .tournament-detail-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 15px;
        }

        .tournament-detail-header h2 {
            margin: 0;
            border-bottom: none;
            padding-bottom: 0;
        }

        .tournament-info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .tournament-info-item {
            background-color: var(--input-bg);
            padding: 15px;
            border-radius: var(--radius);
            border: 1px solid var(--border-color);
        }
        .tournament-info-item strong {
            display: block;
            margin-bottom: 5px;
            color: var(--primary-color);
        }

        .participants-list, .matches-list {
            list-style: none;
            padding: 0;
        }

        .participant-item, .match-item {
            background-color: var(--input-bg);
            border: 1px solid var(--border-color);
            border-radius: var(--radius);
            padding: 15px;
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 10px;
        }

        .participant-item .actions, .match-item .actions {
            display: flex;
            gap: 8px;
        }

        .participant-item .actions .btn, .match-item .actions .btn {
            padding: 8px 12px;
            font-size: 0.9em;
        }

        /* --- Bracket Display (Single/Double Elimination) --- */
        .bracket-visualizer {
            display: flex;
            justify-content: center;
            align-items: flex-start; /* Align rounds at the top */
            overflow-x: auto;
            padding: 20px 0;
            gap: 40px; /* Space between rounds */
        }

        .bracket-round-simple {
            display: flex;
            flex-direction: column;
            gap: 20px; /* Gap between matches in a round */
            position: relative;
            min-width: 250px;
        }

        .bracket-round-simple h4 {
            text-align: center;
            margin-bottom: 15px;
            color: var(--primary-color);
            border-bottom: none;
            padding-bottom: 0;
        }

        .bracket-match-simple {
            background-color: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: var(--radius);
            padding: 10px;
            box-shadow: var(--shadow);
            position: relative;
        }

        .bracket-match-simple .player-line {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 5px 0;
            border-bottom: 1px dashed var(--border-color);
        }
        .bracket-match-simple .player-line:last-of-type {
            border-bottom: none;
        }
        .bracket-match-simple .player-line.winner-player {
            background-color: var(--primary-color);
            color: white;
            border-radius: 5px;
            padding: 5px 10px;
            margin: 2px -5px;
        }

        .bracket-match-simple .score-input {
            width: 60px;
            padding: 3px;
            margin-left: 5px;
            border: 1px solid var(--border-color);
            border-radius: 3px;
            background-color: var(--bg-color);
            color: var(--text-color);
            text-align: center;
        }
        .bracket-match-simple .sets-input {
            width: 100px;
            padding: 3px;
            margin-left: 5px;
            border: 1px solid var(--border-color);
            border-radius: 3px;
            background-color: var(--bg-color);
            color: var(--text-color);
            text-align: center;
        }

        .bracket-match-simple .match-actions {
            margin-top: 10px;
            text-align: right;
            display: flex;
            gap: 5px;
            justify-content: flex-end;
            flex-wrap: wrap;
        }
        .bracket-match-simple .match-actions .btn {
            padding: 5px 10px;
            font-size: 0.8em;
        }

        .match-details-popup {
            position: absolute;
            background-color: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: var(--radius);
            padding: 15px;
            box-shadow: var(--shadow);
            z-index: 10;
            min-width: 250px;
            max-width: 350px;
            top: 100%; /* Position below the match */
            left: 0;
            margin-top: 5px;
            display: none; /* Hidden by default */
        }
        .match-details-popup.active {
            display: block;
        }
        .match-details-popup p {
            margin-bottom: 5px;
            font-size: 0.9em;
        }
        .match-details-popup strong {
            color: var(--primary-color);
        }
        .match-details-popup .player-stats-display {
            margin-top: 10px;
            border-top: 1px dashed var(--border-color);
            padding-top: 10px;
        }
        .match-details-popup .player-stats-display div {
            margin-bottom: 3px;
        }
        .match-details-popup .player-stats-display strong {
            color: var(--secondary-color);
        }

        /* Double Elimination Specifics */
        .double-elimination-wrapper {
            display: flex;
            flex-direction: column;
            gap: 30px;
            width: 100%;
            align-items: center;
        }
        .double-elimination-wrapper > div {
            width: 100%;
            max-width: 100%;
            overflow-x: auto;
            padding-bottom: 10px; /* For scrollbar */
        }
        .double-elimination-wrapper h3 {
            text-align: center;
            width: 100%;
            margin-top: 20px;
            color: var(--secondary-color);
        }
        .double-elimination-wrapper .bracket-visualizer {
            justify-content: flex-start; /* Align rounds to the left */
        }

        /* Multi-Stage Specifics */
        .multi-stage-container .stage-card {
            background-color: var(--input-bg);
            border: 1px solid var(--border-color);
            border-radius: var(--radius);
            padding: 15px;
            margin-bottom: 15px;
            box-shadow: var(--shadow);
        }
        .multi-stage-container .stage-card h4 {
            margin-top: 0;
            margin-bottom: 10px;
            border-bottom: none;
            padding-bottom: 0;
            color: var(--secondary-color);
        }
        .multi-stage-container .stage-card .stage-content {
            margin-top: 15px;
            border-top: 1px dashed var(--border-color);
            padding-top: 15px;
        }

        /* --- Round Robin Table --- */
        .round-robin-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }
        .round-robin-table th, .round-robin-table td {
            border: 1px solid var(--border-color);
            padding: 10px;
            text-align: left;
        }
        .round-robin-table th {
            background-color: var(--primary-color);
            color: white;
            font-weight: bold;
        }
        .round-robin-table tr:nth-child(even) {
            background-color: var(--input-bg);
        }
        .round-robin-table tr:hover {
            background-color: var(--bg-color);
        }

        .round-robin-table .score-input, .round-robin-table .sets-input {
            width: 60px;
            padding: 5px;
            border: 1px solid var(--border-color);
            border-radius: 5px;
            background-color: var(--bg-color);
            color: var(--text-color);
            text-align: center;
        }
        .round-robin-table .sets-input {
            width: 100px;
        }

        /* --- Standings Table --- */
        .standings-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }
        .standings-table th, .standings-table td {
            border: 1px solid var(--border-color);
            padding: 10px;
            text-align: left;
        }
        .standings-table th {
            background-color: var(--secondary-color);
            color: white;
            font-weight: bold;
        }
        .standings-table tr:nth-child(even) {
            background-color: var(--input-bg);
        }
        .standings-table tr:hover {
            background-color: var(--bg-color);
        }
        .standings-table td.rank {
            font-weight: bold;
            text-align: center;
        }

        /* --- Modals --- */
        .modal {
            display: none; /* Hidden by default */
            position: fixed; /* Stay in place */
            z-index: 1000; /* Sit on top */
            left: 0;
            top: 0;
            width: 100%; /* Full width */
            height: 100%; /* Full height */
            overflow: auto; /* Enable scroll if needed */
            background-color: rgba(0,0,0,0.6); /* Black w/ opacity */
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
            padding-top: 60px;
        }

        .modal-content {
            background-color: var(--card-bg);
            margin: 5% auto;
            padding: 30px;
            border-radius: var(--radius);
            box-shadow: var(--shadow);
            width: 90%;
            max-width: 700px;
            position: relative;
            animation: fadeIn 0.3s ease-out;
        }

        .modal-content h3 {
            margin-top: 0;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 10px;
            margin-bottom: 20px;
            color: var(--primary-color);
        }

        .close-button {
            color: var(--text-color);
            position: absolute;
            top: 15px;
            right: 25px;
            font-size: 30px;
            font-weight: bold;
            cursor: pointer;
            transition: color 0.2s;
        }

        .close-button:hover,
        .close-button:focus {
            color: var(--primary-color);
            text-decoration: none;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* --- Utility & Responsive --- */
        .hidden {
            display: none !important;
        }

        .text-center {
            text-align: center;
        }

        .flex-between {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 10px;
        }

        .flex-gap-10 {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .alert {
            padding: 15px;
            margin-bottom: 20px;
            border-radius: var(--radius);
            font-weight: bold;
        }
        .alert-success {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        .alert-error {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .search-filter-bar {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        .search-filter-bar input, .search-filter-bar select {
            flex: 1;
            min-width: 150px;
        }

        footer {
            text-align: center;
            padding: 20px;
            margin-top: 40px;
            background-color: var(--card-bg);
            color: var(--text-color);
            border-top: 1px solid var(--border-color);
            font-size: 0.9em;
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .container {
                margin: 10px auto;
                padding: 0 10px;
            }
            header h1 {
                font-size: 1.5em;
            }
            nav button {
                padding: 12px 15px;
                font-size: 1em;
            }
            .content-section {
                padding: 20px;
            }
            .form-grid {
                grid-template-columns: 1fr;
            }
            .tournament-list {
                grid-template-columns: 1fr;
            }
            .tournament-detail-header {
                flex-direction: column;
                align-items: flex-start;
            }
            .tournament-detail-header .btn-group {
                width: 100%;
                justify-content: flex-start;
            }
            .bracket-visualizer {
                justify-content: flex-start;
            }
            .bracket-round-simple {
                margin-right: 20px;
            }
        }
    </style>
</head>
<body>
    <header>
        <h1>Ultimate Tournament Manager</h1>
        <button id="themeToggle" class="theme-toggle">ðŸ’¡</button>
    </header>

    <div class="container">
        <nav>
            <button id="navDashboard" class="active">Dashboard</button>
            <button id="navCreateTournament">Create Tournament</button>
            <button id="navImportExport">Import/Export</button>
        </nav>

        <main id="appContent">
            <!-- Dashboard Section -->
            <section id="dashboardSection" class="content-section">
                <h2>All Tournaments</h2>
                <div class="search-filter-bar">
                    <input type="text" id="tournamentSearch" placeholder="Search tournaments...">
                    <select id="tournamentFilterStatus">
                        <option value="">All Statuses</option>
                        <option value="Upcoming">Upcoming</option>
                        <option value="Active">Active</option>
                        <option value="Completed">Completed</option>
                    </select>
                    <select id="tournamentFilterSport">
                        <option value="">All Sports</option>
                        <option value="Football">Football</option>
                        <option value="Basketball">Basketball</option>
                        <option value="Tennis">Tennis</option>
                        <option value="Esports">Esports</option>
                        <option value="Chess">Chess</option>
                        <option value="Volleyball">Volleyball</option>
                        <option value="Badminton">Badminton</option>
                        <option value="Table Tennis">Table Tennis</option>
                        <option value="Cricket">Cricket</option>
                        <option value="Rugby">Rugby</option>
                        <option value="Hockey">Hockey</option>
                        <option value="Baseball">Baseball</option>
                        <option value="Softball">Softball</option>
                        <option value="Swimming">Swimming</option>
                        <option value="Athletics">Athletics</option>
                        <option value="Boxing">Boxing</option>
                        <option value="MMA">MMA</option>
                        <option value="Golf">Golf</option>
                        <option value="Darts">Darts</option>
                        <option value="Pool">Pool</option>
                        <option value="Other">Other</option>
                    </select>
                    <select id="tournamentFilterType">
                        <option value="">All Types</option>
                        <option value="Single Elimination">Single Elimination</option>
                        <option value="Double Elimination">Double Elimination</option>
                        <option value="Round Robin">Round Robin</option>
                        <option value="Multi-Stage">Multi-Stage</option>
                    </select>
                </div>
                <div id="tournamentList" class="tournament-list">
                    <p class="no-data">No tournaments created yet. Go to "Create Tournament" to get started!</p>
                </div>
            </section>

            <!-- Create Tournament Section -->
            <section id="createTournamentSection" class="content-section hidden">
                <h2>Create New Tournament</h2>
                <form id="createTournamentForm">
                    <div class="form-grid">
                        <div class="form-group">
                            <label for="tournamentName">Tournament Name <span style="color:red">*</span></label>
                            <input type="text" id="tournamentName" required>
                        </div>
                        <div class="form-group">
                            <label for="tournamentSport">Sport <span style="color:red">*</span></label>
                            <select id="tournamentSport" required>
                                <option value="">Select Sport</option>
                                <option value="Football">Football</option>
                                <option value="Basketball">Basketball</option>
                                <option value="Tennis">Tennis</option>
                                <option value="Esports">Esports</option>
                                <option value="Chess">Chess</option>
                                <option value="Volleyball">Volleyball</option>
                                <option value="Badminton">Badminton</option>
                                <option value="Table Tennis">Table Tennis</option>
                                <option value="Cricket">Cricket</option>
                                <option value="Rugby">Rugby</option>
                                <option value="Hockey">Hockey</option>
                                <option value="Baseball">Baseball</option>
                                <option value="Softball">Softball</option>
                                <option value="Swimming">Swimming</option>
                                <option value="Athletics">Athletics</option>
                                <option value="Boxing">Boxing</option>
                                <option value="MMA">MMA</option>
                                <option value="Golf">Golf</option>
                                <option value="Darts">Darts</option>
                                <option value="Pool">Pool</option>
                                <option value="Other">Other</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label for="tournamentType">Tournament Type <span style="color:red">*</span></label>
                            <select id="tournamentType" required>
                                <option value="">Select Type</option>
                                <option value="Single Elimination">Single Elimination</option>
                                <option value="Double Elimination">Double Elimination</option>
                                <option value="Round Robin">Round Robin</option>
                                <option value="Multi-Stage">Multi-Stage</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label for="tournamentStartDate">Start Date</label>
                            <input type="date" id="tournamentStartDate">
                        </div>
                        <div class="form-group">
                            <label for="tournamentEndDate">End Date</label>
                            <input type="date" id="tournamentEndDate">
                        </div>
                        <div class="form-group">
                            <label for="tournamentMaxParticipants">Max Participants</label>
                            <input type="number" id="tournamentMaxParticipants" min="2" placeholder="Optional">
                        </div>
                        <div class="form-group">
                            <label for="tournamentEntryFee">Entry Fee ($)</label>
                            <input type="number" id="tournamentEntryFee" min="0" step="0.01" value="0">
                        </div>
                        <div class="form-group">
                            <label for="tournamentPrizePool">Prize Pool ($)</label>
                            <input type="number" id="tournamentPrizePool" min="0" step="0.01" value="0">
                        </div>
                    </div>
                    <div class="form-group">
                        <label for="tournamentDescription">Description</label>
                        <textarea id="tournamentDescription" rows="3"></textarea>
                    </div>

                    <div class="checkbox-group">
                        <input type="checkbox" id="tournamentSetBasedScoring">
                        <label for="tournamentSetBasedScoring">Enable Set-Based Scoring (e.g., "3-0, 2-1")</label>
                    </div>

                    <div class="form-group">
                        <label for="tournamentPlayerStatsFields">Custom Player Stats Fields (comma-separated, e.g., Goals, Assists, Kills, Deaths)</label>
                        <input type="text" id="tournamentPlayerStatsFields" placeholder="e.g., Goals, Assists">
                    </div>

                    <div id="roundRobinSettings" class="hidden">
                        <h3>Round Robin Specific Settings</h3>
                        <div class="checkbox-group">
                            <input type="checkbox" id="rrEnableHomeAway">
                            <label for="rrEnableHomeAway">Enable Home/Away Games</label>
                        </div>
                        <div class="form-grid">
                            <div class="form-group">
                                <label for="rrPointsWin">Points for Win</label>
                                <input type="number" id="rrPointsWin" value="3" min="0">
                            </div>
                            <div class="form-group">
                                <label for="rrPointsDraw">Points for Draw</label>
                                <input type="number" id="rrPointsDraw" value="1" min="0">
                            </div>
                            <div class="form-group">
                                <label for="rrPointsLoss">Points for Loss</label>
                                <input type="number" id="rrPointsLoss" value="0" min="0">
                            </div>
                            <div class="form-group">
                                <label for="rrTieBreaker">Tie-breaker Preference</label>
                                <select id="rrTieBreaker">
                                    <option value="Head-to-Head">Head-to-Head</option>
                                    <option value="Score Difference">Score Difference</option>
                                    <option value="Score For">Score For</option>
                                    <option value="Random">Random</option>
                                </select>
                            </div>
                        </div>
                    </div>

                    <div class="btn-group">
                        <button type="submit" class="btn btn-primary">Create Tournament</button>
                        <button type="reset" class="btn btn-outline">Clear Form</button>
                    </div>
                </form>
            </section>

            <!-- Tournament Detail Section (Dynamically loaded) -->
            <section id="tournamentDetailSection" class="content-section hidden">
                <div class="tournament-detail-header">
                    <h2 id="detailTournamentName"></h2>
                    <div class="btn-group">
                        <button id="editTournamentBtn" class="btn btn-secondary">Edit Tournament</button>
                        <button id="deleteTournamentBtn" class="btn btn-danger">Delete Tournament</button>
                        <select id="changeTournamentStatus" class="btn btn-outline">
                            <option value="Upcoming">Set Upcoming</option>
                            <option value="Active">Set Active</option>
                            <option value="Completed">Set Completed</option>
                        </select>
                        <button id="showQrCodeBtn" class="btn btn-outline">Show QR Code</button>
                        <button id="backToDashboardBtn" class="btn btn-outline">Back to Dashboard</button>
                    </div>
                </div>

                <div class="tournament-info-grid" id="tournamentInfoDisplay">
                    <!-- Info items will be loaded here -->
                </div>

                <hr style="margin: 30px 0; border-color: var(--border-color);">

                <h3>Participants (<span id="participantCount">0</span>/<span id="maxParticipants">âˆž</span>)</h3>
                <div class="flex-between" style="margin-bottom: 15px;">
                    <div class="flex-gap-10">
                        <button id="addParticipantBtn" class="btn btn-primary">Add Participant</button>
                        <button id="bulkImportParticipantsBtn" class="btn btn-secondary">Bulk Import (CSV)</button>
                        <button id="copyParticipantsBtn" class="btn btn-secondary">Copy from Tournament</button>
                    </div>
                    <div class="flex-gap-10">
                        <button id="generateBracketBtn" class="btn btn-secondary hidden">Generate Bracket</button>
                        <button id="generateDoubleEliminationBracketBtn" class="btn btn-secondary hidden">Generate DE Bracket</button>
                        <button id="generateRoundRobinBtn" class="btn btn-secondary hidden">Generate Matches</button>
                        <button id="manageStagesBtn" class="btn btn-secondary hidden">Manage Stages</button>
                    </div>
                </div>
                <div id="participantsList" class="participants-list">
                    <p class="no-data">No participants added yet.</p>
                </div>

                <hr style="margin: 30px 0; border-color: var(--border-color);">

                <div id="bracketSection" class="hidden">
                    <h3>Bracket</h3>
                    <div id="bracketVisualizer" class="bracket-visualizer">
                        <p class="no-data">Bracket not generated. Add participants and click "Generate Bracket".</p>
                    </div>
                </div>

                <div id="doubleEliminationBracketSection" class="hidden">
                    <h3>Double Elimination Bracket</h3>
                    <div id="doubleEliminationWrapper" class="double-elimination-wrapper">
                        <p class="no-data">Double Elimination Bracket not generated. Add participants and click "Generate DE Bracket".</p>
                    </div>
                </div>

                <div id="roundRobinMatchesSection" class="hidden">
                    <h3>Matches</h3>
                    <div id="roundRobinMatches">
                        <p class="no-data">Matches not generated. Add participants and click "Generate Matches".</p>
                    </div>
                    <h3 style="margin-top: 30px;">Standings</h3>
                    <div id="roundRobinStandings">
                        <p class="no-data">Standings will appear after matches are generated and scores recorded.</p>
                    </div>
                </div>

                <div id="multiStageContainer" class="hidden">
                    <h3>Tournament Stages</h3>
                    <div id="stagesList">
                        <p class="no-data">No stages defined. Click "Manage Stages" to add them.</p>
                    </div>
                </div>
            </section>

            <!-- Import/Export Section -->
            <section id="importExportSection" class="content-section hidden">
                <h2>Import / Export Data</h2>
                <div class="form-group">
                    <label>Export All Tournament Data</label>
                    <button id="exportDataBtn" class="btn btn-primary">Download Data (JSON)</button>
                    <p style="font-size: 0.9em; margin-top: 5px; opacity: 0.8;">This will download all your tournament data as a JSON file.</p>
                </div>
                <hr style="margin: 30px 0; border-color: var(--border-color);">
                <div class="form-group">
                    <label for="importFileInput">Import Tournament Data</label>
                    <input type="file" id="importFileInput" accept=".json">
                    <button id="importDataBtn" class="btn btn-secondary" style="margin-top: 10px;">Upload & Import Data</button>
                    <p style="font-size: 0.9em; margin-top: 5px; opacity: 0.8;">Upload a JSON file to restore or add tournament data. Existing tournaments with the same ID will be overwritten.</p>
                </div>
            </section>
        </main>
    </div>

    <footer>
        <p>&copy; 2023 Ultimate Tournament Manager. All data saved locally in your browser.</p>
    </footer>

    <!-- Modals -->

    <!-- Add/Edit Participant Modal -->
    <div id="participantModal" class="modal">
        <div class="modal-content">
            <span class="close-button" onclick="closeModal('participantModal')">&times;</span>
            <h3 id="participantModalTitle">Add Participant</h3>
            <form id="participantForm">
                <input type="hidden" id="participantId">
                <div class="form-group">
                    <label for="participantName">Name / Team Name <span style="color:red">*</span></label>
                    <input type="text" id="participantName" required>
                </div>
                <div class="form-group">
                    <label for="participantSeed">Seed (for Elimination brackets)</label>
                    <input type="number" id="participantSeed" min="1" placeholder="Optional">
                </div>
                <div class="form-group">
                    <label for="participantContact">Contact Info</label>
                    <input type="text" id="participantContact" placeholder="Email, Phone, etc.">
                </div>
                <div class="form-group">
                    <label for="participantNotes">Notes</label>
                    <textarea id="participantNotes" rows="2"></textarea>
                </div>
                <div class="btn-group">
                    <button type="submit" class="btn btn-primary">Save Participant</button>
                    <button type="button" class="btn btn-outline" onclick="closeModal('participantModal')">Cancel</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Edit Tournament Modal -->
    <div id="editTournamentModal" class="modal">
        <div class="modal-content">
            <span class="close-button" onclick="closeModal('editTournamentModal')">&times;</span>
            <h3>Edit Tournament</h3>
            <form id="editTournamentForm">
                <input type="hidden" id="editTournamentId">
                <div class="form-grid">
                    <div class="form-group">
                        <label for="editTournamentName">Tournament Name <span style="color:red">*</span></label>
                        <input type="text" id="editTournamentName" required>
                    </div>
                    <div class="form-group">
                        <label for="editTournamentSport">Sport <span style="color:red">*</span></label>
                        <select id="editTournamentSport" required>
                            <option value="Football">Football</option>
                            <option value="Basketball">Basketball</option>
                            <option value="Tennis">Tennis</option>
                            <option value="Esports">Esports</option>
                            <option value="Chess">Chess</option>
                            <option value="Volleyball">Volleyball</option>
                            <option value="Badminton">Badminton</option>
                            <option value="Table Tennis">Table Tennis</option>
                            <option value="Cricket">Cricket</option>
                            <option value="Rugby">Rugby</option>
                            <option value="Hockey">Hockey</option>
                            <option value="Baseball">Baseball</option>
                            <option value="Softball">Softball</option>
                            <option value="Swimming">Swimming</option>
                            <option value="Athletics">Athletics</option>
                            <option value="Boxing">Boxing</option>
                            <option value="MMA">MMA</option>
                            <option value="Golf">Golf</option>
                            <option value="Darts">Darts</option>
                            <option value="Pool">Pool</option>
                            <option value="Other">Other</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label for="editTournamentType">Tournament Type <span style="color:red">*</span></label>
                        <select id="editTournamentType" required disabled>
                            <option value="Single Elimination">Single Elimination</option>
                            <option value="Double Elimination">Double Elimination</option>
                            <option value="Round Robin">Round Robin</option>
                            <option value="Multi-Stage">Multi-Stage</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label for="editTournamentStartDate">Start Date</label>
                        <input type="date" id="editTournamentStartDate">
                    </div>
                    <div class="form-group">
                        <label for="editTournamentEndDate">End Date</label>
                        <input type="date" id="editTournamentEndDate">
                    </div>
                    <div class="form-group">
                        <label for="editTournamentMaxParticipants">Max Participants</label>
                        <input type="number" id="editTournamentMaxParticipants" min="2">
                    </div>
                    <div class="form-group">
                        <label for="editTournamentEntryFee">Entry Fee ($)</label>
                        <input type="number" id="editTournamentEntryFee" min="0" step="0.01">
                    </div>
                    <div class="form-group">
                        <label for="editTournamentPrizePool">Prize Pool ($)</label>
                        <input type="number" id="editTournamentPrizePool" min="0" step="0.01">
                    </div>
                </div>
                <div class="form-group">
                    <label for="editTournamentDescription">Description</label>
                    <textarea id="editTournamentDescription" rows="3"></textarea>
                </div>

                <div class="checkbox-group">
                    <input type="checkbox" id="editTournamentSetBasedScoring">
                    <label for="editTournamentSetBasedScoring">Enable Set-Based Scoring (e.g., "3-0, 2-1")</label>
                </div>

                <div class="form-group">
                    <label for="editTournamentPlayerStatsFields">Custom Player Stats Fields (comma-separated, e.g., Goals, Assists, Kills, Deaths)</label>
                    <input type="text" id="editTournamentPlayerStatsFields" placeholder="e.g., Goals, Assists">
                </div>

                <div id="editRoundRobinSettings" class="hidden">
                    <h3>Round Robin Specific Settings</h3>
                    <div class="checkbox-group">
                        <input type="checkbox" id="editRrEnableHomeAway">
                        <label for="editRrEnableHomeAway">Enable Home/Away Games</label>
                    </div>
                    <div class="form-grid">
                        <div class="form-group">
                            <label for="editRrPointsWin">Points for Win</label>
                            <input type="number" id="editRrPointsWin" min="0">
                        </div>
                        <div class="form-group">
                            <label for="editRrPointsDraw">Points for Draw</label>
                            <input type="number" id="editRrPointsDraw" min="0">
                        </div>
                        <div class="form-group">
                            <label for="editRrPointsLoss">Points for Loss</label>
                            <input type="number" id="editRrPointsLoss" min="0">
                        </div>
                        <div class="form-group">
                            <label for="editRrTieBreaker">Tie-breaker Preference</label>
                            <select id="editRrTieBreaker">
                                <option value="Head-to-Head">Head-to-Head</option>
                                <option value="Score Difference">Score Difference</option>
                                <option value="Score For">Score For</option>
                                <option value="Random">Random</option>
                            </select>
                        </div>
                    </div>
                </div>

                <div class="btn-group">
                    <button type="submit" class="btn btn-primary">Save Changes</button>
                    <button type="button" class="btn btn-outline" onclick="closeModal('editTournamentModal')">Cancel</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Bulk Import Participants Modal -->
    <div id="bulkImportModal" class="modal">
        <div class="modal-content">
            <span class="close-button" onclick="closeModal('bulkImportModal')">&times;</span>
            <h3>Bulk Import Participants (CSV)</h3>
            <p>Upload a CSV file with participant names. Each name should be on a new line.</p>
            <div class="form-group">
                <label for="bulkImportFileInput">Select CSV File</label>
                <input type="file" id="bulkImportFileInput" accept=".csv">
            </div>
            <div class="btn-group">
                <button id="processBulkImportBtn" class="btn btn-primary">Import Participants</button>
                <button type="button" class="btn btn-outline" onclick="closeModal('bulkImportModal')">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Copy Participants Modal -->
    <div id="copyParticipantsModal" class="modal">
        <div class="modal-content">
            <span class="close-button" onclick="closeModal('copyParticipantsModal')">&times;</span>
            <h3>Copy Participants from Another Tournament</h3>
            <div class="form-group">
                <label for="copyFromTournamentSelect">Select Tournament to Copy From</label>
                <select id="copyFromTournamentSelect">
                    <option value="">-- Select a Tournament --</option>
                </select>
            </div>
            <div class="btn-group">
                <button id="processCopyParticipantsBtn" class="btn btn-primary">Copy Participants</button>
                <button type="button" class="btn btn-outline" onclick="closeModal('copyParticipantsModal')">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Match Details Modal (for editing schedule/stats) -->
    <div id="matchDetailsModal" class="modal">
        <div class="modal-content">
            <span class="close-button" onclick="closeModal('matchDetailsModal')">&times;</span>
            <h3 id="matchDetailsModalTitle">Match Details</h3>
            <form id="matchDetailsForm">
                <input type="hidden" id="matchDetailsMatchId">
                <input type="hidden" id="matchDetailsRoundIndex">
                <input type="hidden" id="matchDetailsBracketType"> <!-- 'rounds', 'winnerBracket', 'loserBracket', 'grandFinal', 'matches' -->
                <input type="hidden" id="matchDetailsStageId"> <!-- For multi-stage tournaments -->

                <div class="form-grid">
                    <div class="form-group">
                        <label for="matchDetailsPlayer1">Player 1</label>
                        <input type="text" id="matchDetailsPlayer1" disabled>
                    </div>
                    <div class="form-group">
                        <label for="matchDetailsPlayer2">Player 2</label>
                        <input type="text" id="matchDetailsPlayer2" disabled>
                    </div>
                    <div class="form-group">
                        <label for="matchDetailsDate">Date</label>
                        <input type="date" id="matchDetailsDate">
                    </div>
                    <div class="form-group">
                        <label for="matchDetailsTime">Time</label>
                        <input type="time" id="matchDetailsTime">
                    </div>
                    <div class="form-group">
                        <label for="matchDetailsVenue">Venue</label>
                        <input type="text" id="matchDetailsVenue" placeholder="e.g., Main Arena">
                    </div>
                    <div class="form-group">
                        <label for="matchDetailsReferee">Referee</label>
                        <input type="text" id="matchDetailsReferee" placeholder="e.g., John Doe">
                    </div>
                </div>

                <div id="matchDetailsPlayerStats" style="margin-top: 20px;">
                    <h4>Player Stats</h4>
                    <div id="player1StatsInputs" class="form-grid"></div>
                    <div id="player2StatsInputs" class="form-grid"></div>
                </div>

                <div class="btn-group">
                    <button type="submit" class="btn btn-primary">Save Match Details</button>
                    <button type="button" class="btn btn-outline" onclick="closeModal('matchDetailsModal')">Cancel</button>
                </div>
            </form>
        </div>
    </div>

    <!-- QR Code Modal -->
    <div id="qrCodeModal" class="modal">
        <div class="modal-content text-center">
            <span class="close-button" onclick="closeModal('qrCodeModal')">&times;</span>
            <h3>Tournament QR Code</h3>
            <p>Scan this QR code to quickly identify this tournament (e.g., for sharing its ID).</p>
            <div id="qrCodeContainer" style="margin: 20px auto; width: 200px; height: 200px;"></div>
            <p style="font-size: 0.9em; opacity: 0.8;">Tournament ID: <span id="qrTournamentId"></span></p>
        </div>
    </div>

    <!-- Manage Stages Modal -->
    <div id="manageStagesModal" class="modal">
        <div class="modal-content">
            <span class="close-button" onclick="closeModal('manageStagesModal')">&times;</span>
            <h3>Manage Stages</h3>
            <div id="currentStagesList">
                <p class="no-data">No stages added yet.</p>
            </div>
            <div class="btn-group">
                <button id="addStageBtn" class="btn btn-primary">Add New Stage</button>
            </div>
        </div>
    </div>

    <!-- Add/Edit Stage Modal -->
    <div id="stageModal" class="modal">
        <div class="modal-content">
            <span class="close-button" onclick="closeModal('stageModal')">&times;</span>
            <h3 id="stageModalTitle">Add Stage</h3>
            <form id="stageForm">
                <input type="hidden" id="stageId">
                <div class="form-group">
                    <label for="stageName">Stage Name <span style="color:red">*</span></label>
                    <input type="text" id="stageName" required>
                </div>
                <div class="form-group">
                    <label for="stageType">Stage Type <span style="color:red">*</span></label>
                    <select id="stageType" required>
                        <option value="">Select Type</option>
                        <option value="Single Elimination">Single Elimination</option>
                        <option value="Round Robin">Round Robin</option>
                    </select>
                </div>
                <div id="stageRoundRobinSettings" class="hidden">
                    <h4>Round Robin Specific Settings</h4>
                    <div class="checkbox-group">
                        <input type="checkbox" id="stageRrEnableHomeAway">
                        <label for="stageRrEnableHomeAway">Enable Home/Away Games</label>
                    </div>
                    <div class="form-grid">
                        <div class="form-group">
                            <label for="stageRrPointsWin">Points for Win</label>
                            <input type="number" id="stageRrPointsWin" value="3" min="0">
                        </div>
                        <div class="form-group">
                            <label for="stageRrPointsDraw">Points for Draw</label>
                            <input type="number" id="stageRrPointsDraw" value="1" min="0">
                        </div>
                        <div class="form-group">
                            <label for="stageRrPointsLoss">Points for Loss</label>
                            <input type="number" id="stageRrPointsLoss" value="0" min="0">
                        </div>
                        <div class="form-group">
                            <label for="stageRrTieBreaker">Tie-breaker Preference</label>
                            <select id="stageRrTieBreaker">
                                <option value="Head-to-Head">Head-to-Head</option>
                                <option value="Score Difference">Score Difference</option>
                                <option value="Score For">Score For</option>
                                <option value="Random">Random</option>
                            </select>
                        </div>
                    </div>
                </div>
                <div class="btn-group">
                    <button type="submit" class="btn btn-primary">Save Stage</button>
                    <button type="button" class="btn btn-outline" onclick="closeModal('stageModal')">Cancel</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Advance Participants Modal -->
    <div id="advanceParticipantsModal" class="modal">
        <div class="modal-content">
            <span class="close-button" onclick="closeModal('advanceParticipantsModal')">&times;</span>
            <h3>Advance Participants to Next Stage</h3>
            <p>Select participants from the current tournament's overall participant list to add to this stage.</p>
            <input type="hidden" id="advanceStageId">
            <div id="availableParticipantsList" class="participants-list" style="max-height: 300px; overflow-y: auto; border: 1px solid var(--border-color); padding: 10px; border-radius: var(--radius);">
                <!-- Checkboxes for participants -->
            </div>
            <div class="btn-group">
                <button id="processAdvanceParticipantsBtn" class="btn btn-primary">Add Selected Participants</button>
                <button type="button" class="btn btn-outline" onclick="closeModal('advanceParticipantsModal')">Cancel</button>
            </div>
        </div>
    </div>

    <script>
        // --- Inlined QR Code Generator (qrious.js - simplified for single file) ---
        // This is a very basic, self-contained QR code generator.
        // For more robust features, a full library would be used.
        // Source: https://github.com/neocotic/qrious (simplified)
        (function() {
            function QRCode(options) {
                options = options || {};
                this.value = options.value || '';
                this.size = options.size || 100;
                this.level = options.level || 'L'; // L, M, Q, H
                this.background = options.background || '#ffffff';
                this.foreground = options.foreground || '#000000';
                this.element = options.element || null;

                this.canvas = document.createElement('canvas');
                this.canvas.width = this.size;
                this.canvas.height = this.size;
                this.context = this.canvas.getContext('2d');

                if (this.element) {
                    this.element.appendChild(this.canvas);
                }

                this.update();
            }

            QRCode.prototype.update = function() {
                if (!this.value) {
                    this.context.clearRect(0, 0, this.size, this.size);
                    return;
                }

                // Simplified QR code generation (not a full QR library)
                // This will just draw a simple pattern for demonstration.
                // A real QR code library would involve complex encoding.
                // For this single HTML file, we'll draw a placeholder.
                this.context.fillStyle = this.background;
                this.context.fillRect(0, 0, this.size, this.size);
                this.context.fillStyle = this.foreground;

                const cellSize = this.size / 10; // Simple grid
                for (let i = 0; i < 10; i++) {
                    for (let j = 0; j < 10; j++) {
                        if ((i + j) % 2 === 0) {
                            this.context.fillRect(i * cellSize, j * cellSize, cellSize, cellSize);
                        }
                    }
                }
                this.context.font = `${this.size / 8}px Arial`;
                this.context.textAlign = 'center';
                this.context.textBaseline = 'middle';
                this.context.fillStyle = this.background;
                this.context.fillRect(this.size/4, this.size/2 - this.size/10, this.size/2, this.size/5);
                this.context.fillStyle = this.foreground;
                this.context.fillText("ID", this.size / 2, this.size / 2);
                // End of simplified placeholder

                // If you want a real QR code, you'd need a full library here.
                // Example with a real library (if you were to include it):
                /*
                const qr = new QRious({
                    value: this.value,
                    size: this.size,
                    level: this.level,
                    background: this.background,
                    foreground: this.foreground
                });
                this.context.drawImage(qr.canvas, 0, 0);
                */
            };

            window.QRCode = QRCode;
        })();
        // --- End Inlined QR Code Generator ---


        // --- Global State & Constants ---
        const LS_KEY = 'tournamentManagerData';
        const LS_THEME_KEY = 'tournamentManagerTheme';
        let tournaments = [];
        let currentTournamentId = null;

        const TOURNAMENT_TYPES = {
            SINGLE_ELIMINATION: 'Single Elimination',
            DOUBLE_ELIMINATION: 'Double Elimination',
            ROUND_ROBIN: 'Round Robin',
            MULTI_STAGE: 'Multi-Stage'
        };

        const TOURNAMENT_STATUS = {
            UPCOMING: 'Upcoming',
            ACTIVE: 'Active',
            COMPLETED: 'Completed'
        };

        // --- Utility Functions ---
        function generateUniqueId() {
            return Date.now().toString(36) + Math.random().toString(36).substr(2, 5);
        }

        function saveData() {
            localStorage.setItem(LS_KEY, JSON.stringify(tournaments));
        }

        function loadData() {
            const data = localStorage.getItem(LS_KEY);
            tournaments = data ? JSON.parse(data) : [];
            renderTournamentList();
        }

        function showSection(sectionId) {
            document.querySelectorAll('.content-section').forEach(section => {
                section.classList.add('hidden');
            });
            document.getElementById(sectionId).classList.remove('hidden');

            document.querySelectorAll('nav button').forEach(btn => {
                btn.classList.remove('active');
            });
            document.getElementById(`nav${sectionId.replace('Section', '')}`).classList.add('active');
        }

        function showAlert(message, type = 'success') {
            const alertDiv = document.createElement('div');
            alertDiv.className = `alert alert-${type}`;
            alertDiv.textContent = message;
            document.querySelector('.container').prepend(alertDiv);
            setTimeout(() => alertDiv.remove(), 5000);
        }

        function openModal(modalId) {
            document.getElementById(modalId).style.display = 'block';
        }

        function closeModal(modalId) {
            document.getElementById(modalId).style.display = 'none';
        }

        // --- Theme Toggle ---
        function applyTheme(theme) {
            document.body.classList.toggle('dark-mode', theme === 'dark');
            localStorage.setItem(LS_THEME_KEY, theme);
        }

        function toggleTheme() {
            const currentTheme = localStorage.getItem(LS_THEME_KEY) || 'light';
            applyTheme(currentTheme === 'light' ? 'dark' : 'light');
        }

        // --- Tournament Management ---
        function createTournament(event) {
            event.preventDefault();

            const name = document.getElementById('tournamentName').value;
            const sport = document.getElementById('tournamentSport').value;
            const type = document.getElementById('tournamentType').value;
            const startDate = document.getElementById('tournamentStartDate').value;
            const endDate = document.getElementById('tournamentEndDate').value;
            const maxParticipants = parseInt(document.getElementById('tournamentMaxParticipants').value) || null;
            const entryFee = parseFloat(document.getElementById('tournamentEntryFee').value) || 0;
            const prizePool = parseFloat(document.getElementById('tournamentPrizePool').value) || 0;
            const description = document.getElementById('tournamentDescription').value;
            const setBasedScoring = document.getElementById('tournamentSetBasedScoring').checked;
            const playerStatsFields = document.getElementById('tournamentPlayerStatsFields').value.split(',').map(s => s.trim()).filter(s => s);


            if (!name || !sport || !type) {
                showAlert('Please fill in all required fields (Name, Sport, Type).', 'error');
                return;
            }

            const newTournament = {
                id: generateUniqueId(),
                name, sport, type, startDate, endDate, description,
                maxParticipants, entryFee, prizePool,
                status: TOURNAMENT_STATUS.UPCOMING,
                participants: [], // Overall tournament participants
                rounds: [], // For single elimination
                winnerBracket: [], // For double elimination
                loserBracket: [], // For double elimination
                grandFinal: [], // For double elimination
                matches: [], // For round robin
                stages: [], // For multi-stage
                settings: {
                    setBasedScoring,
                    playerStatsFields
                }
            };

            if (type === TOURNAMENT_TYPES.ROUND_ROBIN) {
                newTournament.settings.enableHomeAway = document.getElementById('rrEnableHomeAway').checked;
                newTournament.settings.pointsWin = parseInt(document.getElementById('rrPointsWin').value) || 3;
                newTournament.settings.pointsDraw = parseInt(document.getElementById('rrPointsDraw').value) || 1;
                newTournament.settings.pointsLoss = parseInt(document.getElementById('rrPointsLoss').value) || 0;
                newTournament.settings.tieBreaker = document.getElementById('rrTieBreaker').value || 'Score Difference';
            }

            tournaments.push(newTournament);
            saveData();
            showAlert('Tournament created successfully!');
            document.getElementById('createTournamentForm').reset();
            renderTournamentList();
            showSection('dashboardSection');
        }

        function renderTournamentList() {
            const listDiv = document.getElementById('tournamentList');
            listDiv.innerHTML = '';

            const searchTerm = document.getElementById('tournamentSearch').value.toLowerCase();
            const filterStatus = document.getElementById('tournamentFilterStatus').value;
            const filterSport = document.getElementById('tournamentFilterSport').value;
            const filterType = document.getElementById('tournamentFilterType').value;

            const filteredTournaments = tournaments.filter(t => {
                const matchesSearch = t.name.toLowerCase().includes(searchTerm);
                const matchesStatus = filterStatus ? t.status === filterStatus : true;
                const matchesSport = filterSport ? t.sport === filterSport : true;
                const matchesType = filterType ? t.type === filterType : true;
                return matchesSearch && matchesStatus && matchesSport && matchesType;
            });

            if (filteredTournaments.length === 0) {
                listDiv.innerHTML = '<p class="no-data">No tournaments found matching your criteria.</p>';
                return;
            }

            filteredTournaments.forEach(tournament => {
                const card = document.createElement('div');
                card.className = 'tournament-card';
                card.innerHTML = `
                    <h3>${tournament.name}</h3>
                    <p><strong>Sport:</strong> ${tournament.sport}</p>
                    <p><strong>Type:</strong> ${tournament.type}</p>
                    <p><strong>Participants:</strong> ${tournament.participants.length} ${tournament.maxParticipants ? `/ ${tournament.maxParticipants}` : ''}</p>
                    <span class="status ${tournament.status.toLowerCase().replace(' ', '-')}">${tournament.status}</span>
                `;
                card.onclick = () => viewTournamentDetails(tournament.id);
                listDiv.appendChild(card);
            });
        }

        function viewTournamentDetails(id) {
            currentTournamentId = id;
            const tournament = tournaments.find(t => t.id === id);
            if (!tournament) {
                showAlert('Tournament not found!', 'error');
                showSection('dashboardSection');
                return;
            }

            document.getElementById('detailTournamentName').textContent = tournament.name;

            const infoDisplay = document.getElementById('tournamentInfoDisplay');
            infoDisplay.innerHTML = `
                <div class="tournament-info-item"><strong>Sport:</strong> ${tournament.sport}</div>
                <div class="tournament-info-item"><strong>Type:</strong> ${tournament.type}</div>
                <div class="tournament-info-item"><strong>Status:</strong> <span class="status ${tournament.status.toLowerCase().replace(' ', '-')}">${tournament.status}</span></div>
                <div class="tournament-info-item"><strong>Start Date:</strong> ${tournament.startDate || 'N/A'}</div>
                <div class="tournament-info-item"><strong>End Date:</strong> ${tournament.endDate || 'N/A'}</div>
                <div class="tournament-info-item"><strong>Max Participants:</strong> ${tournament.maxParticipants || 'Unlimited'}</div>
                <div class="tournament-info-item"><strong>Entry Fee:</strong> $${tournament.entryFee.toFixed(2)}</div>
                <div class="tournament-info-item"><strong>Prize Pool:</strong> $${tournament.prizePool.toFixed(2)}</div>
                <div class="tournament-info-item" style="grid-column: 1 / -1;"><strong>Description:</strong> ${tournament.description || 'No description.'}</div>
                <div class="tournament-info-item"><strong>Set-Based Scoring:</strong> ${tournament.settings.setBasedScoring ? 'Yes' : 'No'}</div>
                <div class="tournament-info-item"><strong>Player Stats:</strong> ${tournament.settings.playerStatsFields && tournament.settings.playerStatsFields.length > 0 ? tournament.settings.playerStatsFields.join(', ') : 'None'}</div>
            `;

            // Update status dropdown
            const statusSelect = document.getElementById('changeTournamentStatus');
            statusSelect.value = tournament.status;

            // Show/hide bracket/round robin/multi-stage sections and buttons
            document.getElementById('bracketSection').classList.add('hidden');
            document.getElementById('doubleEliminationBracketSection').classList.add('hidden');
            document.getElementById('roundRobinMatchesSection').classList.add('hidden');
            document.getElementById('multiStageContainer').classList.add('hidden');

            document.getElementById('generateBracketBtn').classList.add('hidden');
            document.getElementById('generateDoubleEliminationBracketBtn').classList.add('hidden');
            document.getElementById('generateRoundRobinBtn').classList.add('hidden');
            document.getElementById('manageStagesBtn').classList.add('hidden');


            if (tournament.type === TOURNAMENT_TYPES.SINGLE_ELIMINATION) {
                document.getElementById('bracketSection').classList.remove('hidden');
                document.getElementById('generateBracketBtn').classList.remove('hidden');
                renderBracket(tournament);
            } else if (tournament.type === TOURNAMENT_TYPES.DOUBLE_ELIMINATION) {
                document.getElementById('doubleEliminationBracketSection').classList.remove('hidden');
                document.getElementById('generateDoubleEliminationBracketBtn').classList.remove('hidden');
                renderDoubleEliminationBracket(tournament);
            } else if (tournament.type === TOURNAMENT_TYPES.ROUND_ROBIN) {
                document.getElementById('roundRobinMatchesSection').classList.remove('hidden');
                document.getElementById('generateRoundRobinBtn').classList.remove('hidden');
                renderRoundRobinMatches(tournament);
                renderRoundRobinStandings(tournament);
            } else if (tournament.type === TOURNAMENT_TYPES.MULTI_STAGE) {
                document.getElementById('multiStageContainer').classList.remove('hidden');
                document.getElementById('manageStagesBtn').classList.remove('hidden');
                renderMultiStages(tournament);
            }

            renderParticipantsList(tournament);
            showSection('tournamentDetailSection');
        }

        function editTournamentDetails() {
            const tournament = tournaments.find(t => t.id === currentTournamentId);
            if (!tournament) return;

            document.getElementById('editTournamentId').value = tournament.id;
            document.getElementById('editTournamentName').value = tournament.name;
            document.getElementById('editTournamentSport').value = tournament.sport;
            document.getElementById('editTournamentType').value = tournament.type; // Disabled, type cannot change
            document.getElementById('editTournamentStartDate').value = tournament.startDate;
            document.getElementById('editTournamentEndDate').value = tournament.endDate;
            document.getElementById('editTournamentMaxParticipants').value = tournament.maxParticipants;
            document.getElementById('editTournamentEntryFee').value = tournament.entryFee;
            document.getElementById('editTournamentPrizePool').value = tournament.prizePool;
            document.getElementById('editTournamentDescription').value = tournament.description;
            document.getElementById('editTournamentSetBasedScoring').checked = tournament.settings.setBasedScoring || false;
            document.getElementById('editTournamentPlayerStatsFields').value = (tournament.settings.playerStatsFields || []).join(', ');


            if (tournament.type === TOURNAMENT_TYPES.ROUND_ROBIN) {
                document.getElementById('editRoundRobinSettings').classList.remove('hidden');
                document.getElementById('editRrEnableHomeAway').checked = tournament.settings.enableHomeAway || false;
                document.getElementById('editRrPointsWin').value = tournament.settings.pointsWin;
                document.getElementById('editRrPointsDraw').value = tournament.settings.pointsDraw;
                document.getElementById('editRrPointsLoss').value = tournament.settings.pointsLoss;
                document.getElementById('editRrTieBreaker').value = tournament.settings.tieBreaker;
            } else {
                document.getElementById('editRoundRobinSettings').classList.add('hidden');
            }

            openModal('editTournamentModal');
        }

        function saveEditedTournament(event) {
            event.preventDefault();
            const id = document.getElementById('editTournamentId').value;
            const tournament = tournaments.find(t => t.id === id);
            if (!tournament) return;

            tournament.name = document.getElementById('editTournamentName').value;
            tournament.sport = document.getElementById('editTournamentSport').value;
            tournament.startDate = document.getElementById('editTournamentStartDate').value;
            tournament.endDate = document.getElementById('editTournamentEndDate').value;
            tournament.maxParticipants = parseInt(document.getElementById('editTournamentMaxParticipants').value) || null;
            tournament.entryFee = parseFloat(document.getElementById('editTournamentEntryFee').value) || 0;
            tournament.prizePool = parseFloat(document.getElementById('editTournamentPrizePool').value) || 0;
            tournament.description = document.getElementById('editTournamentDescription').value;
            tournament.settings.setBasedScoring = document.getElementById('editTournamentSetBasedScoring').checked;
            tournament.settings.playerStatsFields = document.getElementById('editTournamentPlayerStatsFields').value.split(',').map(s => s.trim()).filter(s => s);


            if (tournament.type === TOURNAMENT_TYPES.ROUND_ROBIN) {
                tournament.settings.enableHomeAway = document.getElementById('editRrEnableHomeAway').checked;
                tournament.settings.pointsWin = parseInt(document.getElementById('editRrPointsWin').value) || 3;
                tournament.settings.pointsDraw = parseInt(document.getElementById('editRrPointsDraw').value) || 1;
                tournament.settings.pointsLoss = parseInt(document.getElementById('editRrPointsLoss').value) || 0;
                tournament.settings.tieBreaker = document.getElementById('editRrTieBreaker').value || 'Score Difference';
            }

            saveData();
            showAlert('Tournament updated successfully!');
            closeModal('editTournamentModal');
            viewTournamentDetails(id); // Re-render details
        }

        function deleteTournament() {
            if (!confirm('Are you sure you want to delete this tournament and all its data?')) {
                return;
            }
            tournaments = tournaments.filter(t => t.id !== currentTournamentId);
            saveData();
            showAlert('Tournament deleted successfully!', 'danger');
            showSection('dashboardSection');
        }

        function changeTournamentStatus(event) {
            const newStatus = event.target.value;
            const tournament = tournaments.find(t => t.id === currentTournamentId);
            if (tournament) {
                tournament.status = newStatus;
                saveData();
                showAlert(`Tournament status changed to ${newStatus}.`);
                viewTournamentDetails(currentTournamentId); // Re-render details
            }
        }

        // --- Participant Management ---
        function renderParticipantsList(tournament) {
            const listDiv = document.getElementById('participantsList');
            listDiv.innerHTML = '';
            document.getElementById('participantCount').textContent = tournament.participants.length;
            document.getElementById('maxParticipants').textContent = tournament.maxParticipants || 'âˆž';

            if (tournament.participants.length === 0) {
                listDiv.innerHTML = '<p class="no-data">No participants added yet.</p>';
                return;
            }

            tournament.participants.sort((a, b) => (a.seed || Infinity) - (b.seed || Infinity)); // Sort by seed

            tournament.participants.forEach(p => {
                const item = document.createElement('div');
                item.className = 'participant-item';
                item.innerHTML = `
                    <div>
                        <strong>${p.name}</strong>
                        ${p.seed ? ` (Seed: ${p.seed})` : ''}
                        ${p.contact ? `<br><small>${p.contact}</small>` : ''}
                    </div>
                    <div class="actions">
                        <button class="btn btn-secondary" onclick="editParticipant('${p.id}')">Edit</button>
                        <button class="btn btn-danger" onclick="deleteParticipant('${p.id}')">Delete</button>
                    </div>
                `;
                listDiv.appendChild(item);
            });
        }

        function openAddParticipantModal() {
            document.getElementById('participantModalTitle').textContent = 'Add Participant';
            document.getElementById('participantForm').reset();
            document.getElementById('participantId').value = '';
            openModal('participantModal');
        }

        function addOrUpdateParticipant(event) {
            event.preventDefault();
            const tournament = tournaments.find(t => t.id === currentTournamentId);
            if (!tournament) return;

            const participantId = document.getElementById('participantId').value;
            const name = document.getElementById('participantName').value;
            const seed = parseInt(document.getElementById('participantSeed').value) || null;
            const contact = document.getElementById('participantContact').value;
            const notes = document.getElementById('participantNotes').value;

            if (!name) {
                showAlert('Participant name is required.', 'error');
                return;
            }

            if (tournament.maxParticipants && tournament.participants.length >= tournament.maxParticipants && !participantId) {
                showAlert(`Cannot add more participants. Max is ${tournament.maxParticipants}.`, 'error');
                return;
            }

            if (participantId) {
                // Update existing participant
                const participant = tournament.participants.find(p => p.id === participantId);
                if (participant) {
                    participant.name = name;
                    participant.seed = seed;
                    participant.contact = contact;
                    participant.notes = notes;
                    showAlert('Participant updated successfully!');
                }
            } else {
                // Add new participant
                const newParticipant = {
                    id: generateUniqueId(),
                    name, seed, contact, notes,
                    wins: 0, losses: 0, draws: 0, scoreFor: 0, scoreAgainst: 0, points: 0 // For Round Robin
                };
                tournament.participants.push(newParticipant);
                showAlert('Participant added successfully!');
            }

            saveData();
            renderParticipantsList(tournament);
            closeModal('participantModal');
        }

        function editParticipant(participantId) {
            const tournament = tournaments.find(t => t.id === currentTournamentId);
            const participant = tournament.participants.find(p => p.id === participantId);
            if (!participant) return;

            document.getElementById('participantModalTitle').textContent = 'Edit Participant';
            document.getElementById('participantId').value = participant.id;
            document.getElementById('participantName').value = participant.name;
            document.getElementById('participantSeed').value = participant.seed;
            document.getElementById('participantContact').value = participant.contact;
            document.getElementById('participantNotes').value = participant.notes;
            openModal('participantModal');
        }

        function deleteParticipant(participantId) {
            if (!confirm('Are you sure you want to delete this participant? This will also reset any generated brackets/matches in all stages.')) {
                return;
            }
            const tournament = tournaments.find(t => t.id === currentTournamentId);
            if (tournament) {
                tournament.participants = tournament.participants.filter(p => p.id !== participantId);
                // Reset all brackets/matches if participants change
                tournament.rounds = [];
                tournament.winnerBracket = [];
                tournament.loserBracket = [];
                tournament.grandFinal = [];
                tournament.matches = [];
                tournament.stages.forEach(stage => {
                    stage.participants = stage.participants.filter(pId => pId !== participantId);
                    stage.matches = [];
                    stage.rounds = [];
                });
                saveData();
                showAlert('Participant deleted successfully!', 'danger');
                viewTournamentDetails(currentTournamentId); // Re-render details
            }
        }

        function openBulkImportModal() {
            document.getElementById('bulkImportFileInput').value = '';
            openModal('bulkImportModal');
        }

        function processBulkImport() {
            const fileInput = document.getElementById('bulkImportFileInput');
            const file = fileInput.files[0];
            if (!file) {
                showAlert('Please select a CSV file.', 'error');
                return;
            }

            const reader = new FileReader();
            reader.onload = (e) => {
                const csv = e.target.result;
                const names = csv.split('\n').map(line => line.trim()).filter(line => line);
                const tournament = tournaments.find(t => t.id === currentTournamentId);

                if (!tournament) {
                    showAlert('Tournament not found.', 'error');
                    return;
                }

                let addedCount = 0;
                names.forEach(name => {
                    if (tournament.maxParticipants && tournament.participants.length >= tournament.maxParticipants) {
                        showAlert(`Max participants reached. Stopped importing at "${name}".`, 'error');
                        return;
                    }
                    tournament.participants.push({
                        id: generateUniqueId(),
                        name, seed: null, contact: '', notes: '',
                        wins: 0, losses: 0, draws: 0, scoreFor: 0, scoreAgainst: 0, points: 0
                    });
                    addedCount++;
                });

                saveData();
                showAlert(`${addedCount} participants imported successfully!`);
                renderParticipantsList(tournament);
                closeModal('bulkImportModal');
            };
            reader.readAsText(file);
        }

        function openCopyParticipantsModal() {
            const select = document.getElementById('copyFromTournamentSelect');
            select.innerHTML = '<option value="">-- Select a Tournament --</option>';
            tournaments.forEach(t => {
                if (t.id !== currentTournamentId) {
                    const option = document.createElement('option');
                    option.value = t.id;
                    option.textContent = t.name;
                    select.appendChild(option);
                }
            });
            openModal('copyParticipantsModal');
        }

        function processCopyParticipants() {
            const fromTournamentId = document.getElementById('copyFromTournamentSelect').value;
            if (!fromTournamentId) {
                showAlert('Please select a tournament to copy participants from.', 'error');
                return;
            }

            const sourceTournament = tournaments.find(t => t.id === fromTournamentId);
            const targetTournament = tournaments.find(t => t.id === currentTournamentId);

            if (!sourceTournament || !targetTournament) {
                showAlert('Source or target tournament not found.', 'error');
                return;
            }

            let copiedCount = 0;
            sourceTournament.participants.forEach(p => {
                if (targetTournament.maxParticipants && targetTournament.participants.length >= targetTournament.maxParticipants) {
                    showAlert(`Max participants reached in target tournament. Stopped copying.`, 'error');
                    return;
                }
                // Only copy if participant name doesn't already exist to avoid duplicates
                if (!targetTournament.participants.some(tp => tp.name === p.name)) {
                    targetTournament.participants.push({
                        id: generateUniqueId(), // New ID for the copied participant
                        name: p.name,
                        seed: p.seed,
                        contact: p.contact,
                        notes: p.notes,
                        wins: 0, losses: 0, draws: 0, scoreFor: 0, scoreAgainst: 0, points: 0
                    });
                    copiedCount++;
                }
            });

            saveData();
            showAlert(`${copiedCount} participants copied successfully!`);
            renderParticipantsList(targetTournament);
            closeModal('copyParticipantsModal');
        }

        // --- Elimination Bracket Logic (Common for SE & DE) ---
        function generateEliminationBracket(tournament, bracketType, stageId = null) {
            let participantsInStage;
            let targetBracket;
            let confirmMessage;

            if (stageId) {
                const stage = tournament.stages.find(s => s.id === stageId);
                if (!stage) return;
                participantsInStage = tournament.participants.filter(p => stage.participants.includes(p.id));
                targetBracket = stage.rounds;
                confirmMessage = `Bracket for stage "${stage.name}" already generated. Regenerating will clear all scores. Continue?`;
            } else {
                participantsInStage = tournament.participants;
                targetBracket = tournament.rounds;
                if (bracketType === TOURNAMENT_TYPES.DOUBLE_ELIMINATION) {
                    targetBracket = tournament.winnerBracket;
                }
                confirmMessage = 'Bracket already generated. Regenerating will clear all scores. Continue?';
            }

            if (participantsInStage.length < 2) {
                showAlert('Need at least 2 participants to generate a bracket.', 'error');
                return;
            }

            if (targetBracket.length > 0 && !confirm(confirmMessage)) {
                return;
            }

            // Clear existing brackets
            if (stageId) {
                const stage = tournament.stages.find(s => s.id === stageId);
                stage.rounds = [];
            } else {
                tournament.rounds = [];
                tournament.winnerBracket = [];
                tournament.loserBracket = [];
                tournament.grandFinal = [];
            }


            // Sort participants by seed, then randomly
            let sortedParticipants = [...participantsInStage].sort((a, b) => {
                if (a.seed && b.seed) return a.seed - b.seed;
                if (a.seed) return -1; // Seeded players first
                if (b.seed) return 1;
                return Math.random() - 0.5; // Random for unseeded
            });

            const numParticipants = sortedParticipants.length;
            let numRounds = Math.ceil(Math.log2(numParticipants));
            let totalSlots = Math.pow(2, numRounds);
            let byes = totalSlots - numParticipants;

            let currentParticipantsForPairing = [];
            // Assign byes to highest seeds first
            for (let i = 0; i < byes; i++) {
                currentParticipantsForPairing.push({ participant: sortedParticipants[i], bye: true });
            }
            // Add remaining participants
            for (let i = byes; i < numParticipants; i++) {
                currentParticipantsForPairing.push({ participant: sortedParticipants[i], bye: false });
            }

            // Shuffle the non-bye participants to mix them up, keeping byes at the start
            const nonByeParticipants = currentParticipantsForPairing.filter(p => !p.bye).sort(() => Math.random() - 0.5);
            currentParticipantsForPairing = currentParticipantsForPairing.filter(p => p.bye).concat(nonByeParticipants);

            // Create initial matches for Round 1
            let round1Matches = [];
            for (let i = 0; i < currentParticipantsForPairing.length; i += 2) {
                const p1 = currentParticipantsForPairing[i]?.participant;
                const p2 = currentParticipantsForPairing[i + 1]?.participant;

                if (p1 && p2) {
                    round1Matches.push(createMatchObject(p1.id, p2.id, tournament.settings.playerStatsFields));
                } else if (p1) { // Odd number of participants, last one gets a bye
                    round1Matches.push(createMatchObject(p1.id, null, tournament.settings.playerStatsFields, p1.id, 'Completed - Bye'));
                }
            }

            if (bracketType === TOURNAMENT_TYPES.SINGLE_ELIMINATION) {
                if (stageId) {
                    const stage = tournament.stages.find(s => s.id === stageId);
                    stage.rounds.push({ name: 'Round 1', matches: round1Matches });
                    for (let r = 1; r < numRounds; r++) {
                        let nextRoundMatches = [];
                        const numMatchesInRound = Math.ceil(round1Matches.length / Math.pow(2, r));
                        for (let i = 0; i < numMatchesInRound; i++) {
                            nextRoundMatches.push(createMatchObject(null, null, tournament.settings.playerStatsFields));
                        }
                        if (nextRoundMatches.length > 0) {
                            stage.rounds.push({ name: `Round ${r + 1}`, matches: nextRoundMatches });
                        }
                    }
                } else {
                    tournament.rounds.push({ name: 'Round 1', matches: round1Matches });
                    for (let r = 1; r < numRounds; r++) {
                        let nextRoundMatches = [];
                        const numMatchesInRound = Math.ceil(round1Matches.length / Math.pow(2, r));
                        for (let i = 0; i < numMatchesInRound; i++) {
                            nextRoundMatches.push(createMatchObject(null, null, tournament.settings.playerStatsFields));
                        }
                        if (nextRoundMatches.length > 0) {
                            tournament.rounds.push({ name: `Round ${r + 1}`, matches: nextRoundMatches });
                        }
                    }
                }
            } else if (bracketType === TOURNAMENT_TYPES.DOUBLE_ELIMINATION) {
                tournament.winnerBracket.push({ name: 'Winner\'s Round 1', matches: round1Matches });

                for (let r = 1; r < numRounds; r++) {
                    let nextRoundMatches = [];
                    const numMatchesInRound = Math.ceil(round1Matches.length / Math.pow(2, r));
                    for (let i = 0; i < numMatchesInRound; i++) {
                        nextRoundMatches.push(createMatchObject(null, null, tournament.settings.playerStatsFields));
                    }
                    if (nextRoundMatches.length > 0) {
                        tournament.winnerBracket.push({ name: `Winner\'s Round ${r + 1}`, matches: nextRoundMatches });
                    }
                }

                // Initialize Loser's Bracket (simplified)
                const numLoserRounds = numRounds * 2 - 2;
                for (let r = 0; r < numLoserRounds; r++) {
                    tournament.loserBracket.push({ name: `Loser\'s Round ${r + 1}`, matches: [] });
                }

                // Grand Final
                tournament.grandFinal.push({ name: 'Grand Final', matches: [createMatchObject(null, null, tournament.settings.playerStatsFields)] });
            }

            saveData();
            showAlert('Bracket generated successfully!');
            if (stageId) {
                renderMultiStages(tournament);
            } else if (bracketType === TOURNAMENT_TYPES.SINGLE_ELIMINATION) {
                renderBracket(tournament);
            } else {
                renderDoubleEliminationBracket(tournament);
            }
        }

        function createMatchObject(player1Id, player2Id, playerStatsFields, winnerId = null, status = 'Upcoming', homePlayerId = null, awayPlayerId = null) {
            const match = {
                id: generateUniqueId(),
                player1Id,
                player2Id,
                homePlayerId: homePlayerId || player1Id, // Default player1 is home
                awayPlayerId: awayPlayerId || player2Id, // Default player2 is away
                score1: null,
                score2: null,
                sets: null, // For set-based scoring
                winnerId,
                status,
                date: null,
                time: null,
                venue: null,
                referee: null,
                player1Stats: {},
                player2Stats: {}
            };
            playerStatsFields.forEach(field => {
                match.player1Stats[field] = null;
                match.player2Stats[field] = null;
            });
            return match;
        }

        function renderBracket(tournament, targetElementId = 'bracketVisualizer', roundsArray = tournament.rounds, stageId = null) {
            const bracketVisualizer = document.getElementById(targetElementId);
            bracketVisualizer.innerHTML = '';

            if (roundsArray.length === 0) {
                bracketVisualizer.innerHTML = '<p class="no-data">Bracket not generated. Add participants and click "Generate Bracket".</p>';
                return;
            }

            roundsArray.forEach((round, roundIndex) => {
                const roundDiv = document.createElement('div');
                roundDiv.className = 'bracket-round-simple';
                roundDiv.innerHTML = `<h4>${round.name}</h4>`;

                round.matches.forEach(match => {
                    roundDiv.appendChild(createMatchElementHTML(match, tournament, roundIndex, 'rounds', stageId));
                });
                bracketVisualizer.appendChild(roundDiv);
            });

            // Check for overall winner
            const lastRound = roundsArray[roundsArray.length - 1];
            if (lastRound && lastRound.matches.length === 1 && lastRound.matches[0].winnerId) {
                const winner = tournament.participants.find(p => p.id === lastRound.matches[0].winnerId);
                bracketVisualizer.insertAdjacentHTML('beforeend', `<h3 class="text-center" style="margin-top: 30px; color: var(--accent-color);">ðŸ† Tournament Winner: ${winner.name} ðŸ†</h3>`);
            }
        }

        function renderDoubleEliminationBracket(tournament) {
            const deWrapper = document.getElementById('doubleEliminationWrapper');
            deWrapper.innerHTML = '';

            if (tournament.winnerBracket.length === 0) {
                deWrapper.innerHTML = '<p class="no-data">Double Elimination Bracket not generated. Add participants and click "Generate DE Bracket".</p>';
                return;
            }

            // Render Winner's Bracket
            const wbDiv = document.createElement('div');
            wbDiv.innerHTML = '<h3>Winner\'s Bracket</h3>';
            const wbVisualizer = document.createElement('div');
            wbVisualizer.className = 'bracket-visualizer';
            tournament.winnerBracket.forEach((round, roundIndex) => {
                const roundDiv = document.createElement('div');
                roundDiv.className = 'bracket-round-simple';
                roundDiv.innerHTML = `<h4>${round.name}</h4>`;
                round.matches.forEach(match => {
                    roundDiv.appendChild(createMatchElementHTML(match, tournament, roundIndex, 'winnerBracket'));
                });
                wbVisualizer.appendChild(roundDiv);
            });
            wbDiv.appendChild(wbVisualizer);
            deWrapper.appendChild(wbDiv);

            // Render Loser's Bracket
            const lbDiv = document.createElement('div');
            lbDiv.innerHTML = '<h3>Loser\'s Bracket</h3>';
            const lbVisualizer = document.createElement('div');
            lbVisualizer.className = 'bracket-visualizer';
            tournament.loserBracket.forEach((round, roundIndex) => {
                const roundDiv = document.createElement('div');
                roundDiv.className = 'bracket-round-simple';
                roundDiv.innerHTML = `<h4>${round.name}</h4>`;
                round.matches.forEach(match => {
                    roundDiv.appendChild(createMatchElementHTML(match, tournament, roundIndex, 'loserBracket'));
                });
                lbVisualizer.appendChild(roundDiv);
            });
            lbDiv.appendChild(lbVisualizer);
            deWrapper.appendChild(lbDiv);

            // Render Grand Final
            const gfDiv = document.createElement('div');
            gfDiv.innerHTML = '<h3>Grand Final</h3>';
            const gfVisualizer = document.createElement('div');
            gfVisualizer.className = 'bracket-visualizer';
            tournament.grandFinal.forEach((round, roundIndex) => { // Grand Final is typically one round
                const roundDiv = document.createElement('div');
                roundDiv.className = 'bracket-round-simple';
                round.matches.forEach(match => {
                    roundDiv.appendChild(createMatchElementHTML(match, tournament, roundIndex, 'grandFinal'));
                });
                gfVisualizer.appendChild(roundDiv);
            });
            gfDiv.appendChild(gfVisualizer);
            deWrapper.appendChild(gfDiv);

            // Check for overall winner
            const grandFinalMatch = tournament.grandFinal[0]?.matches[0];
            if (grandFinalMatch && grandFinalMatch.winnerId) {
                const winner = tournament.participants.find(p => p.id === grandFinalMatch.winnerId);
                deWrapper.insertAdjacentHTML('beforeend', `<h3 class="text-center" style="margin-top: 30px; color: var(--accent-color);">ðŸ† Tournament Winner: ${winner.name} ðŸ†</h3>`);
            }
        }

        function createMatchElementHTML(match, tournament, roundIndex, bracketType, stageId = null) {
            const p1 = tournament.participants.find(p => p.id === match.player1Id);
            const p2 = tournament.participants.find(p => p.id === match.player2Id);

            const scoreInputHtml1 = p1 ? (tournament.settings.setBasedScoring ?
                `<input type="text" class="sets-input" value="${match.sets !== null ? match.sets.split('-')[0] : ''}" data-player="1" ${match.status !== 'Upcoming' ? 'disabled' : ''}>` :
                `<input type="number" class="score-input" value="${match.score1 !== null ? match.score1 : ''}" data-player="1" ${match.status !== 'Upcoming' ? 'disabled' : ''}>`) : '';
            const scoreInputHtml2 = p2 ? (tournament.settings.setBasedScoring ?
                `<input type="text" class="sets-input" value="${match.sets !== null ? match.sets.split('-')[1] : ''}" data-player="2" ${match.status !== 'Upcoming' ? 'disabled' : ''}>` :
                `<input type="number" class="score-input" value="${match.score2 !== null ? match.score2 : ''}" data-player="2" ${match.status !== 'Upcoming' ? 'disabled' : ''}>`) : '';

            const matchDiv = document.createElement('div');
            matchDiv.className = `bracket-match-simple ${match.winnerId ? 'winner' : ''}`;
            matchDiv.innerHTML = `
                <div class="player-line ${match.winnerId === p1?.id ? 'winner-player' : ''}">
                    <span>${p1 ? p1.name : 'TBD'}</span>
                    ${scoreInputHtml1}
                </div>
                <div class="player-line ${match.winnerId === p2?.id ? 'winner-player' : ''}">
                    <span>${p2 ? p2.name : 'TBD'}</span>
                    ${scoreInputHtml2}
                </div>
                <div class="match-actions">
                    <button class="btn btn-outline" onclick="openMatchDetailsModal('${match.id}', ${roundIndex}, '${bracketType}', '${stageId || ''}')">Details</button>
                    ${match.status === 'Upcoming' && p1 && p2 ? `<button class="btn btn-primary" onclick="recordEliminationScore('${match.id}', ${roundIndex}, '${bracketType}', '${stageId || ''}')">Record Score</button>` : ''}
                    ${match.status === 'Completed' ? `<span style="color: var(--primary-color); font-weight: bold;">Winner: ${tournament.participants.find(p => p.id === match.winnerId)?.name || 'N/A'}</span>` : ''}
                    ${match.status === 'Completed - Bye' ? `<span style="color: var(--secondary-color); font-weight: bold;">BYE - ${p1?.name || 'N/A'} Advances</span>` : ''}
                </div>
            `;
            return matchDiv;
        }

        function recordEliminationScore(matchId, roundIndex, bracketType, stageId = null) {
            const tournament = tournaments.find(t => t.id === currentTournamentId);
            if (!tournament) return;

            let bracket, currentParticipants;
            if (stageId) {
                const stage = tournament.stages.find(s => s.id === stageId);
                bracket = stage.rounds;
                currentParticipants = tournament.participants.filter(p => stage.participants.includes(p.id));
            } else {
                bracket = tournament[bracketType];
                currentParticipants = tournament.participants;
            }

            const round = bracket[roundIndex];
            const match = round.matches.find(m => m.id === matchId);
            if (!match) return;

            const matchElement = document.querySelector(`[onclick*="recordEliminationScore('${matchId}'"]`).closest('.bracket-match-simple');
            let score1, score2;

            if (tournament.settings.setBasedScoring) {
                const setsInput1 = matchElement.querySelector('input[data-player="1"]');
                const setsInput2 = matchElement.querySelector('input[data-player="2"]');
                const sets1 = parseInt(setsInput1.value);
                const sets2 = parseInt(setsInput2.value);

                if (isNaN(sets1) || isNaN(sets2)) {
                    showAlert('Please enter valid set scores for both players.', 'error');
                    return;
                }
                match.sets = `${sets1}-${sets2}`;
                score1 = sets1; // Use sets for winner determination
                score2 = sets2;
            } else {
                const scoreInput1 = matchElement.querySelector('input[data-player="1"]');
                const scoreInput2 = matchElement.querySelector('input[data-player="2"]');
                score1 = parseInt(scoreInput1.value);
                score2 = parseInt(scoreInput2.value);

                if (isNaN(score1) || isNaN(score2)) {
                    showAlert('Please enter valid scores for both players.', 'error');
                    return;
                }
                match.score1 = score1;
                match.score2 = score2;
            }

            let loserId = null;
            if (score1 > score2) {
                match.winnerId = match.player1Id;
                loserId = match.player2Id;
            } else if (score2 > score1) {
                match.winnerId = match.player2Id;
                loserId = match.player1Id;
            } else {
                showAlert('Scores cannot be tied in elimination brackets. Please enter a clear winner.', 'error');
                return;
            }
            match.status = 'Completed';

            // Advance winner and loser
            if (bracketType === 'rounds') { // Single Elimination
                if (roundIndex < bracket.length - 1) {
                    advanceWinner(bracket[roundIndex + 1].matches, match.winnerId);
                }
            } else if (bracketType === 'winnerBracket') { // Double Elimination - Winner's Bracket
                if (roundIndex < tournament.winnerBracket.length - 1) {
                    advanceWinner(tournament.winnerBracket[roundIndex + 1].matches, match.winnerId);
                } else { // Winner of WB goes to Grand Final
                    const grandFinalMatch = tournament.grandFinal[0]?.matches[0];
                    if (grandFinalMatch) {
                        grandFinalMatch.player1Id = match.winnerId; // WB winner is P1 in GF
                    }
                }
                // Send loser to Loser's Bracket
                if (loserId) {
                    // Simplified: Losers from WB Round N go to LB Round 2N-1 or 2N
                    const lbRoundIndex = roundIndex * 2; // This is a very simplified mapping
                    if (tournament.loserBracket[lbRoundIndex]) {
                        let foundSlot = false;
                        for (const lbMatch of tournament.loserBracket[lbRoundIndex].matches) {
                            if (!lbMatch.player1Id) { lbMatch.player1Id = loserId; foundSlot = true; break; }
                            if (!lbMatch.player2Id) { lbMatch.player2Id = loserId; foundSlot = true; break; }
                        }
                        if (!foundSlot) { // If no existing slot, create one
                            tournament.loserBracket[lbRoundIndex].matches.push(createMatchObject(loserId, null, tournament.settings.playerStatsFields));
                        }
                    } else { // Create new round if needed
                        tournament.loserBracket.push({ name: `Loser's Round ${tournament.loserBracket.length + 1}`, matches: [createMatchObject(loserId, null, tournament.settings.playerStatsFields)] });
                    }
                }
            } else if (bracketType === 'loserBracket') { // Double Elimination - Loser's Bracket
                if (roundIndex < tournament.loserBracket.length - 1) {
                    advanceWinner(tournament.loserBracket[roundIndex + 1].matches, match.winnerId);
                } else { // Winner of LB goes to Grand Final
                    const grandFinalMatch = tournament.grandFinal[0]?.matches[0];
                    if (grandFinalMatch) {
                        grandFinalMatch.player2Id = match.winnerId; // LB winner is P2 in GF
                    }
                }
            } else if (bracketType === 'grandFinal') {
                // Grand Final winner is tournament winner
            }

            saveData();
            showAlert(`Score recorded for match. ${currentParticipants.find(p => p.id === match.winnerId)?.name} advances!`);
            if (stageId) {
                renderMultiStages(tournament);
            } else if (bracketType === 'rounds') {
                renderBracket(tournament);
            } else {
                renderDoubleEliminationBracket(tournament);
            }
        }

        function advanceWinner(nextRoundMatches, winnerId) {
            let foundSlot = false;
            for (const nextMatch of nextRoundMatches) {
                if (!nextMatch.player1Id) {
                    nextMatch.player1Id = winnerId;
                    foundSlot = true;
                    break;
                } else if (!nextMatch.player2Id) {
                    nextMatch.player2Id = winnerId;
                    foundSlot = true;
                    break;
                }
            }
            // If no empty slot found, it means the bracket logic needs to be more robust
            // For now, we assume slots are available or created.
            // A more advanced system would pre-create empty matches for future rounds.
        }

        // --- Match Details Modal ---
        function openMatchDetailsModal(matchId, roundIndex, bracketType, stageId = null) {
            const tournament = tournaments.find(t => t.id === currentTournamentId);
            if (!tournament) return;

            let match;
            let participantsForMatch;

            if (stageId) {
                const stage = tournament.stages.find(s => s.id === stageId);
                if (bracketType === 'matches') { // RR stage
                    match = stage.matches.find(m => m.id === matchId);
                } else { // SE stage
                    match = stage.rounds[roundIndex].matches.find(m => m.id === matchId);
                }
                participantsForMatch = tournament.participants.filter(p => stage.participants.includes(p.id));
            } else {
                if (bracketType === 'matches') { // RR tournament
                    match = tournament.matches.find(m => m.id === matchId);
                } else { // SE/DE tournament
                    match = tournament[bracketType][roundIndex].matches.find(m => m.id === matchId);
                }
                participantsForMatch = tournament.participants;
            }

            if (!match) return;

            document.getElementById('matchDetailsModalTitle').textContent = `Match: ${participantsForMatch.find(p => p.id === match.player1Id)?.name || 'TBD'} vs ${participantsForMatch.find(p => p.id === match.player2Id)?.name || 'TBD'}`;
            document.getElementById('matchDetailsMatchId').value = match.id;
            document.getElementById('matchDetailsRoundIndex').value = roundIndex;
            document.getElementById('matchDetailsBracketType').value = bracketType;
            document.getElementById('matchDetailsStageId').value = stageId;

            document.getElementById('matchDetailsPlayer1').value = participantsForMatch.find(p => p.id === match.player1Id)?.name || 'BYE';
            document.getElementById('matchDetailsPlayer2').value = participantsForMatch.find(p => p.id === match.player2Id)?.name || 'BYE';
            document.getElementById('matchDetailsDate').value = match.date || '';
            document.getElementById('matchDetailsTime').value = match.time || '';
            document.getElementById('matchDetailsVenue').value = match.venue || '';
            document.getElementById('matchDetailsReferee').value = match.referee || '';

            // Render player stats inputs
            const player1StatsInputsDiv = document.getElementById('player1StatsInputs');
            const player2StatsInputsDiv = document.getElementById('player2StatsInputs');
            player1StatsInputsDiv.innerHTML = `<h4>${participantsForMatch.find(p => p.id === match.player1Id)?.name || 'Player 1'} Stats</h4>`;
            player2StatsInputsDiv.innerHTML = `<h4>${participantsForMatch.find(p => p.id === match.player2Id)?.name || 'Player 2'} Stats</h4>`;

            tournament.settings.playerStatsFields.forEach(field => {
                player1StatsInputsDiv.innerHTML += `
                    <div class="form-group">
                        <label for="p1_stat_${field}">${field}</label>
                        <input type="number" id="p1_stat_${field}" value="${match.player1Stats[field] !== null ? match.player1Stats[field] : ''}" data-player="1" data-stat="${field}">
                    </div>
                `;
                player2StatsInputsDiv.innerHTML += `
                    <div class="form-group">
                        <label for="p2_stat_${field}">${field}</label>
                        <input type="number" id="p2_stat_${field}" value="${match.player2Stats[field] !== null ? match.player2Stats[field] : ''}" data-player="2" data-stat="${field}">
                    </div>
                `;
            });

            openModal('matchDetailsModal');
        }

        function saveMatchDetails(event) {
            event.preventDefault();
            const tournament = tournaments.find(t => t.id === currentTournamentId);
            if (!tournament) return;

            const matchId = document.getElementById('matchDetailsMatchId').value;
            const roundIndex = parseInt(document.getElementById('matchDetailsRoundIndex').value);
            const bracketType = document.getElementById('matchDetailsBracketType').value;
            const stageId = document.getElementById('matchDetailsStageId').value;

            let match;
            if (stageId) {
                const stage = tournament.stages.find(s => s.id === stageId);
                if (bracketType === 'matches') {
                    match = stage.matches.find(m => m.id === matchId);
                } else {
                    match = stage.rounds[roundIndex].matches.find(m => m.id === matchId);
                }
            } else {
                if (bracketType === 'matches') {
                    match = tournament.matches.find(m => m.id === matchId);
                } else {
                    match = tournament[bracketType][roundIndex].matches.find(m => m.id === matchId);
                }
            }

            if (!match) return;

            match.date = document.getElementById('matchDetailsDate').value;
            match.time = document.getElementById('matchDetailsTime').value;
            match.venue = document.getElementById('matchDetailsVenue').value;
            match.referee = document.getElementById('matchDetailsReferee').value;

            // Save player stats
            tournament.settings.playerStatsFields.forEach(field => {
                match.player1Stats[field] = parseInt(document.getElementById(`p1_stat_${field}`).value) || 0;
                match.player2Stats[field] = parseInt(document.getElementById(`p2_stat_${field}`).value) || 0;
            });

            saveData();
            showAlert('Match details updated successfully!');
            closeModal('matchDetailsModal');
            if (stageId) {
                renderMultiStages(tournament);
            } else if (bracketType === 'rounds') {
                renderBracket(tournament);
            } else if (bracketType === 'winnerBracket' || bracketType === 'loserBracket' || bracketType === 'grandFinal') {
                renderDoubleEliminationBracket(tournament);
            } else if (bracketType === 'matches') { // For Round Robin
                renderRoundRobinMatches(tournament);
                renderRoundRobinStandings(tournament);
            }
        }

        // --- Round Robin Logic ---
        function generateRoundRobinMatches(tournament, stageId = null) {
            let participantsInStage;
            let matchesArray;
            let rrSettings;
            let confirmMessage;

            if (stageId) {
                const stage = tournament.stages.find(s => s.id === stageId);
                if (!stage) return;
                participantsInStage = tournament.participants.filter(p => stage.participants.includes(p.id));
                matchesArray = stage.matches;
                rrSettings = stage.settings;
                confirmMessage = `Matches for stage "${stage.name}" already generated. Regenerating will clear all scores. Continue?`;
            } else {
                participantsInStage = tournament.participants;
                matchesArray = tournament.matches;
                rrSettings = tournament.settings;
                confirmMessage = 'Matches already generated. Regenerating will clear all scores. Continue?';
            }

            if (participantsInStage.length < 2) {
                showAlert('Need at least 2 participants to generate matches.', 'error');
                return;
            }

            if (matchesArray.length > 0 && !confirm(confirmMessage)) {
                return;
            }

            // Clear existing matches
            if (stageId) {
                const stage = tournament.stages.find(s => s.id === stageId);
                stage.matches = [];
            } else {
                tournament.matches = [];
            }

            const participants = participantsInStage;
            const numParticipants = participants.length;

            for (let i = 0; i < numParticipants; i++) {
                for (let j = i + 1; j < numParticipants; j++) {
                    // Match 1: P[i] vs P[j] (P[i] is home)
                    matchesArray.push(createMatchObject(participants[i].id, participants[j].id, tournament.settings.playerStatsFields, null, 'Upcoming', participants[i].id, participants[j].id));
                    if (rrSettings.enableHomeAway) {
                        // Match 2: P[j] vs P[i] (P[j] is home)
                        matchesArray.push(createMatchObject(participants[j].id, participants[i].id, tournament.settings.playerStatsFields, null, 'Upcoming', participants[j].id, participants[i].id));
                    }
                }
            }
            saveData();
            showAlert('Round Robin matches generated successfully!');
            if (stageId) {
                renderMultiStages(tournament);
            } else {
                renderRoundRobinMatches(tournament);
                renderRoundRobinStandings(tournament);
            }
        }

        function renderRoundRobinMatches(tournament, targetElementId = 'roundRobinMatches', matchesArray = tournament.matches, participantsArray = tournament.participants, rrSettings = tournament.settings, stageId = null) {
            const matchesDiv = document.getElementById(targetElementId);
            matchesDiv.innerHTML = '';

            if (matchesArray.length === 0) {
                matchesDiv.innerHTML = '<p class="no-data">Matches not generated. Add participants and click "Generate Matches".</p>';
                return;
            }

            const table = document.createElement('table');
            table.className = 'round-robin-table';
            table.innerHTML = `
                <thead>
                    <tr>
                        <th>Match</th>
                        <th>Home Player</th>
                        <th>Score</th>
                        <th>Away Player</th>
                        <th>Status</th>
                        <th>Schedule</th>
                        <th>Actions</th>
                    </tr>
                </thead>
                <tbody></tbody>
            `;
            const tbody = table.querySelector('tbody');

            matchesArray.forEach(match => {
                const p1 = participantsArray.find(p => p.id === match.player1Id);
                const p2 = participantsArray.find(p => p.id === match.player2Id);
                const homePlayer = participantsArray.find(p => p.id === match.homePlayerId);
                const awayPlayer = participantsArray.find(p => p.id === match.awayPlayerId);

                const scoreInputHtml1 = tournament.settings.setBasedScoring ?
                    `<input type="text" class="sets-input" value="${match.sets !== null ? match.sets.split('-')[0] : ''}" data-match-id="${match.id}" data-player="1" ${match.status !== 'Upcoming' ? 'disabled' : ''}>` :
                    `<input type="number" class="score-input" value="${match.score1 !== null ? match.score1 : ''}" data-match-id="${match.id}" data-player="1" ${match.status !== 'Upcoming' ? 'disabled' : ''}>`;
                const scoreInputHtml2 = tournament.settings.setBasedScoring ?
                    `<input type="text" class="sets-input" value="${match.sets !== null ? match.sets.split('-')[1] : ''}" data-match-id="${match.id}" data-player="2" ${match.status !== 'Upcoming' ? 'disabled' : ''}>` :
                    `<input type="number" class="score-input" value="${match.score2 !== null ? match.score2 : ''}" data-match-id="${match.id}" data-player="2" ${match.status !== 'Upcoming' ? 'disabled' : ''}>`;

                const row = document.createElement('tr');
                row.innerHTML = `
                    <td>${homePlayer?.name || 'N/A'} vs ${awayPlayer?.name || 'N/A'}</td>
                    <td>${homePlayer?.name || 'N/A'}</td>
                    <td>
                        ${scoreInputHtml1}
                        -
                        ${scoreInputHtml2}
                    </td>
                    <td>${awayPlayer?.name || 'N/A'}</td>
                    <td>${match.status}</td>
                    <td>${match.date || 'N/A'} ${match.time || ''}</td>
                    <td>
                        <button class="btn btn-outline btn-sm" onclick="openMatchDetailsModal('${match.id}', 0, 'matches', '${stageId || ''}')">Details</button>
                        ${match.status === 'Upcoming' ? `<button class="btn btn-primary btn-sm" onclick="recordRoundRobinScore('${match.id}', '${stageId || ''}')">Record</button>` : ''}
                        ${match.status === 'Completed' ? `<span style="color: var(--primary-color); font-weight: bold;">Winner: ${participantsArray.find(p => p.id === match.winnerId)?.name || 'Draw'}</span>` : ''}
                    </td>
                `;
                tbody.appendChild(row);
            });
            matchesDiv.appendChild(table);
        }

        function recordRoundRobinScore(matchId, stageId = null) {
            const tournament = tournaments.find(t => t.id === currentTournamentId);
            if (!tournament) return;

            let matchesArray;
            if (stageId) {
                const stage = tournament.stages.find(s => s.id === stageId);
                matchesArray = stage.matches;
            } else {
                matchesArray = tournament.matches;
            }

            const match = matchesArray.find(m => m.id === matchId);
            if (!match) return;

            const scoreInput1 = document.querySelector(`input[data-match-id="${matchId}"][data-player="1"]`);
            const scoreInput2 = document.querySelector(`input[data-match-id="${matchId}"][data-player="2"]`);

            let score1, score2;
            if (tournament.settings.setBasedScoring) {
                const sets1 = parseInt(scoreInput1.value);
                const sets2 = parseInt(scoreInput2.value);
                if (isNaN(sets1) || isNaN(sets2)) {
                    showAlert('Please enter valid set scores for both players.', 'error');
                    return;
                }
                match.sets = `${sets1}-${sets2}`;
                score1 = sets1;
                score2 = sets2;
            } else {
                score1 = parseInt(scoreInput1.value);
                score2 = parseInt(scoreInput2.value);
                if (isNaN(score1) || isNaN(score2)) {
                    showAlert('Please enter valid scores for both players.', 'error');
                    return;
                }
                match.score1 = score1;
                match.score2 = score2;
            }

            if (score1 > score2) {
                match.winnerId = match.player1Id;
            } else if (score2 > score1) {
                match.winnerId = match.player2Id;
            } else {
                match.winnerId = null; // Draw
            }
            match.status = 'Completed';

            saveData();
            showAlert('Score recorded successfully!');
            if (stageId) {
                renderMultiStages(tournament);
            } else {
                renderRoundRobinMatches(tournament);
                renderRoundRobinStandings(tournament);
            }
        }

        function renderRoundRobinStandings(tournament, targetElementId = 'roundRobinStandings', matchesArray = tournament.matches, participantsArray = tournament.participants, rrSettings = tournament.settings) {
            const standingsDiv = document.getElementById(targetElementId);
            standingsDiv.innerHTML = '';

            if (matchesArray.length === 0) {
                standingsDiv.innerHTML = '<p class="no-data">Standings will appear after matches are generated and scores recorded.</p>';
                return;
            }

            const participantStats = {};
            participantsArray.forEach(p => {
                participantStats[p.id] = {
                    id: p.id,
                    name: p.name,
                    wins: 0, losses: 0, draws: 0,
                    scoreFor: 0, scoreAgainst: 0,
                    scoreDiff: 0,
                    points: 0
                };
                tournament.settings.playerStatsFields.forEach(field => {
                    participantStats[p.id][field] = 0;
                });
            });

            matchesArray.forEach(match => {
                if (match.status === 'Completed') {
                    const p1Stats = participantStats[match.player1Id];
                    const p2Stats = participantStats[match.player2Id];

                    if (!p1Stats || !p2Stats) return; // Should not happen

                    let score1 = tournament.settings.setBasedScoring ? parseInt(match.sets.split('-')[0]) : match.score1;
                    let score2 = tournament.settings.setBasedScoring ? parseInt(match.sets.split('-')[1]) : match.score2;

                    p1Stats.scoreFor += score1;
                    p1Stats.scoreAgainst += score2;
                    p2Stats.scoreFor += score2;
                    p2Stats.scoreAgainst += score1;

                    tournament.settings.playerStatsFields.forEach(field => {
                        p1Stats[field] += match.player1Stats[field] || 0;
                        p2Stats[field] += match.player2Stats[field] || 0;
                    });

                    if (match.winnerId === match.player1Id) {
                        p1Stats.wins++;
                        p2Stats.losses++;
                        p1Stats.points += rrSettings.pointsWin;
                        p2Stats.points += rrSettings.pointsLoss;
                    } else if (match.winnerId === match.player2Id) {
                        p2Stats.wins++;
                        p1Stats.losses++;
                        p2Stats.points += rrSettings.pointsWin;
                        p1Stats.points += rrSettings.pointsLoss;
                    } else { // Draw
                        p1Stats.draws++;
                        p2Stats.draws++;
                        p1Stats.points += rrSettings.pointsDraw;
                        p2Stats.points += rrSettings.pointsDraw;
                    }
                }
            });

            let standings = Object.values(participantStats);

            // Calculate score difference
            standings.forEach(stats => {
                stats.scoreDiff = stats.scoreFor - stats.scoreAgainst;
            });

            // Sort standings
            standings.sort((a, b) => {
                if (b.points !== a.points) return b.points - a.points;
                // Tie-breaking rules
                switch (rrSettings.tieBreaker) {
                    case 'Score Difference':
                        return b.scoreDiff - a.scoreDiff;
                    case 'Score For':
                        return b.scoreFor - a.scoreFor;
                    case 'Head-to-Head':
                        // Simplified: For a true head-to-head, you'd need to filter matches between tied players
                        // and calculate a mini-standings. For simplicity, we'll just use score diff if H2H is chosen.
                        return b.scoreDiff - a.scoreDiff;
                    case 'Random':
                    default:
                        return Math.random() - 0.5;
                }
            });

            const table = document.createElement('table');
            table.className = 'standings-table';
            let headerHtml = `
                <thead>
                    <tr>
                        <th>Rank</th>
                        <th>Participant</th>
                        <th>W</th>
                        <th>L</th>
                        <th>D</th>
                        <th>GF</th>
                        <th>GA</th>
                        <th>GD</th>
            `;
            tournament.settings.playerStatsFields.forEach(field => {
                headerHtml += `<th>${field}</th>`;
            });
            headerHtml += `<th>Pts</th></tr></thead><tbody></tbody>`;
            table.innerHTML = headerHtml;
            const tbody = table.querySelector('tbody');

            standings.forEach((stats, index) => {
                let rowHtml = `
                    <td class="rank">${index + 1}</td>
                    <td>${stats.name}</td>
                    <td>${stats.wins}</td>
                    <td>${stats.losses}</td>
                    <td>${stats.draws}</td>
                    <td>${stats.scoreFor}</td>
                    <td>${stats.scoreAgainst}</td>
                    <td>${stats.scoreDiff}</td>
                `;
                tournament.settings.playerStatsFields.forEach(field => {
                    rowHtml += `<td>${stats[field]}</td>`;
                });
                rowHtml += `<td>${stats.points}</td>`;

                const row = document.createElement('tr');
                row.innerHTML = rowHtml;
                tbody.appendChild(row);
            });
            standingsDiv.appendChild(table);
        }

        // --- Multi-Stage Management ---
        function renderMultiStages(tournament) {
            const stagesListDiv = document.getElementById('stagesList');
            stagesListDiv.innerHTML = '';

            if (tournament.stages.length === 0) {
                stagesListDiv.innerHTML = '<p class="no-data">No stages defined. Click "Manage Stages" to add them.</p>';
                return;
            }

            tournament.stages.forEach(stage => {
                const stageCard = document.createElement('div');
                stageCard.className = 'stage-card';
                stageCard.innerHTML = `
                    <div class="flex-between">
                        <h4>${stage.name} (${stage.type})</h4>
                        <div class="btn-group">
                            <button class="btn btn-secondary btn-sm" onclick="editStage('${stage.id}')">Edit Stage</button>
                            <button class="btn btn-danger btn-sm" onclick="deleteStage('${stage.id}')">Delete Stage</button>
                            <button class="btn btn-outline btn-sm" onclick="openAdvanceParticipantsModal('${stage.id}')">Add Participants</button>
                            ${stage.type === TOURNAMENT_TYPES.ROUND_ROBIN ?
                                `<button class="btn btn-primary btn-sm" onclick="generateRoundRobinMatches(tournaments.find(t => t.id === currentTournamentId), '${stage.id}')">Generate Matches</button>` :
                                `<button class="btn btn-primary btn-sm" onclick="generateEliminationBracket(tournaments.find(t => t.id === currentTournamentId), '${TOURNAMENT_TYPES.SINGLE_ELIMINATION}', '${stage.id}')">Generate Bracket</button>`
                            }
                        </div>
                    </div>
                    <p>Participants: ${stage.participants.length} / ${tournament.participants.length}</p>
                    <div class="stage-content" id="stageContent_${stage.id}">
                        <!-- Stage specific content will be rendered here -->
                    </div>
                `;
                stagesListDiv.appendChild(stageCard);

                const stageContentDiv = document.getElementById(`stageContent_${stage.id}`);
                const stageParticipants = tournament.participants.filter(p => stage.participants.includes(p.id));

                if (stage.type === TOURNAMENT_TYPES.ROUND_ROBIN) {
                    const matchesDiv = document.createElement('div');
                    matchesDiv.id = `stageMatches_${stage.id}`;
                    stageContentDiv.appendChild(matchesDiv);
                    renderRoundRobinMatches(tournament, `stageMatches_${stage.id}`, stage.matches, stageParticipants, stage.settings, stage.id);

                    const standingsDiv = document.createElement('div');
                    standingsDiv.id = `stageStandings_${stage.id}`;
                    stageContentDiv.appendChild(standingsDiv);
                    renderRoundRobinStandings(tournament, `stageStandings_${stage.id}`, stage.matches, stageParticipants, stage.settings);
                } else if (stage.type === TOURNAMENT_TYPES.SINGLE_ELIMINATION) {
                    const bracketDiv = document.createElement('div');
                    bracketDiv.className = 'bracket-visualizer';
                    bracketDiv.id = `stageBracket_${stage.id}`;
                    stageContentDiv.appendChild(bracketDiv);
                    renderBracket(tournament, `stageBracket_${stage.id}`, stage.rounds, stage.id);
                }
            });
        }

        function openManageStagesModal() {
            renderCurrentStagesList();
            openModal('manageStagesModal');
        }

        function renderCurrentStagesList() {
            const listDiv = document.getElementById('currentStagesList');
            listDiv.innerHTML = '';
            const tournament = tournaments.find(t => t.id === currentTournamentId);
            if (!tournament || tournament.stages.length === 0) {
                listDiv.innerHTML = '<p class="no-data">No stages added yet.</p>';
                return;
            }

            tournament.stages.forEach(stage => {
                const item = document.createElement('div');
                item.className = 'participant-item'; // Reusing style
                item.innerHTML = `
                    <div>
                        <strong>${stage.name}</strong> (${stage.type})
                        <br><small>Participants: ${stage.participants.length}</small>
                    </div>
                    <div class="actions">
                        <button class="btn btn-secondary" onclick="editStage('${stage.id}')">Edit</button>
                        <button class="btn btn-danger" onclick="deleteStage('${stage.id}')">Delete</button>
                    </div>
                `;
                listDiv.appendChild(item);
            });
        }

        function openAddStageModal() {
            document.getElementById('stageModalTitle').textContent = 'Add Stage';
            document.getElementById('stageForm').reset();
            document.getElementById('stageId').value = '';
            document.getElementById('stageRoundRobinSettings').classList.add('hidden');
            openModal('stageModal');
        }

        function addOrUpdateStage(event) {
            event.preventDefault();
            const tournament = tournaments.find(t => t.id === currentTournamentId);
            if (!tournament) return;

            const stageId = document.getElementById('stageId').value;
            const name = document.getElementById('stageName').value;
            const type = document.getElementById('stageType').value;

            if (!name || !type) {
                showAlert('Stage name and type are required.', 'error');
                return;
            }

            const stageSettings = {};
            if (type === TOURNAMENT_TYPES.ROUND_ROBIN) {
                stageSettings.enableHomeAway = document.getElementById('stageRrEnableHomeAway').checked;
                stageSettings.pointsWin = parseInt(document.getElementById('stageRrPointsWin').value) || 3;
                stageSettings.pointsDraw = parseInt(document.getElementById('stageRrPointsDraw').value) || 1;
                stageSettings.pointsLoss = parseInt(document.getElementById('stageRrPointsLoss').value) || 0;
                stageSettings.tieBreaker = document.getElementById('stageRrTieBreaker').value || 'Score Difference';
            }

            if (stageId) {
                const stage = tournament.stages.find(s => s.id === stageId);
                if (stage) {
                    stage.name = name;
                    stage.type = type;
                    stage.settings = stageSettings;
                    showAlert('Stage updated successfully!');
                }
            } else {
                const newStage = {
                    id: generateUniqueId(),
                    name, type,
                    participants: [], // Participants for this specific stage
                    matches: [], // For RR
                    rounds: [], // For SE
                    settings: stageSettings
                };
                tournament.stages.push(newStage);
                showAlert('Stage added successfully!');
            }

            saveData();
            renderMultiStages(tournament);
            renderCurrentStagesList();
            closeModal('stageModal');
        }

        function editStage(stageId) {
            const tournament = tournaments.find(t => t.id === currentTournamentId);
            const stage = tournament.stages.find(s => s.id === stageId);
            if (!stage) return;

            document.getElementById('stageModalTitle').textContent = 'Edit Stage';
            document.getElementById('stageId').value = stage.id;
            document.getElementById('stageName').value = stage.name;
            document.getElementById('stageType').value = stage.type;

            if (stage.type === TOURNAMENT_TYPES.ROUND_ROBIN) {
                document.getElementById('stageRoundRobinSettings').classList.remove('hidden');
                document.getElementById('stageRrEnableHomeAway').checked = stage.settings.enableHomeAway || false;
                document.getElementById('stageRrPointsWin').value = stage.settings.pointsWin;
                document.getElementById('stageRrPointsDraw').value = stage.settings.pointsDraw;
                document.getElementById('stageRrPointsLoss').value = stage.settings.pointsLoss;
                document.getElementById('stageRrTieBreaker').value = stage.settings.tieBreaker;
            } else {
                document.getElementById('stageRoundRobinSettings').classList.add('hidden');
            }

            openModal('stageModal');
        }

        function deleteStage(stageId) {
            if (!confirm('Are you sure you want to delete this stage and all its matches/brackets?')) {
                return;
            }
            const tournament = tournaments.find(t => t.id === currentTournamentId);
            if (tournament) {
                tournament.stages = tournament.stages.filter(s => s.id !== stageId);
                saveData();
                showAlert('Stage deleted successfully!', 'danger');
                renderMultiStages(tournament);
                renderCurrentStagesList();
            }
        }

        function openAdvanceParticipantsModal(stageId) {
            const tournament = tournaments.find(t => t.id === currentTournamentId);
            const stage = tournament.stages.find(s => s.id === stageId);
            if (!tournament || !stage) return;

            document.getElementById('advanceStageId').value = stageId;
            const availableParticipantsList = document.getElementById('availableParticipantsList');
            availableParticipantsList.innerHTML = '';

            tournament.participants.forEach(p => {
                const checkboxDiv = document.createElement('div');
                checkboxDiv.className = 'checkbox-group';
                checkboxDiv.innerHTML = `
                    <input type="checkbox" id="adv_p_${p.id}" value="${p.id}" ${stage.participants.includes(p.id) ? 'checked' : ''}>
                    <label for="adv_p_${p.id}">${p.name}</label>
                `;
                availableParticipantsList.appendChild(checkboxDiv);
            });

            openModal('advanceParticipantsModal');
        }

        function processAdvanceParticipants() {
            const tournament = tournaments.find(t => t.id === currentTournamentId);
            const stageId = document.getElementById('advanceStageId').value;
            const stage = tournament.stages.find(s => s.id === stageId);
            if (!tournament || !stage) return;

            const selectedParticipantIds = Array.from(document.querySelectorAll('#availableParticipantsList input[type="checkbox"]:checked'))
                                                .map(cb => cb.value);

            stage.participants = selectedParticipantIds;
            // Reset matches/rounds for the stage if participants change
            stage.matches = [];
            stage.rounds = [];

            saveData();
            showAlert('Participants updated for stage successfully!');
            renderMultiStages(tournament);
            renderCurrentStagesList();
            closeModal('advanceParticipantsModal');
        }


        // --- Import/Export ---
        function exportData() {
            const dataStr = JSON.stringify(tournaments, null, 2);
            const blob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `tournament_manager_data_${new Date().toISOString().slice(0,10)}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            showAlert('Data exported successfully!');
        }

        function importData(event) {
            const file = event.target.files[0];
            if (!file) {
                showAlert('No file selected.', 'error');
                return;
            }

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const importedData = JSON.parse(e.target.result);
                    if (!Array.isArray(importedData)) {
                        throw new Error('Invalid JSON format. Expected an array of tournaments.');
                    }

                    if (confirm('Do you want to REPLACE all existing data with the imported data? Click Cancel to MERGE (add new, update existing by ID).')) {
                        tournaments = importedData;
                        showAlert('All data replaced successfully!', 'success');
                    } else {
                        importedData.forEach(importedTournament => {
                            const existingIndex = tournaments.findIndex(t => t.id === importedTournament.id);
                            if (existingIndex !== -1) {
                                tournaments[existingIndex] = importedTournament; // Update existing
                            } else {
                                tournaments.push(importedTournament); // Add new
                            }
                        });
                        showAlert('Data merged successfully!', 'success');
                    }

                    saveData();
                    renderTournamentList();
                    showSection('dashboardSection');
                    document.getElementById('importFileInput').value = ''; // Clear file input
                } catch (error) {
                    showAlert(`Error importing data: ${error.message}`, 'error');
                }
            };
            reader.readAsText(file);
        }

        // --- QR Code ---
        function showQrCode() {
            const tournament = tournaments.find(t => t.id === currentTournamentId);
            if (!tournament) return;

            const qrCodeContainer = document.getElementById('qrCodeContainer');
            qrCodeContainer.innerHTML = ''; // Clear previous QR code

            // Use the inlined QRCode generator
            new QRCode({
                element: qrCodeContainer,
                value: tournament.id,
                size: 200,
                background: document.body.classList.contains('dark-mode') ? '#3a3a3a' : '#ffffff',
                foreground: document.body.classList.contains('dark-mode') ? '#e0e0e0' : '#000000'
            });

            document.getElementById('qrTournamentId').textContent = tournament.id;
            openModal('qrCodeModal');
        }


        // --- Event Listeners ---
        document.addEventListener('DOMContentLoaded', () => {
            // Load theme
            const savedTheme = localStorage.getItem(LS_THEME_KEY) || 'light';
            applyTheme(savedTheme);

            loadData();
            renderTournamentList(); // Initial render

            // Navigation
            document.getElementById('navDashboard').addEventListener('click', () => showSection('dashboardSection'));
            document.getElementById('navCreateTournament').addEventListener('click', () => {
                showSection('createTournamentSection');
                document.getElementById('createTournamentForm').reset();
                document.getElementById('roundRobinSettings').classList.add('hidden');
                document.getElementById('tournamentSetBasedScoring').checked = false;
                document.getElementById('tournamentPlayerStatsFields').value = '';
            });
            document.getElementById('navImportExport').addEventListener('click', () => showSection('importExportSection'));

            // Theme Toggle
            document.getElementById('themeToggle').addEventListener('click', toggleTheme);

            // Create Tournament Form
            document.getElementById('createTournamentForm').addEventListener('submit', createTournament);
            document.getElementById('tournamentType').addEventListener('change', (e) => {
                if (e.target.value === TOURNAMENT_TYPES.ROUND_ROBIN) {
                    document.getElementById('roundRobinSettings').classList.remove('hidden');
                } else {
                    document.getElementById('roundRobinSettings').classList.add('hidden');
                }
            });

            // Tournament Detail Actions
            document.getElementById('backToDashboardBtn').addEventListener('click', () => showSection('dashboardSection'));
            document.getElementById('editTournamentBtn').addEventListener('click', editTournamentDetails);
            document.getElementById('deleteTournamentBtn').addEventListener('click', deleteTournament);
            document.getElementById('changeTournamentStatus').addEventListener('change', changeTournamentStatus);
            document.getElementById('showQrCodeBtn').addEventListener('click', showQrCode);


            // Edit Tournament Modal Form
            document.getElementById('editTournamentForm').addEventListener('submit', saveEditedTournament);
            document.getElementById('editTournamentType').addEventListener('change', (e) => {
                if (e.target.value === TOURNAMENT_TYPES.ROUND_ROBIN) {
                    document.getElementById('editRoundRobinSettings').classList.remove('hidden');
                } else {
                    document.getElementById('editRoundRobinSettings').classList.add('hidden');
                }
            });


            // Participant Management
            document.getElementById('addParticipantBtn').addEventListener('click', openAddParticipantModal);
            document.getElementById('participantForm').addEventListener('submit', addOrUpdateParticipant);
            document.getElementById('bulkImportParticipantsBtn').addEventListener('click', openBulkImportModal);
            document.getElementById('processBulkImportBtn').addEventListener('click', processBulkImport);
            document.getElementById('copyParticipantsBtn').addEventListener('click', openCopyParticipantsModal);
            document.getElementById('processCopyParticipantsBtn').addEventListener('click', processCopyParticipants);


            // Bracket/Match Generation
            document.getElementById('generateBracketBtn').addEventListener('click', () => {
                const tournament = tournaments.find(t => t.id === currentTournamentId);
                if (tournament) generateEliminationBracket(tournament, TOURNAMENT_TYPES.SINGLE_ELIMINATION);
            });
            document.getElementById('generateDoubleEliminationBracketBtn').addEventListener('click', () => {
                const tournament = tournaments.find(t => t.id === currentTournamentId);
                if (tournament) generateEliminationBracket(tournament, TOURNAMENT_TYPES.DOUBLE_ELIMINATION);
            });
            document.getElementById('generateRoundRobinBtn').addEventListener('click', () => {
                const tournament = tournaments.find(t => t.id === currentTournamentId);
                if (tournament) generateRoundRobinMatches(tournament);
            });

            // Multi-Stage Management
            document.getElementById('manageStagesBtn').addEventListener('click', openManageStagesModal);
            document.getElementById('addStageBtn').addEventListener('click', openAddStageModal);
            document.getElementById('stageForm').addEventListener('submit', addOrUpdateStage);
            document.getElementById('stageType').addEventListener('change', (e) => {
                if (e.target.value === TOURNAMENT_TYPES.ROUND_ROBIN) {
                    document.getElementById('stageRoundRobinSettings').classList.remove('hidden');
                } else {
                    document.getElementById('stageRoundRobinSettings').classList.add('hidden');
                }
            });
            document.getElementById('processAdvanceParticipantsBtn').addEventListener('click', processAdvanceParticipants);


            // Match Details Modal
            document.getElementById('matchDetailsForm').addEventListener('submit', saveMatchDetails);

            // Search and Filter
            document.getElementById('tournamentSearch').addEventListener('input', renderTournamentList);
            document.getElementById('tournamentFilterStatus').addEventListener('change', renderTournamentList);
            document.getElementById('tournamentFilterSport').addEventListener('change', renderTournamentList);
            document.getElementById('tournamentFilterType').addEventListener('change', renderTournamentList);

            // Import/Export
            document.getElementById('exportDataBtn').addEventListener('click', exportData);
            document.getElementById('importFileInput').addEventListener('change', importData);
        });
    </script>
</body>
</html>

------------------------------------------------------------------------------------------------------------------------------------------------------

modify the above code based on the below information : 

Got it âœ… â€” you want me to research and break down **the logic that powers every kind of tournament format used worldwide**. That means not just listing them, but explaining *how they function, what rules govern them, and why theyâ€™re used*.

Hereâ€™s a structured breakdown:

---

# ðŸ† Tournament Formats & Their Underlying Logic

## 1. **Single Elimination (Knockout)**

* **Logic:** Lose once â†’ youâ€™re out. Win â†’ advance.
* **Progression:** Matches halve the field each round.
* **Rounds:** âŒˆlogâ‚‚(n)âŒ‰ rounds for *n* participants.
* **Fairness:** Quick and decisive but harshâ€”one bad game eliminates even strong players.
* **Use Cases:** Tennis Grand Slams, FIFA World Cup knockout stage, Olympic boxing.

---

## 2. **Double Elimination**

* **Logic:** Lose once â†’ drop to â€œLosersâ€™ Bracket.â€ Lose twice â†’ eliminated.
* **Progression:** Players can redeem an early loss. Final is often between the Winnerâ€™s Bracket finalist and Loserâ€™s Bracket finalist.
* **Fairness:** More forgiving than single elimination.
* **Use Cases:** eSports (Dota 2, CS\:GO majors), Little League Baseball.

---

## 3. **Round Robin**

* **Logic:** Every participant plays against every other participant.
* **Progression:** Points (win = 3, draw = 1, loss = 0) or win/loss records determine standings.
* **Rounds:** (n Ã— (n-1)) Ã· 2 matches total.
* **Fairness:** Most accurate measure of skill since everyone plays everyone.
* **Use Cases:** Chess tournaments, FIFA World Cup group stage, Cricket World Cup (2019, 2023).

---

## 4. **Swiss System**

* **Logic:** Participants play a fixed number of rounds (not everyone plays everyone). Each round pairs players with similar records (win vs win, loss vs loss).
* **Progression:** After several rounds, standings are determined by points + tiebreakers (Buchholz, Sonneborn-Berger, etc.).
* **Fairness:** Scales better than round robin, avoids early elimination, balances strength.
* **Use Cases:** Chess (FIDE tournaments), Magic: The Gathering, eSports qualifiers.

---

## 5. **Ladder / King of the Hill**

* **Logic:** Players challenge others above them on a ranked ladder. Winners climb, losers fall.
* **Progression:** Continuous, open-ended format.
* **Fairness:** Rewards consistency, but can be exploited if matchups arenâ€™t balanced.
* **Use Cases:** Online gaming ladders, local club leagues.

---

## 6. **League Systems**

* **Logic:** Similar to round robin, but played over a â€œseason.â€ Often home-and-away matches.
* **Progression:** Points table decides champions or playoff qualifiers.
* **Fairness:** Most comprehensive long-term test of ability.
* **Use Cases:** Football leagues (EPL, La Liga), NBA regular season.

---

## 7. **Group + Knockout Hybrid**

* **Logic:** First phase = groups (round robin or Swiss), then top teams advance to single-elimination knockout.
* **Progression:** Group stage filters â†’ knockout decides champion.
* **Fairness:** Mixes balance + drama.
* **Use Cases:** FIFA World Cup, ICC Cricket World Cup, UEFA Champions League.

---

## 8. **Multi-Stage Tournaments**

* **Logic:** Tournament progresses through phases of different formats.
* **Examples:**

  * Groups â†’ Super Six â†’ Knockout.
  * League phase â†’ Playoffs with top 4.
* **Use Cases:** Cricket World Cup (1999 â€œSuper Sixâ€), IPL (League + Playoffs).

---

## 9. **Consolation / Placement Brackets**

* **Logic:** Eliminated players continue in side brackets to determine ranks (5th place, etc.).
* **Use Cases:** Wrestling tournaments, Judo, badminton.

---

## 10. **GSL Format (eSports-specific hybrid)**

* **Logic:** 4 players in a group. Initial matches â†’ winners play each other (Winnerâ€™s Match), losers play (Elimination Match). Final match decides 2nd qualifier.
* **Use Cases:** StarCraft II, Valorant qualifiers.
* **Fairness:** Efficient mini-tournament within a group.

---

## 11. **Triple/Quadruple Elimination**

* **Logic:** Same as double elimination but you need 3â€“4 losses to be out.
* **Use Cases:** Rare, some amateur events where more playtime is desired.

---

## 12. **Aggregate / Two-Leg Tie**

* **Logic:** Each pair plays two matches (home & away). Total score (aggregate) decides winner.
* **Variants:** Away goals rule, penalties if tied.
* **Use Cases:** UEFA Champions League knockout ties.

---

## 13. **Best-of-n Series**

* **Logic:** Instead of one match, teams play multiple games (best of 3, 5, 7). First to majority wins.
* **Use Cases:** NBA playoffs, MLB World Series, eSports finals.
* **Fairness:** Reduces randomness; stronger team usually wins.

---

## 14. **Battle Royale Format**

* **Logic:** Everyone competes simultaneously in a large field, last standing wins.
* **Progression:** Can be score-based (PUBG points system) or survival-based.
* **Use Cases:** Fortnite World Cup, PUBG Global Championship.

---

## 15. **Race / Time-Based Tournaments**

* **Logic:** Winner determined by fastest completion time or most progress.
* **Use Cases:** Formula 1, Olympics athletics/swimming, speedrunning tournaments.

---

# ðŸŽ¯ Key Underlying Logics

* **Elimination logic:** Survival until the end (single, double, knockout).
* **Scoring logic:** Accumulate points across matches (round robin, leagues, Swiss).
* **Ranking logic:** Placement based on performance, can be continuous (ladders).
* **Hybrid logic:** Combinations to balance fairness + excitement.
* **Series logic:** Multiple matches to reduce randomness.
* **Time/survival logic:** Outlast or outperform in real-time competition.

---

ðŸ‘‰ Would you like me to **map all these into algorithm-style pseudocode** (like the logic behind scheduling, progression, and winner determination), so you can use it to implement a universal â€œTournament Managerâ€ app?

Awesome â€” hereâ€™s a **plug-and-play pseudocode toolkit** you can drop into a â€œUniversal Tournament Manager.â€ Itâ€™s organized as:

1. core data models,
2. common utilities (seeding, standings, tiebreakers, series),
3. format modules (each with clear entrypoints),
4. scheduling algorithms, and
5. edge-case notes.

Use this as your source of truth for implementing any format.

---

# 1) Core Data Models

```pseudocode
TYPE PlayerOrTeam:
  id: ID
  name: STRING
  rating: FLOAT?        // optional (Elo/seed)
  meta: MAP             // any extra fields

TYPE Match:
  id: ID
  round: INT
  stage: STRING         // e.g., "Groups", "Main", "Losers", "Playoffs"
  participants: LIST<PlayerOrTeam | BYE>  // size 2 unless FFA/battle-royale
  scheduled_at: DATETIME?
  result: Result?       // null until played
  best_of: INT = 1
  aggregate_key: STRING? // for 2-leg ties
  metadata: MAP          // map for court, venue, stream URL, etc.

TYPE Result:
  scores: MAP<PlayerOrTeam.id -> INT>     // set count or points
  winner_id: ID
  loser_id: ID?
  tiebreak_detail: STRING?

TYPE StandingRow:
  id: ID
  points: INT
  wins: INT
  draws: INT
  losses: INT
  sets_for: INT
  sets_against: INT
  goals_for: INT
  goals_against: INT
  buchholz: FLOAT
  sb: FLOAT            // Sonnebornâ€“Berger
  sos: FLOAT           // strength of schedule
  head_to_head: MAP<ID -> INT>
  fair_play: INT
  custom: MAP

TYPE Stage:
  name: STRING
  type: ENUM("SINGLE_ELIM","DOUBLE_ELIM","ROUND_ROBIN","SWISS","GSL",
             "LEAGUE","LADDER","TRIPLE_ELIM","BATTLE_ROYALE","TIME_TRIAL",
             "TWO_LEG","SERIES_ONLY","HYBRID")
  config: MAP
  matches: LIST<Match>
  standings: LIST<StandingRow>
```

---

# 2) Common Utilities

### 2.1 Seeding

```pseudocode
FUNCTION seed_participants(participants, method, bracket_size=None) -> LIST<ID>:
  SWITCH method:
    CASE "RATING_DESC": return sort_by(participants, -rating)
    CASE "RANDOM": return shuffle(participants)
    CASE "POT_DRAW": return pot_draw(participants, pots=method.pots)
    CASE "GEOGRAPHIC": return constraint_seed(participants, constraints=method.constraints)
  // If bracket_size is power of 2, insert BYEs to fill.
```

### 2.2 Standings Update

```pseudocode
FUNCTION update_standings(standings, match: Match):
  FOR each p in match.participants:
    row = standings.get_or_create(p.id)
  // sport-agnostic:
  winner = match.result.winner_id
  loser  = match.result.loser_id
  IF match.best_of > 1:
    row[winner].wins   += 1
    row[loser].losses  += 1
  // points logic (configurable):
  IF config.points_scheme == "3-1-0":
    IF draw(match): row[p1].points+=1; row[p2].points+=1
    ELSE row[winner].points+=3
  ELSE IF config.points_scheme == "2-1-0":
    IF draw: +1/+1 ELSE +2 winner
  // Also record goals/sets for tie-breaks if present
```

### 2.3 Tiebreakers (chainable)

```pseudocode
FUNCTION sort_with_tiebreakers(rows, rules_order) -> LIST<StandingRow>:
  RETURN sort(rows) BY comparator:
    FOR rule IN rules_order:
      cmp = compare_rule(a,b,rule)
      IF cmp != 0: RETURN cmp
    RETURN RANDOM_TOSS()   // last resort

FUNCTION compare_rule(a,b,rule):
  SWITCH rule:
    CASE "POINTS": return cmp_desc(a.points, b.points)
    CASE "WINS":   return cmp_desc(a.wins, b.wins)
    CASE "HEAD_TO_HEAD":
      return cmp_desc(a.head_to_head[b.id], b.head_to_head[a.id])
    CASE "GOAL_DIFF":
      return cmp_desc((a.goals_for - a.goals_against), (b.gf - b.ga))
    CASE "SETS_DIFF":
      return cmp_desc(a.sets_for - a.sets_against, b.sets_for - b.sets_against)
    CASE "GOALS_FOR": return cmp_desc(a.goals_for, b.goals_for)
    CASE "BUCHHOLZ":  return cmp_desc(a.buchholz, b.buchholz)
    CASE "SB":        return cmp_desc(a.sb, b.sb)
    CASE "SOS":       return cmp_desc(a.sos, b.sos)
    CASE "FAIR_PLAY": return cmp_asc(a.fair_play, b.fair_play) // fewer cards wins
    CASE "RANDOM":    return RANDOM_TOSS()
```

### 2.4 Best-of-N Series Wrapper (reduces randomness)

```pseudocode
FUNCTION schedule_series(pA, pB, best_of, stage_name, round) -> LIST<Match>:
  wins_needed = floor(best_of/2) + 1
  series_id = UUID()
  matches = []
  FOR i IN 1..best_of:
    matches.append(Match(id=UUID(), round=round, stage=stage_name,
                         participants=[pA,pB], metadata={"series_id":series_id}))
  RETURN matches

FUNCTION resolve_series(matches_in_series) -> Result:
  tally = map(id->0)
  FOR m IN matches_in_series WHERE m.result != null:
    tally[m.result.winner_id] += 1
    IF tally[any] >= wins_needed: DECLARE winner immediately (remaining become "if necessary")
  RETURN winner_id, loser_id
```

### 2.5 Two-Leg Aggregate

```pseudocode
FUNCTION schedule_two_leg_tie(pA, pB, stage_name, round):
  k = UUID() // aggregate key
  leg1 = Match(round, stage_name, [pA,pB], aggregate_key=k, home=pA)
  leg2 = Match(round, stage_name, [pB,pA], aggregate_key=k, home=pB)
  RETURN [leg1, leg2]

FUNCTION resolve_aggregate(legs, away_goals_rule=FALSE, extra_time=TRUE, penalties=TRUE):
  scoreA = goals_by(A in both legs)
  scoreB = goals_by(B in both legs)
  IF scoreA != scoreB: winner = max(scoreA, scoreB)
  ELSE IF away_goals_rule:
    awayA = goals_of_A_when_home_is_B
    awayB = goals_of_B_when_home_is_A
    IF awayA != awayB: winner = max(awayA, awayB)
  IF tie AND extra_time: play_extra_time_in_leg2
  IF still_tie AND penalties: shootout
  RETURN winner_id
```

---

# 3) Formats (Drop-in Modules)

## 3.1 Single Elimination (Knockout)

```pseudocode
FUNCTION single_elim(participants, best_of=1, reseed_each_round=FALSE):
  seeds = seed_participants(participants, config.seeding, bracket_size=next_pow2(n))
  bracket = place_seeds_in_fixed_bracket(seeds)  // 1 vs 16, 8 vs 9, etc.
  round = 1
  matches_by_round = []

  WHILE count_alive(bracket) > 1:
    pairs = pair_adjacent_alive_nodes(bracket)
    IF reseed_each_round:
      pairs = reseed_pairs_by_survivor_seeds(pairs)
    matches = []
    FOR (A,B) IN pairs:
      IF best_of==1: matches.append(Match(round,"Main",[A,B]))
      ELSE: matches += schedule_series(A,B,best_of,"Main",round)
    play_and_resolve(matches)
    advance_winners_in_bracket(matches, bracket)
    matches_by_round.append(matches)
    round += 1

  RETURN champion = last_survivor(bracket), matches_by_round
```

## 3.2 Double Elimination

```pseudocode
FUNCTION double_elim(participants, best_of_winners=1, best_of_losers=1, grand_final_reset=TRUE):
  W = create_winners_bracket(seed_participants(participants, config.seeding))
  L = create_losers_bracket()
  round = 1

  WHILE NOT (W.has_champion() AND L.has_champion()):
    // Winners round
    w_pairs = W.next_round_pairs()
    w_matches = schedule_pairs(w_pairs, best_of_winners, stage="Winners", round)
    play_and_advance(W, w_matches, winners_to=W, losers_to=L)
    // Losers round(s) may have two phases (minor/major)
    l_pairs = L.next_round_pairs()
    l_matches = schedule_pairs(l_pairs, best_of_losers, stage="Losers", round)
    play_and_advance(L, l_matches, winners_to=L, losers_out=True)
    round += 1

  // Grand Final: WB champ vs LB champ
  GF = schedule_series(W.champion, L.champion, best_of=config.gf_best_of, stage="Grand Final", round)
  play_and_resolve(GF)
  IF grand_final_reset AND winner_is_L_champion AND bracket_logic_requires_reset:
    // because WB champ has first loss now; optional bracket reset
    GF2 = schedule_series(W.champion, L.champion, best_of=config.gf_reset_best_of, stage="GF Reset", round+1)
    play_and_resolve(GF2)
  RETURN champion
```

## 3.3 Round Robin (Groups or Full League)

```pseudocode
FUNCTION round_robin(participants, double_round=False, points_scheme="3-1-0", tiebreakers=DEFAULT):
  schedule = circle_method(participants, home_away=double_round)
  standings = init_standings(participants)
  FOR match IN schedule:
    play(match)
    update_standings(standings, match)
  sorted = sort_with_tiebreakers(standings, tiebreakers)
  RETURN sorted, schedule
```

## 3.4 Swiss System

```pseudocode
FUNCTION swiss(participants, rounds, pairing="DUTCH", avoid_repeats=True, top_cut=None):
  standings = init_standings(participants)  // all start 0 points
  history = map(id -> set(opponent_ids))

  FOR r IN 1..rounds:
    buckets = bucket_by_score(standings)      // players with same score grouped
    pairs = []
    FOR bucket IN buckets_high_to_low:
      pool = order_bucket(bucket, method=pairing) // e.g., rank by rating or SOS
      pairs += greedy_pair(pool, history, avoid_repeats)
      IF odd(bucket): assign_bye_to_lowest_SOS_not_yet_had_bye()
    matches = schedule_pairs(pairs, best_of=1, stage="Swiss", round=r)
    play_and_apply_results(matches, standings, history)
    recompute_tiebreaks(standings, method=["BUCHHOLZ","SB","SOS"])

  final = sort_with_tiebreakers(standings, ["POINTS","BUCHHOLZ","SB","SOS","RANDOM"])
  IF top_cut != null:
    qualifiers = take(final, top_cut)
    RETURN qualifiers, final
  RETURN final
```

## 3.5 GSL (4-Player Dual Tournament)

```pseudocode
FUNCTION gsl_group(players4, best_of=3):
  // A vs B, C vs D
  M1 = schedule_series(players4[1], players4[2], best_of, "GSL", 1)
  M2 = schedule_series(players4[3], players4[4], best_of, "GSL", 1)
  play_and_resolve(M1); play_and_resolve(M2)

  winners = [winner(M1), winner(M2)]
  losers  = [loser(M1),  loser(M2)]

  // Winners' Match (qualifier #1)
  WM = schedule_series(winners[1], winners[2], best_of, "GSL", 2)
  play_and_resolve(WM); q1 = winner(WM)

  // Elimination Match (loser out)
  EM = schedule_series(losers[1], losers[2], best_of, "GSL", 2)
  play_and_resolve(EM); survive = winner(EM)

  // Decider for #2
  DM = schedule_series(survive, loser(WM), best_of, "GSL", 3)
  play_and_resolve(DM); q2 = winner(DM)

  RETURN [q1, q2], [M1,M2,WM,EM,DM]
```

## 3.6 League Season (+ optional Playoffs)

```pseudocode
FUNCTION league_season(teams, double_round=True, playoffs_top_k=None, playoff_config):
  table, fixtures = round_robin(teams, double_round, points_scheme="3-1-0")
  IF playoffs_top_k:
    seeds = take(table, playoffs_top_k)
    champion = playoffs(seeds, playoff_config)
    RETURN champion, table, fixtures
  RETURN table, fixtures
```

## 3.7 Playoffs (Fixed vs Reseed, Byes)

```pseudocode
FUNCTION playoffs(seeds_ordered, config):
  n = len(seeds_ordered)
  IF config.allow_byes AND NOT is_pow2(n):
    extend_with_BYEs_to_pow2(seeds_ordered)
  round = 1
  while remaining > 1:
    pairs = IF config.reseed_each_round
              THEN pair_high_vs_low(remaining_seeds)
              ELSE fixed_bracket_pairs(remaining_seeds)
    matches = []
    FOR (A,B) IN pairs:
      matches += schedule_series(A,B, best_of=config.best_of_per_round[round], stage="Playoffs", round)
    play_and_resolve(matches)
    remaining_seeds = collect_series_winners(matches)
    round += 1
  RETURN champion
```

## 3.8 Ladder / King-of-the-Hill

```pseudocode
FUNCTION ladder_init(players):
  ranks = sort_by(players, -rating)  // or random
  RETURN ranks

FUNCTION ladder_challenge(ranks, challenger_id, target_id):
  REQUIRE position(challenger) > position(target)   // can only challenge up
  match = schedule(challenger, target, stage="Ladder")
  play(match)
  IF match.result.winner_id == challenger_id:
    swap_positions(ranks, challenger, target)
  else:
    maybe_demote(challenger) // optional rule
  RETURN ranks
```

## 3.9 Triple / Quadruple Elimination

```pseudocode
FUNCTION multi_elim(participants, losses_to_eliminate=3):
  // Maintain buckets by loss-count: L0, L1, L2, ... Lk
  buckets = {0: participants}
  round = 1
  WHILE count_alive(buckets) > 1:
    FOR i IN 0..(losses_to_eliminate-1):
      pairs = pair_in_bucket(buckets[i])
      matches = schedule_pairs(pairs, stage="L"+i, round=round)
      play(matches)
      MOVE losers -> bucket[i+1]; winners stay in bucket[i]
    eliminate_all_in_bucket(losses_to_eliminate)
    round += 1
  RETURN last_remaining()
```

## 3.10 Battle Royale / FFA (points-based)

```pseudocode
FUNCTION battle_royale_round(field, scoring):
  // scoring example: placement_points + kill_points
  match = schedule_ffa(field)
  play(match)
  FOR p IN field:
    pts = scoring.placement[p] + scoring.kills[p]
    standings[p].points += pts
  RETURN standings

FUNCTION battle_royale_tournament(field, rounds, scoring):
  standings = init_standings(field)
  FOR r IN 1..rounds:
    standings = battle_royale_round(field, scoring)
  RETURN sort_with_tiebreakers(standings, ["POINTS","KILLS","HIGHEST_PLACEMENT","RANDOM"])
```

## 3.11 Time-Trial / Race

```pseudocode
FUNCTION time_trial(entries, heats=None, take_top=None, final_size=None):
  IF heats:
    results = []
    FOR heat IN split(entries, heats):
      times = run_heat_timers(heat)
      results += times
    ranked = sort_by(results, time_asc)
  ELSE:
    ranked = sort_by(run_heat_timers(entries), time_asc)

  IF take_top:
    finalists = take(ranked, final_size)
    final_times = run_heat_timers(finalists)
    RETURN sort_by(final_times, time_asc)
  RETURN ranked
```

## 3.12 Two-Leg Tie (module wrapper)

```pseudocode
FUNCTION two_leg_knockout(pairs, away_goals_rule=FALSE):
  all_matches = []
  FOR (A,B) IN pairs:
    legs = schedule_two_leg_tie(A,B,"Knockout",round=1)
    all_matches += legs
  play_and_fill(all_matches)
  winners = []
  FOR each_pair_legs IN group_by_aggregate_key(all_matches):
    winners.append(resolve_aggregate(each_pair_legs, away_goals_rule))
  RETURN winners
```

---

# 4) Scheduling Algorithms

### 4.1 Round Robin â€œCircle Methodâ€

```pseudocode
FUNCTION circle_method(participants, home_away=False):
  list = participants.copy()
  IF len(list) is odd: list.append(BYE)
  n = len(list)
  rounds = n - 1
  schedule = []

  FOR r IN 1..rounds:
    // Pair first half vs reversed second half
    first_half  = list[0: n/2]
    second_half = reverse(list[n/2: n])
    pairs = zip(first_half, second_half)     // (list[0] vs list[n-1]), ...
    // Alternate home/away by round index
    schedule += make_matches_from_pairs(pairs, round=r)

    // Rotate: keep first fixed, move last of list to position 1
    list = [list[0]] + [list[-1]] + list[1:-1]

  IF home_away:
    // Mirror fixture list with swapped home/away
    schedule += mirror_and_swap(schedule)
  RETURN schedule
```

### 4.2 Swiss Pairing (Greedy with Repeat-Avoidance)

```pseudocode
FUNCTION greedy_pair(bucket, history, avoid_repeats):
  pairs = []
  pool = bucket.copy()
  WHILE len(pool) >= 2:
    A = pop_front(pool)
    best = find_first_B_in_pool(pool) WHERE (NOT avoid_repeats OR B.id NOT IN history[A.id])
    IF best == null:
      best = pool[0]    // unavoidable repeat
    pairs.append((A,best))
    remove(pool, best)
  IF len(pool) == 1: assign_bye(pool[0])
  RETURN pairs
```

### 4.3 Fixed Bracket Seeding (common maps)

```pseudocode
FUNCTION place_seeds_in_fixed_bracket(seeds):
  // power-of-2 bracket mapping for fairness: 1-16, 8-9, 5-12, 4-13, 6-11, 3-14, 7-10, 2-15
  RETURN map_seeds_to_positions(seeds, template="standard")
```

---

# 5) Hybrid Pipelines (common real-world flows)

### 5.1 FIFA/UEFA-style Group â†’ Knockout

```pseudocode
FUNCTION groups_then_knockout(teams, group_count, teams_per_group, advance_k_each, tiebreakers, knockout_config):
  groups = split_by_seed(teams, group_count, method="serpentine")
  group_tables = []
  qualifiers = []

  FOR g IN groups:
    table, fixtures = round_robin(g, double_round=False, points_scheme="3-1-0", tiebreakers=tiebreakers)
    group_tables.append((g.name, table))
    qualifiers += take(table, advance_k_each)

  // Optional: draw bracket with group-winner vs runner-up constraints
  knockout_pairs = draw_knockout_pairs(qualifiers, avoid_same_group=True, avoid_same_country=config.avoid_country)
  champion = playoffs(order_by_seed(knockout_pairs), knockout_config)
  RETURN champion, group_tables
```

### 5.2 IPL-style Playoffs (Top-2 advantage)

```pseudocode
FUNCTION ipl_playoffs(top4):
  // Q1: 1 vs 2 (winner -> Final, loser -> Qualifier 2)
  // Eliminator: 3 vs 4 (loser out, winner -> Qualifier 2)
  Q1 = schedule_series(top4[1], top4[2], best_of=1, "Playoffs", 1)
  EL = schedule_series(top4[3], top4[4], best_of=1, "Playoffs", 1)
  play_and_resolve(Q1); play_and_resolve(EL)
  Q2 = schedule_series(loser(Q1), winner(EL), best_of=1, "Playoffs", 2)
  play_and_resolve(Q2)
  FINAL = schedule_series(winner(Q1), winner(Q2), best_of=1, "Playoffs", 3)
  play_and_resolve(FINAL)
  RETURN winner(FINAL)
```

---

# 6) Edge Cases & Policy Hooks

```pseudocode
// BYEs:
IF odd_participants: assign BYE to the lowest seed not yet had BYE (or random)

// Walkovers/forfeits:
IF team_no_show:
  award win with nominal score (e.g., 3-0 goals or 2-0 sets)

// Draw handling (sports-dependent):
IF draw_not_allowed_in_knockout: use extra_time_then_penalties()

// Reseeding:
IF reseed_each_round: always pair highest remaining seed vs lowest remaining seed

// Venue/Home/Away:
alternate_home_away_for_fairness(); ensure no consecutive extreme travel if constraints exist

// Anti-repeat constraints:
prefer avoiding rematches in groups until necessary; in Swiss, track history

// Tiebreaker transparency:
store tiebreak chain & intermediate values per team for auditability

// Scheduling fairness:
avoid back-to-back fixtures; maintain minimum rest windows

// Disqualifications:
remove participant and nullify or keep results per tournament policy

// Grand Final reset (double elim):
apply only if WB champ receives first loss in GF and rulebook says reset
```

---

# 7) Complexity Notes (so you can scale)

* **Round Robin:** O(nÂ²) matches; schedule build O(nÂ²).
* **Swiss:** O(RÂ·nÂ·log n) for sorting buckets per round; pairing \~O(n).
* **Single/Double Elim:** matches O(n) / \~O(2nâˆ’1) respectively.
* **Ladder:** per challenge O(1) update; global maintenance O(n log n) if re-ranking.
* **Battle Royale:** O(RÂ·n) with constant-time scoring per player.

---

# 8) Plug-in Points (sports/game specific)

Provide sport adapters for:

```pseudocode
INTERFACE SportAdapter:
  FUNCTION parse_score(raw) -> Result
  FUNCTION points_for(result) -> (winner_pts, loser_pts, draw_pts)
  FUNCTION series_scoring() -> INT   // default 1
  FUNCTION knockout_draw_resolution() -> ENUM("ET","PEN","REPLAY")
  FUNCTION normalize_stats(match) -> dict(goals_for, sets_for, etc.)
```

---

# 9) Minimal Orchestrator

```pseudocode
FUNCTION run_tournament(stages: LIST<Stage>, participants):
  context = {participants, global_standings, history}
  FOR stage IN stages:
    SWITCH stage.type:
      CASE "ROUND_ROBIN": table, fixtures = round_robin(participants, stage.config.double_round, stage.config.points, stage.config.tiebreakers)
                          stage.standings = table; stage.matches = fixtures
      CASE "SWISS": final = swiss(participants, stage.config.rounds, stage.config.pairing, stage.config.avoid_repeats, stage.config.top_cut)
      CASE "SINGLE_ELIM": champion = single_elim(participants, stage.config.best_of, stage.config.reseed)
      CASE "DOUBLE_ELIM": champion = double_elim(participants, ...)
      CASE "GSL": qualifiers, ms = gsl_group(pick4(participants), best_of=stage.config.best_of)
      CASE "LEAGUE": table, fixtures = league_season(participants, ...)
      CASE "LADDER": // event-driven
      CASE "TWO_LEG": winners = two_leg_knockout(pairs_from_draw(participants), stage.config.away_goals)
      CASE "HYBRID": // call nested pipeline
    update_context(context, stage)
  RETURN context
```

---

If you want, I can now convert any of these modules to **real code** (JS/TS, Python, or directly into your Simple Tournament Manager App) and wire up sample JSON configs for each format.


Perfect ðŸ‘ â€” letâ€™s design a **modular algorithm** for handling **group stages** (like FIFA/Cricket/UEFA style) plus **player stats showcase & management** (tracking goals, assists, K/D, etc., depending on the sport/game).

Iâ€™ll keep it **sport-agnostic** but with hooks for sport-specific stats.

---

# ðŸ† Algorithm: Group Stage

### Data Structures

```pseudocode
TYPE Group:
  id: STRING
  participants: LIST<Team>
  matches: LIST<Match>
  standings: LIST<StandingRow>

TYPE StandingRow:
  team_id: ID
  played: INT
  wins: INT
  draws: INT
  losses: INT
  goals_for: INT
  goals_against: INT
  goal_diff: INT
  points: INT
  tiebreak_values: MAP   // e.g., head-to-head, fair play

TYPE Match:
  id: ID
  round: INT
  home: Team
  away: Team
  result: Result?         // filled after play
```

---

### Algorithm

```pseudocode
FUNCTION group_stage(participants, groups_count, advance_k, points_scheme, tiebreakers):
  // 1. Split into groups
  groups = split_participants(participants, groups_count, method="serpentine")

  // 2. Schedule matches (round robin inside each group)
  FOR group IN groups:
    group.matches = round_robin(group.participants)

  // 3. Play matches + update standings
  FOR group IN groups:
    group.standings = init_standings(group.participants)
    FOR match IN group.matches:
      play(match)                               // input or simulated result
      update_standings(group.standings, match, points_scheme)

    // 4. Apply tie-breakers
    group.standings = sort_with_tiebreakers(group.standings, tiebreakers)

  // 5. Decide who advances
  qualifiers = []
  FOR group IN groups:
    qualifiers += take(group.standings, advance_k)

  RETURN groups, qualifiers
```

---

# ðŸ“Š Algorithm: Player Stats Showcase & Management

### Data Structures

```pseudocode
TYPE Player:
  id: ID
  name: STRING
  team_id: ID
  stats: PlayerStats

TYPE PlayerStats:
  matches_played: INT
  goals: INT
  assists: INT
  saves: INT
  cards_yellow: INT
  cards_red: INT
  minutes_played: INT
  kills: INT      // for eSports
  deaths: INT
  damage: FLOAT
  custom: MAP     // extension for game-specific metrics
```

---

### Core Functions

```pseudocode
FUNCTION update_player_stats(player: Player, match_event: Event):
  SWITCH match_event.type:
    CASE "GOAL": player.stats.goals += 1
    CASE "ASSIST": player.stats.assists += 1
    CASE "SAVE": player.stats.saves += 1
    CASE "YELLOW_CARD": player.stats.cards_yellow += 1
    CASE "RED_CARD": player.stats.cards_red += 1
    CASE "MINUTE_PLAYED": player.stats.minutes_played += 1
    CASE "KILL": player.stats.kills += 1
    CASE "DEATH": player.stats.deaths += 1
    CASE "DAMAGE": player.stats.damage += match_event.value
    CASE "CUSTOM": player.stats.custom[match_event.key] += match_event.value

FUNCTION finalize_match_stats(match: Match, events: LIST<Event>, players: LIST<Player>):
  FOR event IN events:
    update_player_stats(event.player, event)

  FOR player IN players_of_match(match):
    player.stats.matches_played += 1
```

---

### Showcase / Leaderboards

```pseudocode
FUNCTION generate_leaderboard(players, metric, top_n):
  sorted = sort_by(players, -players.stats[metric])
  RETURN take(sorted, top_n)

FUNCTION show_player_profile(player: Player):
  DISPLAY player.name
  DISPLAY "Goals:", player.stats.goals
  DISPLAY "Assists:", player.stats.assists
  DISPLAY "Kills:", player.stats.kills
  DISPLAY "Damage:", player.stats.damage
  DISPLAY "Cards:", player.stats.cards_yellow, "/", player.stats.cards_red
  DISPLAY "Minutes:", player.stats.minutes_played
```

---

# âš™ï¸ Workflow Example (FIFA-style Group Stage + Stats)

1. **Setup**: 32 teams â†’ 8 groups of 4.
2. **Schedule**: Each group does round robin (6 matches per group).
3. **Play matches**: Record results + match events (goals, assists, cards, etc.).
4. **Update standings**: Points (3/1/0), GD, head-to-head.
5. **Update player stats**: Every event logged updates the player record.
6. **Showcase**: Generate:

   * Team standings per group
   * Player leaderboards (Top Scorers, Top Assists, Most Saves, etc.)
7. **Advance**: Top 2 per group â†’ knockout stage.

---

ðŸ‘‰ Do you want me to **convert this into actual code** (Python/JS) with ready-to-use functions, so you can directly plug into your **Tournament Manager App** and manage both team standings & player stats?
