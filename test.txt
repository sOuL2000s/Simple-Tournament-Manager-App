<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ultimate Tournament Manager (Score7 Inspired)</title>
    <style>
        /* --- Global Styles & Variables --- */
        :root {
            --bg-color: #f4f7f6;
            --text-color: #333;
            --primary-color: #4CAF50;
            --primary-dark: #388E3C;
            --secondary-color: #2196F3;
            --accent-color: #FFC107;
            --border-color: #ddd;
            --card-bg: #fff;
            --input-bg: #f9f9f9;
            --shadow: 0 2px 5px rgba(0,0,0,0.1);
            --radius: 8px;
            --font-family: 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
        }

        body.dark-mode {
            --bg-color: #2c2c2c;
            --text-color: #e0e0e0;
            --primary-color: #66BB6A;
            --primary-dark: #43A047;
            --secondary-color: #64B5F6;
            --accent-color: #FFEB3B;
            --border-color: #555;
            --card-bg: #3a3a3a;
            --input-bg: #444;
            --shadow: 0 2px 5px rgba(0,0,0,0.3);
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: var(--font-family);
            background-color: var(--bg-color);
            color: var(--text-color);
            line-height: 1.6;
            transition: background-color 0.3s, color 0.3s;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        /* --- Layout --- */
        .container {
            max-width: 1200px;
            margin: 20px auto;
            padding: 0 20px;
            flex-grow: 1;
        }

        header {
            background-color: var(--primary-color);
            color: white;
            padding: 15px 20px;
            text-align: center;
            box-shadow: var(--shadow);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        header h1 {
            margin: 0;
            font-size: 1.8em;
        }

        .theme-toggle {
            background: none;
            border: none;
            color: white;
            font-size: 1.5em;
            cursor: pointer;
            padding: 5px;
            border-radius: var(--radius);
            transition: background-color 0.2s;
        }
        .theme-toggle:hover {
            background-color: rgba(255,255,255,0.2);
        }

        nav {
            background-color: var(--card-bg);
            box-shadow: var(--shadow);
            border-radius: var(--radius);
            margin-top: 20px;
            display: flex;
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
        }

        nav button {
            flex: 1;
            min-width: 120px;
            background: none;
            border: none;
            padding: 15px 20px;
            font-size: 1.1em;
            cursor: pointer;
            color: var(--text-color);
            transition: background-color 0.3s, color 0.3s;
            border-bottom: 3px solid transparent;
        }

        nav button:hover {
            background-color: var(--bg-color);
        }

        nav button.active {
            color: var(--primary-color);
            border-bottom-color: var(--primary-color);
            font-weight: bold;
        }

        .content-section {
            background-color: var(--card-bg);
            padding: 30px;
            border-radius: var(--radius);
            box-shadow: var(--shadow);
            margin-top: 20px;
        }

        /* --- Typography --- */
        h2, h3, h4 {
            color: var(--primary-color);
            margin-bottom: 15px;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 10px;
        }

        h2 { font-size: 1.8em; }
        h3 { font-size: 1.4em; }
        h4 { font-size: 1.2em; }

        /* --- Forms --- */
        .form-group {
            margin-bottom: 15px;
        }

        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: var(--text-color);
        }

        .form-group input[type="text"],
        .form-group input[type="number"],
        .form-group input[type="date"],
        .form-group input[type="time"],
        .form-group select,
        .form-group textarea {
            width: 100%;
            padding: 10px 12px;
            border: 1px solid var(--border-color);
            border-radius: var(--radius);
            background-color: var(--input-bg);
            color: var(--text-color);
            font-size: 1em;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .form-group input:focus,
        .form-group select:focus,
        .form-group textarea:focus {
            border-color: var(--primary-color);
            box-shadow: 0 0 0 2px rgba(var(--primary-color-rgb, 76, 175, 80), 0.2);
            outline: none;
        }

        .form-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
        }
        .checkbox-group input[type="checkbox"] {
            width: auto;
            margin-right: 5px;
        }

        /* --- Buttons --- */
        .btn {
            display: inline-block;
            padding: 10px 20px;
            border-radius: var(--radius);
            cursor: pointer;
            font-size: 1em;
            font-weight: bold;
            text-align: center;
            text-decoration: none;
            transition: background-color 0.2s, transform 0.1s;
            border: none;
        }

        .btn-primary {
            background-color: var(--primary-color);
            color: white;
        }
        .btn-primary:hover {
            background-color: var(--primary-dark);
            transform: translateY(-1px);
        }

        .btn-secondary {
            background-color: var(--secondary-color);
            color: white;
        }
        .btn-secondary:hover {
            background-color: #1976D2; /* Darker secondary */
            transform: translateY(-1px);
        }

        .btn-danger {
            background-color: #f44336;
            color: white;
        }
        .btn-danger:hover {
            background-color: #d32f2f;
            transform: translateY(-1px);
        }

        .btn-outline {
            background-color: transparent;
            color: var(--primary-color);
            border: 2px solid var(--primary-color);
        }
        .btn-outline:hover {
            background-color: var(--primary-color);
            color: white;
            transform: translateY(-1px);
        }

        .btn-group {
            display: flex;
            gap: 10px;
            margin-top: 20px;
            flex-wrap: wrap;
        }

        /* --- Lists & Cards --- */
        .tournament-list {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
        }

        .tournament-card {
            background-color: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: var(--radius);
            padding: 20px;
            box-shadow: var(--shadow);
            transition: transform 0.2s, box-shadow 0.2s;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .tournament-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 4px 10px rgba(0,0,0,0.15);
        }

        .tournament-card h3 {
            margin-top: 0;
            margin-bottom: 10px;
            border-bottom: none;
            padding-bottom: 0;
            color: var(--primary-color);
        }

        .tournament-card p {
            margin-bottom: 8px;
            font-size: 0.95em;
        }

        .tournament-card .status {
            display: inline-block;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 0.8em;
            font-weight: bold;
            margin-top: 10px;
        }

        .status.upcoming { background-color: var(--secondary-color); color: white; }
        .status.active { background-color: var(--primary-color); color: white; }
        .status.completed { background-color: #9E9E9E; color: white; }

        .no-data {
            text-align: center;
            padding: 40px;
            font-style: italic;
            color: var(--text-color);
            opacity: 0.7;
        }

        /* --- Tournament Detail Specifics --- */
        .tournament-detail-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 15px;
        }

        .tournament-detail-header h2 {
            margin: 0;
            border-bottom: none;
            padding-bottom: 0;
        }

        .tournament-info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .tournament-info-item {
            background-color: var(--input-bg);
            padding: 15px;
            border-radius: var(--radius);
            border: 1px solid var(--border-color);
        }
        .tournament-info-item strong {
            display: block;
            margin-bottom: 5px;
            color: var(--primary-color);
        }

        .participants-list, .matches-list {
            list-style: none;
            padding: 0;
        }

        .participant-item, .match-item {
            background-color: var(--input-bg);
            border: 1px solid var(--border-color);
            border-radius: var(--radius);
            padding: 15px;
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 10px;
        }

        .participant-item .actions, .match-item .actions {
            display: flex;
            gap: 8px;
        }

        .participant-item .actions .btn, .match-item .actions .btn {
            padding: 8px 12px;
            font-size: 0.9em;
        }

        /* --- Bracket Display (Single/Double Elimination) --- */
        .bracket-visualizer {
            display: flex;
            justify-content: center;
            align-items: flex-start; /* Align rounds at the top */
            overflow-x: auto;
            padding: 20px 0;
            gap: 40px; /* Space between rounds */
        }

        .bracket-round-simple {
            display: flex;
            flex-direction: column;
            gap: 20px; /* Gap between matches in a round */
            position: relative;
            min-width: 250px;
        }

        .bracket-round-simple h4 {
            text-align: center;
            margin-bottom: 15px;
            color: var(--primary-color);
            border-bottom: none;
            padding-bottom: 0;
        }

        .bracket-match-simple {
            background-color: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: var(--radius);
            padding: 10px;
            box-shadow: var(--shadow);
            position: relative;
        }

        .bracket-match-simple .player-line {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 5px 0;
            border-bottom: 1px dashed var(--border-color);
        }
        .bracket-match-simple .player-line:last-of-type {
            border-bottom: none;
        }
        .bracket-match-simple .player-line.winner-player {
            background-color: var(--primary-color);
            color: white;
            border-radius: 5px;
            padding: 5px 10px;
            margin: 2px -5px;
        }

        .bracket-match-simple .score-input {
            width: 60px;
            padding: 3px;
            margin-left: 5px;
            border: 1px solid var(--border-color);
            border-radius: 3px;
            background-color: var(--bg-color);
            color: var(--text-color);
            text-align: center;
        }
        .bracket-match-simple .sets-input {
            width: 100px;
            padding: 3px;
            margin-left: 5px;
            border: 1px solid var(--border-color);
            border-radius: 3px;
            background-color: var(--bg-color);
            color: var(--text-color);
            text-align: center;
        }

        .bracket-match-simple .match-actions {
            margin-top: 10px;
            text-align: right;
            display: flex;
            gap: 5px;
            justify-content: flex-end;
            flex-wrap: wrap;
        }
        .bracket-match-simple .match-actions .btn {
            padding: 5px 10px;
            font-size: 0.8em;
        }

        .match-details-popup {
            position: absolute;
            background-color: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: var(--radius);
            padding: 15px;
            box-shadow: var(--shadow);
            z-index: 10;
            min-width: 250px;
            max-width: 350px;
            top: 100%; /* Position below the match */
            left: 0;
            margin-top: 5px;
            display: none; /* Hidden by default */
        }
        .match-details-popup.active {
            display: block;
        }
        .match-details-popup p {
            margin-bottom: 5px;
            font-size: 0.9em;
        }
        .match-details-popup strong {
            color: var(--primary-color);
        }
        .match-details-popup .player-stats-display {
            margin-top: 10px;
            border-top: 1px dashed var(--border-color);
            padding-top: 10px;
        }
        .match-details-popup .player-stats-display div {
            margin-bottom: 3px;
        }
        .match-details-popup .player-stats-display strong {
            color: var(--secondary-color);
        }

        /* Double Elimination Specifics */
        .double-elimination-wrapper {
            display: flex;
            flex-direction: column;
            gap: 30px;
            width: 100%;
            align-items: center;
        }
        .double-elimination-wrapper > div {
            width: 100%;
            max-width: 100%;
            overflow-x: auto;
            padding-bottom: 10px; /* For scrollbar */
        }
        .double-elimination-wrapper h3 {
            text-align: center;
            width: 100%;
            margin-top: 20px;
            color: var(--secondary-color);
        }
        .double-elimination-wrapper .bracket-visualizer {
            justify-content: flex-start; /* Align rounds to the left */
        }

        /* Multi-Stage Specifics */
        .multi-stage-container .stage-card {
            background-color: var(--input-bg);
            border: 1px solid var(--border-color);
            border-radius: var(--radius);
            padding: 15px;
            margin-bottom: 15px;
            box-shadow: var(--shadow);
        }
        .multi-stage-container .stage-card h4 {
            margin-top: 0;
            margin-bottom: 10px;
            border-bottom: none;
            padding-bottom: 0;
            color: var(--secondary-color);
        }
        .multi-stage-container .stage-card .stage-content {
            margin-top: 15px;
            border-top: 1px dashed var(--border-color);
            padding-top: 15px;
        }

        /* Group Stage Specifics */
        .group-card {
            background-color: var(--input-bg);
            border: 1px solid var(--border-color);
            border-radius: var(--radius);
            padding: 15px;
            margin-bottom: 20px;
            box-shadow: var(--shadow);
        }
        .group-card h4 {
            margin-top: 0;
            margin-bottom: 10px;
            border-bottom: none;
            padding-bottom: 0;
            color: var(--secondary-color);
        }
        .group-card .group-content {
            margin-top: 15px;
            border-top: 1px dashed var(--border-color);
            padding-top: 15px;
        }

        /* --- Round Robin Table --- */
        .round-robin-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }
        .round-robin-table th, .round-robin-table td {
            border: 1px solid var(--border-color);
            padding: 10px;
            text-align: left;
        }
        .round-robin-table th {
            background-color: var(--primary-color);
            color: white;
            font-weight: bold;
        }
        .round-robin-table tr:nth-child(even) {
            background-color: var(--input-bg);
        }
        .round-robin-table tr:hover {
            background-color: var(--bg-color);
        }

        .round-robin-table .score-input, .round-robin-table .sets-input {
            width: 60px;
            padding: 5px;
            border: 1px solid var(--border-color);
            border-radius: 5px;
            background-color: var(--bg-color);
            color: var(--text-color);
            text-align: center;
        }
        .round-robin-table .sets-input {
            width: 100px;
        }

        /* --- Standings Table --- */
        .standings-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }
        .standings-table th, .standings-table td {
            border: 1px solid var(--border-color);
            padding: 10px;
            text-align: left;
        }
        .standings-table th {
            background-color: var(--secondary-color);
            color: white;
            font-weight: bold;
        }
        .standings-table tr:nth-child(even) {
            background-color: var(--input-bg);
        }
        .standings-table tr:hover {
            background-color: var(--bg-color);
        }
        .standings-table td.rank {
            font-weight: bold;
            text-align: center;
        }

        /* --- Leaderboard Table --- */
        .leaderboard-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }
        .leaderboard-table th, .leaderboard-table td {
            border: 1px solid var(--border-color);
            padding: 10px;
            text-align: left;
        }
        .leaderboard-table th {
            background-color: var(--accent-color);
            color: var(--text-color);
            font-weight: bold;
        }
        .leaderboard-table tr:nth-child(even) {
            background-color: var(--input-bg);
        }
        .leaderboard-table tr:hover {
            background-color: var(--bg-color);
        }
        .leaderboard-table td.rank {
            font-weight: bold;
            text-align: center;
        }


        /* --- Modals --- */
        .modal {
            display: none; /* Hidden by default */
            position: fixed; /* Stay in place */
            z-index: 1000; /* Sit on top */
            left: 0;
            top: 0;
            width: 100%; /* Full width */
            height: 100%; /* Full height */
            overflow: auto; /* Enable scroll if needed */
            background-color: rgba(0,0,0,0.6); /* Black w/ opacity */
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
            padding-top: 60px;
        }

        .modal-content {
            background-color: var(--card-bg);
            margin: 5% auto;
            padding: 30px;
            border-radius: var(--radius);
            box-shadow: var(--shadow);
            width: 90%;
            max-width: 700px;
            position: relative;
            animation: fadeIn 0.3s ease-out;
        }

        .modal-content h3 {
            margin-top: 0;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 10px;
            margin-bottom: 20px;
            color: var(--primary-color);
        }

        .close-button {
            color: var(--text-color);
            position: absolute;
            top: 15px;
            right: 25px;
            font-size: 30px;
            font-weight: bold;
            cursor: pointer;
            transition: color 0.2s;
        }

        .close-button:hover,
        .close-button:focus {
            color: var(--primary-color);
            text-decoration: none;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* --- Utility & Responsive --- */
        .hidden {
            display: none !important;
        }

        .text-center {
            text-align: center;
        }

        .flex-between {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 10px;
        }

        .flex-gap-10 {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .alert {
            padding: 15px;
            margin-bottom: 20px;
            border-radius: var(--radius);
            font-weight: bold;
        }
        .alert-success {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        .alert-error {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .search-filter-bar {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        .search-filter-bar input, .search-filter-bar select {
            flex: 1;
            min-width: 150px;
        }

        footer {
            text-align: center;
            padding: 20px;
            margin-top: 40px;
            background-color: var(--card-bg);
            color: var(--text-color);
            border-top: 1px solid var(--border-color);
            font-size: 0.9em;
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .container {
                margin: 10px auto;
                padding: 0 10px;
            }
            header h1 {
                font-size: 1.5em;
            }
            nav button {
                padding: 12px 15px;
                font-size: 1em;
            }
            .content-section {
                padding: 20px;
            }
            .form-grid {
                grid-template-columns: 1fr;
            }
            .tournament-list {
                grid-template-columns: 1fr;
            }
            .tournament-detail-header {
                flex-direction: column;
                align-items: flex-start;
            }
            .tournament-detail-header .btn-group {
                width: 100%;
                justify-content: flex-start;
            }
            .bracket-visualizer {
                justify-content: flex-start;
            }
            .bracket-round-simple {
                margin-right: 20px;
            }
        }
    </style>
</head>
<body>
    <header>
        <h1>Ultimate Tournament Manager</h1>
        <button id="themeToggle" class="theme-toggle">💡</button>
    </header>

    <div class="container">
        <nav>
            <button id="navDashboard" class="active">Dashboard</button>
            <button id="navCreateTournament">Create Tournament</button>
            <button id="navImportExport">Import/Export</button>
        </nav>

        <main id="appContent">
            <!-- Dashboard Section -->
            <section id="dashboardSection" class="content-section">
                <h2>All Tournaments</h2>
                <div class="search-filter-bar">
                    <input type="text" id="tournamentSearch" placeholder="Search tournaments...">
                    <select id="tournamentFilterStatus">
                        <option value="">All Statuses</option>
                        <option value="Upcoming">Upcoming</option>
                        <option value="Active">Active</option>
                        <option value="Completed">Completed</option>
                    </select>
                    <select id="tournamentFilterSport">
                        <option value="">All Sports</option>
                        <option value="Football">Football</option>
                        <option value="Basketball">Basketball</option>
                        <option value="Tennis">Tennis</option>
                        <option value="Esports">Esports</option>
                        <option value="Chess">Chess</option>
                        <option value="Volleyball">Volleyball</option>
                        <option value="Badminton">Badminton</option>
                        <option value="Table Tennis">Table Tennis</option>
                        <option value="Cricket">Cricket</option>
                        <option value="Rugby">Rugby</option>
                        <option value="Hockey">Hockey</option>
                        <option value="Baseball">Baseball</option>
                        <option value="Softball">Softball</option>
                        <option value="Swimming">Swimming</option>
                        <option value="Athletics">Athletics</option>
                        <option value="Boxing">Boxing</option>
                        <option value="MMA">MMA</option>
                        <option value="Golf">Golf</option>
                        <option value="Darts">Darts</option>
                        <option value="Pool">Pool</option>
                        <option value="Other">Other</option>
                    </select>
                    <select id="tournamentFilterType">
                        <option value="">All Types</option>
                        <option value="Single Elimination">Single Elimination</option>
                        <option value="Double Elimination">Double Elimination</option>
                        <option value="Round Robin">Round Robin</option>
                        <option value="Multi-Stage">Multi-Stage</option>
                        <option value="Group Stage">Group Stage</option> <!-- NEW -->
                        <option value="Swiss System">Swiss System</option>
                        <option value="GSL Format">GSL Format</option>
                        <option value="Ladder">Ladder</option>
                    </select>
                </div>
                <div id="tournamentList" class="tournament-list">
                    <p class="no-data">No tournaments created yet. Go to "Create Tournament" to get started!</p>
                </div>
            </section>

            <!-- Create Tournament Section -->
            <section id="createTournamentSection" class="content-section hidden">
                <h2>Create New Tournament</h2>
                <form id="createTournamentForm">
                    <div class="form-grid">
                        <div class="form-group">
                            <label for="tournamentName">Tournament Name <span style="color:red">*</span></label>
                            <input type="text" id="tournamentName" required>
                        </div>
                        <div class="form-group">
                            <label for="tournamentSport">Sport <span style="color:red">*</span></label>
                            <select id="tournamentSport" required>
                                <option value="">Select Sport</option>
                                <option value="Football">Football</option>
                                <option value="Basketball">Basketball</option>
                                <option value="Tennis">Tennis</option>
                                <option value="Esports">Esports</option>
                                <option value="Chess">Chess</option>
                                <option value="Volleyball">Volleyball</option>
                                <option value="Badminton">Badminton</option>
                                <option value="Table Tennis">Table Tennis</option>
                                <option value="Cricket">Cricket</option>
                                <option value="Rugby">Rugby</option>
                                <option value="Hockey">Hockey</option>
                                <option value="Baseball">Baseball</option>
                                <option value="Softball">Softball</option>
                                <option value="Swimming">Swimming</option>
                                <option value="Athletics">Athletics</option>
                                <option value="Boxing">Boxing</option>
                                <option value="MMA">MMA</option>
                                <option value="Golf">Golf</option>
                                <option value="Darts">Darts</option>
                                <option value="Pool">Pool</option>
                                <option value="Other">Other</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label for="tournamentType">Tournament Type <span style="color:red">*</span></label>
                            <select id="tournamentType" required>
                                <option value="">Select Type</option>
                                <option value="Single Elimination">Single Elimination</option>
                                <option value="Double Elimination">Double Elimination</option>
                                <option value="Round Robin">Round Robin</option>
                                <option value="Multi-Stage">Multi-Stage</option>
                                <option value="Group Stage">Group Stage</option> <!-- NEW -->
                                <option value="Swiss System">Swiss System</option>
                                <option value="GSL Format">GSL Format</option>
                                <option value="Ladder">Ladder</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label for="tournamentStartDate">Start Date</label>
                            <input type="date" id="tournamentStartDate">
                        </div>
                        <div class="form-group">
                            <label for="tournamentEndDate">End Date</label>
                            <input type="date" id="tournamentEndDate">
                        </div>
                        <div class="form-group">
                            <label for="tournamentMaxParticipants">Max Participants</label>
                            <input type="number" id="tournamentMaxParticipants" min="2" placeholder="Optional">
                        </div>
                        <div class="form-group">
                            <label for="tournamentEntryFee">Entry Fee ($)</label>
                            <input type="number" id="tournamentEntryFee" min="0" step="0.01" value="0">
                        </div>
                        <div class="form-group">
                            <label for="tournamentPrizePool">Prize Pool ($)</label>
                            <input type="number" id="tournamentPrizePool" min="0" step="0.01" value="0">
                        </div>
                    </div>
                    <div class="form-group">
                        <label for="tournamentDescription">Description</label>
                        <textarea id="tournamentDescription" rows="3"></textarea>
                    </div>

                    <div id="eliminationSettings" class="hidden">
                        <h3>Elimination Specific Settings</h3>
                        <div class="form-group">
                            <label for="tournamentBestOf">Best-of-N Series (e.g., 1 for single match, 3 for best of 3)</label>
                            <input type="number" id="tournamentBestOf" min="1" value="1">
                        </div>
                    </div>

                    <div class="checkbox-group">
                        <input type="checkbox" id="tournamentSetBasedScoring">
                        <label for="tournamentSetBasedScoring">Enable Set-Based Scoring (e.g., "3-0, 2-1")</label>
                    </div>

                    <div class="form-group">
                        <label for="tournamentPlayerStatsFields">Custom Player Stats Fields (comma-separated, e.g., Goals, Assists, Kills, Deaths)</label>
                        <input type="text" id="tournamentPlayerStatsFields" placeholder="e.g., Goals, Assists">
                    </div>

                    <div id="roundRobinSettings" class="hidden">
                        <h3>Round Robin Specific Settings</h3>
                        <div class="checkbox-group">
                            <input type="checkbox" id="rrEnableHomeAway">
                            <label for="rrEnableHomeAway">Enable Home/Away Games</label>
                        </div>
                        <div class="form-grid">
                            <div class="form-group">
                                <label for="rrPointsWin">Points for Win</label>
                                <input type="number" id="rrPointsWin" value="3" min="0">
                            </div>
                            <div class="form-group">
                                <label for="rrPointsDraw">Points for Draw</label>
                                <input type="number" id="rrPointsDraw" value="1" min="0">
                            </div>
                            <div class="form-group">
                                <label for="rrPointsLoss">Points for Loss</label>
                                <input type="number" id="rrPointsLoss" value="0" min="0">
                            </div>
                            <div class="form-group">
                                <label for="rrTieBreaker">Tie-breaker Preference</label>
                                <select id="rrTieBreaker">
                                    <option value="Points">Points (default)</option>
                                    <option value="Head-to-Head">Head-to-Head</option>
                                    <option value="Score Difference">Score Difference</option>
                                    <option value="Score For">Score For</option>
                                    <option value="Random">Random</option>
                                </select>
                            </div>
                        </div>
                    </div>

                    <!-- NEW: Group Stage Settings -->
                    <div id="groupStageSettings" class="hidden">
                        <h3>Group Stage Specific Settings</h3>
                        <div class="form-grid">
                            <div class="form-group">
                                <label for="groupStageGroupsCount">Number of Groups <span style="color:red">*</span></label>
                                <input type="number" id="groupStageGroupsCount" min="1" value="4" required>
                            </div>
                            <div class="form-group">
                                <label for="groupStageAdvanceK">Teams to Advance per Group <span style="color:red">*</span></label>
                                <input type="number" id="groupStageAdvanceK" min="1" value="2" required>
                            </div>
                            <div class="form-group">
                                <label for="groupStagePointsWin">Points for Win</label>
                                <input type="number" id="groupStagePointsWin" value="3" min="0">
                            </div>
                            <div class="form-group">
                                <label for="groupStagePointsDraw">Points for Draw</label>
                                <input type="number" id="groupStagePointsDraw" value="1" min="0">
                            </div>
                            <div class="form-group">
                                <label for="groupStagePointsLoss">Points for Loss</label>
                                <input type="number" id="groupStagePointsLoss" value="0" min="0">
                            </div>
                            <div class="form-group">
                                <label for="groupStageTieBreaker">Tie-breaker Preference</label>
                                <select id="groupStageTieBreaker">
                                    <option value="Points">Points (default)</option>
                                    <option value="Head-to-Head">Head-to-Head</option>
                                    <option value="Score Difference">Score Difference</option>
                                    <option value="Score For">Score For</option>
                                    <option value="Random">Random</option>
                                </select>
                            </div>
                        </div>
                    </div>

                    <!-- Placeholders for future tournament types -->
                    <div id="swissSettings" class="hidden">
                        <h3>Swiss System Specific Settings</h3>
                        <div class="form-group">
                            <label for="swissRounds">Number of Rounds</label>
                            <input type="number" id="swissRounds" value="5" min="1">
                        </div>
                        <p><i>(Advanced pairing logic and tiebreakers not yet implemented)</i></p>
                    </div>

                    <div id="gslSettings" class="hidden">
                        <h3>GSL Format Specific Settings</h3>
                        <p><i>(GSL format logic not yet implemented)</i></p>
                    </div>

                    <div id="ladderSettings" class="hidden">
                        <h3>Ladder Specific Settings</h3>
                        <p><i>(Ladder format logic not yet implemented)</i></p>
                    </div>


                    <div class="btn-group">
                        <button type="submit" class="btn btn-primary">Create Tournament</button>
                        <button type="reset" class="btn btn-outline">Clear Form</button>
                    </div>
                </form>
            </section>

            <!-- Tournament Detail Section (Dynamically loaded) -->
            <section id="tournamentDetailSection" class="content-section hidden">
                <div class="tournament-detail-header">
                    <h2 id="detailTournamentName"></h2>
                    <div class="btn-group">
                        <button id="editTournamentBtn" class="btn btn-secondary">Edit Tournament</button>
                        <button id="deleteTournamentBtn" class="btn btn-danger">Delete Tournament</button>
                        <select id="changeTournamentStatus" class="btn btn-outline">
                            <option value="Upcoming">Set Upcoming</option>
                            <option value="Active">Set Active</option>
                            <option value="Completed">Set Completed</option>
                        </select>
                        <button id="showQrCodeBtn" class="btn btn-outline">Show QR Code</button>
                        <button id="backToDashboardBtn" class="btn btn-outline">Back to Dashboard</button>
                    </div>
                </div>

                <div class="tournament-info-grid" id="tournamentInfoDisplay">
                    <!-- Info items will be loaded here -->
                </div>

                <hr style="margin: 30px 0; border-color: var(--border-color);">

                <h3>Participants (<span id="participantCount">0</span>/<span id="maxParticipants">∞</span>)</h3>
                <div class="flex-between" style="margin-bottom: 15px;">
                    <div class="flex-gap-10">
                        <button id="addParticipantBtn" class="btn btn-primary">Add Participant</button>
                        <button id="bulkImportParticipantsBtn" class="btn btn-secondary">Bulk Import (CSV)</button>
                        <button id="copyParticipantsBtn" class="btn btn-secondary">Copy from Tournament</button>
                    </div>
                    <div class="flex-gap-10">
                        <button id="generateBracketBtn" class="btn btn-secondary hidden">Generate Bracket</button>
                        <button id="generateDoubleEliminationBracketBtn" class="btn btn-secondary hidden">Generate DE Bracket</button>
                        <button id="generateRoundRobinBtn" class="btn btn-secondary hidden">Generate Matches</button>
                        <button id="manageStagesBtn" class="btn btn-secondary hidden">Manage Stages</button>
                        <button id="generateGroupStageBtn" class="btn btn-secondary hidden">Generate Groups</button> <!-- NEW -->
                        <!-- New buttons for future formats -->
                        <button id="generateSwissBtn" class="btn btn-secondary hidden">Generate Swiss Rounds</button>
                        <button id="generateGSLBtn" class="btn btn-secondary hidden">Generate GSL Group</button>
                        <button id="manageLadderBtn" class="btn btn-secondary hidden">Manage Ladder</button>
                    </div>
                </div>
                <div id="participantsList" class="participants-list">
                    <p class="no-data">No participants added yet.</p>
                </div>

                <hr style="margin: 30px 0; border-color: var(--border-color);">

                <div id="eliminationBracketSection" class="hidden">
                    <h3>Bracket</h3>
                    <div id="bracketVisualizer" class="bracket-visualizer">
                        <p class="no-data">Bracket not generated. Add participants and click "Generate Bracket".</p>
                    </div>
                </div>

                <div id="doubleEliminationBracketSection" class="hidden">
                    <h3>Double Elimination Bracket</h3>
                    <div id="doubleEliminationWrapper" class="double-elimination-wrapper">
                        <p class="no-data">Double Elimination Bracket not generated. Add participants and click "Generate DE Bracket".</p>
                    </div>
                </div>

                <div id="roundRobinMatchesSection" class="hidden">
                    <h3>Matches</h3>
                    <div id="roundRobinMatches">
                        <p class="no-data">Matches not generated. Add participants and click "Generate Matches".</p>
                    </div>
                    <h3 style="margin-top: 30px;">Standings</h3>
                    <div id="roundRobinStandings">
                        <p class="no-data">Standings will appear after matches are generated and scores recorded.</p>
                    </div>
                </div>

                <div id="multiStageContainer" class="hidden">
                    <h3>Tournament Stages</h3>
                    <div id="stagesList">
                        <p class="no-data">No stages defined. Click "Manage Stages" to add them.</p>
                    </div>
                </div>

                <!-- NEW: Group Stage Section -->
                <div id="groupStageSection" class="hidden">
                    <h3>Groups</h3>
                    <div id="groupsDisplay">
                        <p class="no-data">Groups not generated. Add participants and click "Generate Groups".</p>
                    </div>
                    <h3 style="margin-top: 30px;">Player Leaderboards</h3>
                    <div id="playerLeaderboardsDisplay">
                        <p class="no-data">Player stats will appear after matches are played.</p>
                    </div>
                </div>

                <!-- Placeholders for future tournament types -->
                <div id="swissSection" class="hidden">
                    <h3>Swiss System Rounds</h3>
                    <div id="swissRoundsDisplay">
                        <p class="no-data">Swiss rounds not generated.</p>
                    </div>
                    <h3 style="margin-top: 30px;">Swiss Standings</h3>
                    <div id="swissStandingsDisplay">
                        <p class="no-data">Swiss standings will appear after rounds are generated and scores recorded.</p>
                    </div>
                </div>

                <div id="gslSection" class="hidden">
                    <h3>GSL Groups</h3>
                    <div id="gslGroupsDisplay">
                        <p class="no-data">GSL groups not generated.</p>
                    </div>
                </div>

                <div id="ladderSection" class="hidden">
                    <h3>Ladder Rankings</h3>
                    <div id="ladderRankingsDisplay">
                        <p class="no-data">Ladder not initialized.</p>
                    </div>
                </div>

            </section>

            <!-- Import/Export Section -->
            <section id="importExportSection" class="content-section hidden">
                <h2>Import / Export Data</h2>
                <div class="form-group">
                    <label>Export All Tournament Data</label>
                    <button id="exportDataBtn" class="btn btn-primary">Download Data (JSON)</button>
                    <p style="font-size: 0.9em; margin-top: 5px; opacity: 0.8;">This will download all your tournament data as a JSON file.</p>
                </div>
                <hr style="margin: 30px 0; border-color: var(--border-color);">
                <div class="form-group">
                    <label for="importFileInput">Import Tournament Data</label>
                    <input type="file" id="importFileInput" accept=".json">
                    <button id="importDataBtn" class="btn btn-secondary" style="margin-top: 10px;">Upload & Import Data</button>
                    <p style="font-size: 0.9em; margin-top: 5px; opacity: 0.8;">Upload a JSON file to restore or add tournament data. Existing tournaments with the same ID will be overwritten.</p>
                </div>
            </section>
        </main>
    </div>

    <footer>
        <p>&copy; 2023 Ultimate Tournament Manager. All data saved locally in your browser.</p>
    </footer>

    <!-- Modals -->

    <!-- Add/Edit Participant Modal -->
    <div id="participantModal" class="modal">
        <div class="modal-content">
            <span class="close-button" onclick="closeModal('participantModal')">&times;</span>
            <h3 id="participantModalTitle">Add Participant</h3>
            <form id="participantForm">
                <input type="hidden" id="participantId">
                <div class="form-group">
                    <label for="participantName">Name / Team Name <span style="color:red">*</span></label>
                    <input type="text" id="participantName" required>
                </div>
                <div class="form-group">
                    <label for="participantSeed">Seed (lower number = higher seed, for Elimination brackets)</label>
                    <input type="number" id="participantSeed" min="1" placeholder="Optional">
                </div>
                <div class="form-group">
                    <label for="participantRating">Rating (e.g., Elo, for Swiss/Ladder)</label>
                    <input type="number" id="participantRating" placeholder="Optional">
                </div>
                <div class="form-group">
                    <label for="participantContact">Contact Info</label>
                    <input type="text" id="participantContact" placeholder="Email, Phone, etc.">
                </div>
                <div class="form-group">
                    <label for="participantNotes">Notes</label>
                    <textarea id="participantNotes" rows="2"></textarea>
                </div>
                <div class="btn-group">
                    <button type="submit" class="btn btn-primary">Save Participant</button>
                    <button type="button" class="btn btn-outline" onclick="closeModal('participantModal')">Cancel</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Edit Tournament Modal -->
    <div id="editTournamentModal" class="modal">
        <div class="modal-content">
            <span class="close-button" onclick="closeModal('editTournamentModal')">&times;</span>
            <h3>Edit Tournament</h3>
            <form id="editTournamentForm">
                <input type="hidden" id="editTournamentId">
                <div class="form-grid">
                    <div class="form-group">
                        <label for="editTournamentName">Tournament Name <span style="color:red">*</span></label>
                        <input type="text" id="editTournamentName" required>
                    </div>
                    <div class="form-group">
                        <label for="editTournamentSport">Sport <span style="color:red">*</span></label>
                        <select id="editTournamentSport" required>
                            <option value="Football">Football</option>
                            <option value="Basketball">Basketball</option>
                            <option value="Tennis">Tennis</option>
                            <option value="Esports">Esports</option>
                            <option value="Chess">Chess</option>
                            <option value="Volleyball">Volleyball</option>
                            <option value="Badminton">Badminton</option>
                            <option value="Table Tennis">Table Tennis</option>
                            <option value="Cricket">Cricket</option>
                            <option value="Rugby">Rugby</option>
                            <option value="Hockey">Hockey</option>
                            <option value="Baseball">Baseball</option>
                            <option value="Softball">Softball</option>
                            <option value="Swimming">Swimming</option>
                            <option value="Athletics">Athletics</option>
                            <option value="Boxing">Boxing</option>
                            <option value="MMA">MMA</option>
                            <option value="Golf">Golf</option>
                            <option value="Darts">Darts</option>
                            <option value="Pool">Pool</option>
                            <option value="Other">Other</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label for="editTournamentType">Tournament Type <span style="color:red">*</span></label>
                        <select id="editTournamentType" required disabled>
                            <option value="Single Elimination">Single Elimination</option>
                            <option value="Double Elimination">Double Elimination</option>
                            <option value="Round Robin">Round Robin</option>
                            <option value="Multi-Stage">Multi-Stage</option>
                            <option value="Group Stage">Group Stage</option> <!-- NEW -->
                            <option value="Swiss System">Swiss System</option>
                            <option value="GSL Format">GSL Format</option>
                            <option value="Ladder">Ladder</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label for="editTournamentStartDate">Start Date</label>
                        <input type="date" id="editTournamentStartDate">
                    </div>
                    <div class="form-group">
                        <label for="editTournamentEndDate">End Date</label>
                        <input type="date" id="editTournamentEndDate">
                    </div>
                    <div class="form-group">
                        <label for="editTournamentMaxParticipants">Max Participants</label>
                        <input type="number" id="editTournamentMaxParticipants" min="2">
                    </div>
                    <div class="form-group">
                        <label for="editTournamentEntryFee">Entry Fee ($)</label>
                        <input type="number" id="editTournamentEntryFee" min="0" step="0.01">
                    </div>
                    <div class="form-group">
                        <label for="editTournamentPrizePool">Prize Pool ($)</label>
                        <input type="number" id="editTournamentPrizePool" min="0" step="0.01">
                    </div>
                </div>
                <div class="form-group">
                    <label for="editTournamentDescription">Description</label>
                    <textarea id="editTournamentDescription" rows="3"></textarea>
                </div>

                <div id="editEliminationSettings" class="hidden">
                    <h3>Elimination Specific Settings</h3>
                    <div class="form-group">
                        <label for="editTournamentBestOf">Best-of-N Series (e.g., 1 for single match, 3 for best of 3)</label>
                        <input type="number" id="editTournamentBestOf" min="1">
                    </div>
                </div>

                <div class="checkbox-group">
                    <input type="checkbox" id="editTournamentSetBasedScoring">
                    <label for="editTournamentSetBasedScoring">Enable Set-Based Scoring (e.g., "3-0, 2-1")</label>
                </div>

                <div class="form-group">
                    <label for="editTournamentPlayerStatsFields">Custom Player Stats Fields (comma-separated, e.g., Goals, Assists, Kills, Deaths)</label>
                    <input type="text" id="editTournamentPlayerStatsFields" placeholder="e.g., Goals, Assists">
                </div>

                <div id="editRoundRobinSettings" class="hidden">
                    <h3>Round Robin Specific Settings</h3>
                    <div class="checkbox-group">
                        <input type="checkbox" id="editRrEnableHomeAway">
                        <label for="editRrEnableHomeAway">Enable Home/Away Games</label>
                    </div>
                    <div class="form-grid">
                        <div class="form-group">
                            <label for="editRrPointsWin">Points for Win</label>
                            <input type="number" id="editRrPointsWin" min="0">
                        </div>
                        <div class="form-group">
                            <label for="editRrPointsDraw">Points for Draw</label>
                            <input type="number" id="editRrPointsDraw" min="0">
                        </div>
                        <div class="form-group">
                            <label for="editRrPointsLoss">Points for Loss</label>
                            <input type="number" id="editRrPointsLoss" min="0">
                        </div>
                        <div class="form-group">
                            <label for="editRrTieBreaker">Tie-breaker Preference</label>
                            <select id="editRrTieBreaker">
                                <option value="Points">Points (default)</option>
                                <option value="Head-to-Head">Head-to-Head</option>
                                <option value="Score Difference">Score Difference</option>
                                <option value="Score For">Score For</option>
                                <option value="Random">Random</option>
                            </select>
                        </div>
                    </div>
                </div>

                <!-- NEW: Edit Group Stage Settings -->
                <div id="editGroupStageSettings" class="hidden">
                    <h3>Group Stage Specific Settings</h3>
                    <div class="form-grid">
                        <div class="form-group">
                            <label for="editGroupStageGroupsCount">Number of Groups <span style="color:red">*</span></label>
                            <input type="number" id="editGroupStageGroupsCount" min="1" required>
                        </div>
                        <div class="form-group">
                            <label for="editGroupStageAdvanceK">Teams to Advance per Group <span style="color:red">*</span></label>
                            <input type="number" id="editGroupStageAdvanceK" min="1" required>
                        </div>
                        <div class="form-group">
                            <label for="editGroupStagePointsWin">Points for Win</label>
                            <input type="number" id="editGroupStagePointsWin" min="0">
                        </div>
                        <div class="form-group">
                            <label for="editGroupStagePointsDraw">Points for Draw</label>
                            <input type="number" id="editGroupStagePointsDraw" min="0">
                        </div>
                        <div class="form-group">
                            <label for="editGroupStagePointsLoss">Points for Loss</label>
                            <input type="number" id="editGroupStagePointsLoss" min="0">
                        </div>
                        <div class="form-group">
                            <label for="editGroupStageTieBreaker">Tie-breaker Preference</label>
                            <select id="editGroupStageTieBreaker">
                                <option value="Points">Points (default)</option>
                                <option value="Head-to-Head">Head-to-Head</option>
                                <option value="Score Difference">Score Difference</option>
                                <option value="Score For">Score For</option>
                                <option value="Random">Random</option>
                            </select>
                        </div>
                    </div>
                </div>

                <!-- Placeholders for future tournament types -->
                <div id="editSwissSettings" class="hidden">
                    <h3>Swiss System Specific Settings</h3>
                    <div class="form-group">
                        <label for="editSwissRounds">Number of Rounds</label>
                        <input type="number" id="editSwissRounds" min="1">
                    </div>
                    <p><i>(Advanced pairing logic and tiebreakers not yet implemented)</i></p>
                </div>

                <div id="editGslSettings" class="hidden">
                    <h3>GSL Format Specific Settings</h3>
                    <p><i>(GSL format logic not yet implemented)</i></p>
                </div>

                <div id="editLadderSettings" class="hidden">
                    <h3>Ladder Specific Settings</h3>
                    <p><i>(Ladder format logic not yet implemented)</i></p>
                </div>

                <div class="btn-group">
                    <button type="submit" class="btn btn-primary">Save Changes</button>
                    <button type="button" class="btn btn-outline" onclick="closeModal('editTournamentModal')">Cancel</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Bulk Import Participants Modal -->
    <div id="bulkImportModal" class="modal">
        <div class="modal-content">
            <span class="close-button" onclick="closeModal('bulkImportModal')">&times;</span>
            <h3>Bulk Import Participants (CSV)</h3>
            <p>Upload a CSV file with participant names. Each name should be on a new line.</p>
            <div class="form-group">
                <label for="bulkImportFileInput">Select CSV File</label>
                <input type="file" id="bulkImportFileInput" accept=".csv">
            </div>
            <div class="btn-group">
                <button id="processBulkImportBtn" class="btn btn-primary">Import Participants</button>
                <button type="button" class="btn btn-outline" onclick="closeModal('bulkImportModal')">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Copy Participants Modal -->
    <div id="copyParticipantsModal" class="modal">
        <div class="modal-content">
            <span class="close-button" onclick="closeModal('copyParticipantsModal')">&times;</span>
            <h3>Copy Participants from Another Tournament</h3>
            <div class="form-group">
                <label for="copyFromTournamentSelect">Select Tournament to Copy From</label>
                <select id="copyFromTournamentSelect">
                    <option value="">-- Select a Tournament --</option>
                </select>
            </div>
            <div class="btn-group">
                <button id="processCopyParticipantsBtn" class="btn btn-primary">Copy Participants</button>
                <button type="button" class="btn btn-outline" onclick="closeModal('copyParticipantsModal')">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Match Details Modal (for editing schedule/stats) -->
    <div id="matchDetailsModal" class="modal">
        <div class="modal-content">
            <span class="close-button" onclick="closeModal('matchDetailsModal')">&times;</span>
            <h3 id="matchDetailsModalTitle">Match Details</h3>
            <form id="matchDetailsForm">
                <input type="hidden" id="matchDetailsMatchId">
                <input type="hidden" id="matchDetailsRoundIndex">
                <input type="hidden" id="matchDetailsBracketType"> <!-- 'rounds', 'winnerBracket', 'loserBracket', 'grandFinal', 'matches', 'groupMatches' -->
                <input type="hidden" id="matchDetailsStageId"> <!-- For multi-stage tournaments -->
                <input type="hidden" id="matchDetailsGroupId"> <!-- For group stage tournaments -->

                <div class="form-grid">
                    <div class="form-group">
                        <label for="matchDetailsPlayer1">Player 1</label>
                        <input type="text" id="matchDetailsPlayer1" disabled>
                    </div>
                    <div class="form-group">
                        <label for="matchDetailsPlayer2">Player 2</label>
                        <input type="text" id="matchDetailsPlayer2" disabled>
                    </div>
                    <div class="form-group">
                        <label for="matchDetailsBestOf">Best-of-N</label>
                        <input type="number" id="matchDetailsBestOf" min="1">
                    </div>
                    <div class="form-group">
                        <label for="matchDetailsDate">Date</label>
                        <input type="date" id="matchDetailsDate">
                    </div>
                    <div class="form-group">
                        <label for="matchDetailsTime">Time</label>
                        <input type="time" id="matchDetailsTime">
                    </div>
                    <div class="form-group">
                        <label for="matchDetailsVenue">Venue</label>
                        <input type="text" id="matchDetailsVenue" placeholder="e.g., Main Arena">
                    </div>
                    <div class="form-group">
                        <label for="matchDetailsReferee">Referee</label>
                        <input type="text" id="matchDetailsReferee" placeholder="e.g., John Doe">
                    </div>
                </div>

                <div id="matchDetailsPlayerStats" style="margin-top: 20px;">
                    <h4>Player Stats</h4>
                    <div id="player1StatsInputs" class="form-grid"></div>
                    <div id="player2StatsInputs" class="form-grid"></div>
                </div>

                <div class="btn-group">
                    <button type="submit" class="btn btn-primary">Save Match Details</button>
                    <button type="button" class="btn btn-outline" onclick="closeModal('matchDetailsModal')">Cancel</button>
                </div>
            </form>
        </div>
    </div>

    <!-- QR Code Modal -->
    <div id="qrCodeModal" class="modal">
        <div class="modal-content text-center">
            <span class="close-button" onclick="closeModal('qrCodeModal')">&times;</span>
            <h3>Tournament QR Code</h3>
            <p>Scan this QR code to quickly identify this tournament (e.g., for sharing its ID).</p>
            <div id="qrCodeContainer" style="margin: 20px auto; width: 200px; height: 200px;"></div>
            <p style="font-size: 0.9em; opacity: 0.8;">Tournament ID: <span id="qrTournamentId"></span></p>
        </div>
    </div>

    <!-- Manage Stages Modal -->
    <div id="manageStagesModal" class="modal">
        <div class="modal-content">
            <span class="close-button" onclick="closeModal('manageStagesModal')">&times;</span>
            <h3>Manage Stages</h3>
            <div id="currentStagesList">
                <p class="no-data">No stages added yet.</p>
            </div>
            <div class="btn-group">
                <button id="addStageBtn" class="btn btn-primary">Add New Stage</button>
            </div>
        </div>
    </div>

    <!-- Add/Edit Stage Modal -->
    <div id="stageModal" class="modal">
        <div class="modal-content">
            <span class="close-button" onclick="closeModal('stageModal')">&times;</span>
            <h3 id="stageModalTitle">Add Stage</h3>
            <form id="stageForm">
                <input type="hidden" id="stageId">
                <div class="form-group">
                    <label for="stageName">Stage Name <span style="color:red">*</span></label>
                    <input type="text" id="stageName" required>
                </div>
                <div class="form-group">
                    <label for="stageType">Stage Type <span style="color:red">*</span></label>
                    <select id="stageType" required>
                        <option value="">Select Type</option>
                        <option value="Single Elimination">Single Elimination</option>
                        <option value="Round Robin">Round Robin</option>
                        <!-- Add other stage types here if needed -->
                    </select>
                </div>

                <div id="stageEliminationSettings" class="hidden">
                    <h4>Elimination Specific Settings</h4>
                    <div class="form-group">
                        <label for="stageBestOf">Best-of-N Series</label>
                        <input type="number" id="stageBestOf" min="1" value="1">
                    </div>
                </div>

                <div id="stageRoundRobinSettings" class="hidden">
                    <h4>Round Robin Specific Settings</h4>
                    <div class="checkbox-group">
                        <input type="checkbox" id="stageRrEnableHomeAway">
                        <label for="stageRrEnableHomeAway">Enable Home/Away Games</label>
                    </div>
                    <div class="form-grid">
                        <div class="form-group">
                            <label for="stageRrPointsWin">Points for Win</label>
                            <input type="number" id="stageRrPointsWin" value="3" min="0">
                        </div>
                        <div class="form-group">
                            <label for="stageRrPointsDraw">Points for Draw</label>
                            <input type="number" id="stageRrPointsDraw" value="1" min="0">
                        </div>
                        <div class="form-group">
                            <label for="stageRrPointsLoss">Points for Loss</label>
                            <input type="number" id="stageRrPointsLoss" value="0" min="0">
                        </div>
                        <div class="form-group">
                            <label for="stageRrTieBreaker">Tie-breaker Preference</label>
                            <select id="stageRrTieBreaker">
                                <option value="Points">Points (default)</option>
                                <option value="Head-to-Head">Head-to-Head</option>
                                <option value="Score Difference">Score Difference</option>
                                <option value="Score For">Score For</option>
                                <option value="Random">Random</option>
                            </select>
                        </div>
                    </div>
                </div>
                <div class="btn-group">
                    <button type="submit" class="btn btn-primary">Save Stage</button>
                    <button type="button" class="btn btn-outline" onclick="closeModal('stageModal')">Cancel</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Advance Participants Modal -->
    <div id="advanceParticipantsModal" class="modal">
        <div class="modal-content">
            <span class="close-button" onclick="closeModal('advanceParticipantsModal')">&times;</span>
            <h3>Advance Participants to Stage</h3>
            <p>Select participants from the tournament's overall participant list to add to this stage.</p>
            <input type="hidden" id="advanceStageId">
            <div id="availableParticipantsList" class="participants-list" style="max-height: 300px; overflow-y: auto; border: 1px solid var(--border-color); padding: 10px; border-radius: var(--radius);">
                <!-- Checkboxes for participants -->
            </div>
            <div class="btn-group">
                <button id="processAdvanceParticipantsBtn" class="btn btn-primary">Add Selected Participants</button>
                <button type="button" class="btn btn-outline" onclick="closeModal('advanceParticipantsModal')">Cancel</button>
            </div>
        </div>
    </div>

    <script>
        // --- Inlined QR Code Generator (qrious.js - simplified for single file) ---
        // This is a very basic, self-contained QR code generator.
        // For more robust features, a full library would be used.
        // Source: https://github.com/neocult/qrious (simplified)
        (function() {
            function QRCode(options) {
                options = options || {};
                this.value = options.value || '';
                this.size = options.size || 100;
                this.level = options.level || 'L'; // L, M, Q, H
                this.background = options.background || '#ffffff';
                this.foreground = options.foreground || '#000000';
                this.element = options.element || null;

                this.canvas = document.createElement('canvas');
                this.canvas.width = this.size;
                this.canvas.height = this.size;
                this.context = this.canvas.getContext('2d');

                if (this.element) {
                    this.element.appendChild(this.canvas);
                }

                this.update = function() {
                    if (!this.value) {
                        this.context.clearRect(0, 0, this.size, this.size);
                        return;
                    }

                    // Simplified QR code generation (not a full QR library)
                    // This will just draw a simple pattern for demonstration.
                    // A real QR code library would involve complex encoding.
                    // For this single HTML file, we'll draw a placeholder.
                    this.context.fillStyle = this.background;
                    this.context.fillRect(0, 0, this.size, this.size);
                    this.context.fillStyle = this.foreground;

                    const cellSize = this.size / 10; // Simple grid
                    for (let i = 0; i < 10; i++) {
                        for (let j = 0; j < 10; j++) {
                            if ((i + j) % 2 === 0) {
                                this.context.fillRect(i * cellSize, j * cellSize, cellSize, cellSize);
                            }
                        }
                    }
                    this.context.font = `${this.size / 8}px Arial`;
                    this.context.textAlign = 'center';
                    this.context.textBaseline = 'middle';
                    this.context.fillStyle = this.background;
                    this.context.fillRect(this.size/4, this.size/2 - this.size/10, this.size/2, this.size/5);
                    this.context.fillStyle = this.foreground;
                    this.context.fillText("ID", this.size / 2, this.size / 2);
                    // End of simplified placeholder

                    // If you want a real QR code, you'd need a full library here.
                    // Example with a real library (if you were to include it):
                    /*
                    const qr = new QRious({
                        value: this.value,
                        size: this.size,
                        level: this.level,
                        background: this.background,
                        foreground: this.foreground
                    });
                    this.context.drawImage(qr.canvas, 0, 0);
                    */
                };
                this.update();
            }

            window.QRCode = QRCode;
        })();
        // --- End Inlined QR Code Generator ---


        // --- Global State & Constants ---
        const LS_KEY = 'tournamentManagerData';
        const LS_THEME_KEY = 'tournamentManagerTheme';
        let tournaments = [];
        let currentTournamentId = null;

        const TOURNAMENT_TYPES = {
            SINGLE_ELIMINATION: 'Single Elimination',
            DOUBLE_ELIMINATION: 'Double Elimination',
            ROUND_ROBIN: 'Round Robin',
            MULTI_STAGE: 'Multi-Stage',
            GROUP_STAGE: 'Group Stage', // NEW
            SWISS_SYSTEM: 'Swiss System',
            GSL_FORMAT: 'GSL Format',
            LADDER: 'Ladder'
        };

        const TOURNAMENT_STATUS = {
            UPCOMING: 'Upcoming',
            ACTIVE: 'Active',
            COMPLETED: 'Completed'
        };

        // --- Utility Functions ---
        function generateUniqueId() {
            return Date.now().toString(36) + Math.random().toString(36).substr(2, 5);
        }

        function saveData() {
            localStorage.setItem(LS_KEY, JSON.stringify(tournaments));
        }

        function loadData() {
            const data = localStorage.getItem(LS_KEY);
            tournaments = data ? JSON.parse(data) : [];
            // Ensure new fields are initialized for old data
            tournaments.forEach(t => {
                if (!t.groups) t.groups = []; // For Group Stage
                if (!t.swissRounds) t.swissRounds = [];
                if (!t.gslGroups) t.gslGroups = [];
                if (!t.ladderRanks) t.ladderRanks = [];
                if (!t.settings.groupStage) t.settings.groupStage = {}; // For Group Stage settings
                t.participants.forEach(p => {
                    if (!p.stats) {
                        p.stats = { matchesPlayed: 0, goals: 0, assists: 0, saves: 0, cardsYellow: 0, cardsRed: 0, minutesPlayed: 0, kills: 0, deaths: 0, damage: 0, custom: {} };
                    }
                });
            });
            renderTournamentList();
        }

        function showSection(sectionId) {
            document.querySelectorAll('.content-section').forEach(section => {
                section.classList.add('hidden');
            });
            document.getElementById(sectionId).classList.remove('hidden');

            document.querySelectorAll('nav button').forEach(btn => {
                btn.classList.remove('active');
            });
            document.getElementById(`nav${sectionId.replace('Section', '')}`).classList.add('active');
        }

        function showAlert(message, type = 'success') {
            const alertDiv = document.createElement('div');
            alertDiv.className = `alert alert-${type}`;
            alertDiv.textContent = message;
            document.querySelector('.container').prepend(alertDiv);
            setTimeout(() => alertDiv.remove(), 5000);
        }

        function openModal(modalId) {
            document.getElementById(modalId).style.display = 'block';
        }

        function closeModal(modalId) {
            document.getElementById(modalId).style.display = 'none';
        }

        // --- Theme Toggle ---
        function applyTheme(theme) {
            document.body.classList.toggle('dark-mode', theme === 'dark');
            localStorage.setItem(LS_THEME_KEY, theme);
        }

        function toggleTheme() {
            const currentTheme = localStorage.getItem(LS_THEME_KEY) || 'light';
            applyTheme(currentTheme === 'light' ? 'dark' : 'light');
        }

        // --- Tournament Management ---
        function createTournament(event) {
            event.preventDefault();

            const name = document.getElementById('tournamentName').value;
            const sport = document.getElementById('tournamentSport').value;
            const type = document.getElementById('tournamentType').value;
            const startDate = document.getElementById('tournamentStartDate').value;
            const endDate = document.getElementById('tournamentEndDate').value;
            const maxParticipants = parseInt(document.getElementById('tournamentMaxParticipants').value) || null;
            const entryFee = parseFloat(document.getElementById('tournamentEntryFee').value) || 0;
            const prizePool = parseFloat(document.getElementById('tournamentPrizePool').value) || 0;
            const description = document.getElementById('tournamentDescription').value;
            const setBasedScoring = document.getElementById('tournamentSetBasedScoring').checked;
            const playerStatsFields = document.getElementById('tournamentPlayerStatsFields').value.split(',').map(s => s.trim()).filter(s => s);

            if (!name || !sport || !type) {
                showAlert('Please fill in all required fields (Name, Sport, Type).', 'error');
                return;
            }

            const newTournament = {
                id: generateUniqueId(),
                name, sport, type, startDate, endDate, description,
                maxParticipants, entryFee, prizePool,
                status: TOURNAMENT_STATUS.UPCOMING,
                participants: [], // Overall tournament participants
                rounds: [], // For single elimination
                winnerBracket: [], // For double elimination
                loserBracket: [], // For double elimination
                grandFinal: [], // For double elimination
                matches: [], // For round robin
                stages: [], // For multi-stage
                groups: [], // NEW: For Group Stage
                swissRounds: [],
                gslGroups: [],
                ladderRanks: [],
                settings: {
                    setBasedScoring,
                    playerStatsFields,
                    bestOf: 1, // Default for elimination
                    groupStage: {} // NEW: Group Stage specific settings
                }
            };

            if (type === TOURNAMENT_TYPES.SINGLE_ELIMINATION || type === TOURNAMENT_TYPES.DOUBLE_ELIMINATION) {
                newTournament.settings.bestOf = parseInt(document.getElementById('tournamentBestOf').value) || 1;
            } else if (type === TOURNAMENT_TYPES.ROUND_ROBIN) {
                newTournament.settings.enableHomeAway = document.getElementById('rrEnableHomeAway').checked;
                newTournament.settings.pointsWin = parseInt(document.getElementById('rrPointsWin').value) || 3;
                newTournament.settings.pointsDraw = parseInt(document.getElementById('rrPointsDraw').value) || 1;
                newTournament.settings.pointsLoss = parseInt(document.getElementById('rrPointsLoss').value) || 0;
                newTournament.settings.tieBreaker = document.getElementById('rrTieBreaker').value || 'Points';
            } else if (type === TOURNAMENT_TYPES.GROUP_STAGE) { // NEW
                newTournament.settings.groupStage.groupsCount = parseInt(document.getElementById('groupStageGroupsCount').value) || 1;
                newTournament.settings.groupStage.advanceK = parseInt(document.getElementById('groupStageAdvanceK').value) || 1;
                newTournament.settings.groupStage.pointsWin = parseInt(document.getElementById('groupStagePointsWin').value) || 3;
                newTournament.settings.groupStage.pointsDraw = parseInt(document.getElementById('groupStagePointsDraw').value) || 1;
                newTournament.settings.groupStage.pointsLoss = parseInt(document.getElementById('groupStagePointsLoss').value) || 0;
                newTournament.settings.groupStage.tieBreaker = document.getElementById('groupStageTieBreaker').value || 'Points';
            } else if (type === TOURNAMENT_TYPES.SWISS_SYSTEM) {
                newTournament.settings.swissRounds = parseInt(document.getElementById('swissRounds').value) || 5;
                // Add more Swiss settings here
            }
            // Add settings for other new types here

            tournaments.push(newTournament);
            saveData();
            showAlert('Tournament created successfully!');
            document.getElementById('createTournamentForm').reset();
            renderTournamentList();
            showSection('dashboardSection');
        }

        function renderTournamentList() {
            const listDiv = document.getElementById('tournamentList');
            listDiv.innerHTML = '';

            const searchTerm = document.getElementById('tournamentSearch').value.toLowerCase();
            const filterStatus = document.getElementById('tournamentFilterStatus').value;
            const filterSport = document.getElementById('tournamentFilterSport').value;
            const filterType = document.getElementById('tournamentFilterType').value;

            const filteredTournaments = tournaments.filter(t => {
                const matchesSearch = t.name.toLowerCase().includes(searchTerm);
                const matchesStatus = filterStatus ? t.status === filterStatus : true;
                const matchesSport = filterSport ? t.sport === filterSport : true;
                const matchesType = filterType ? t.type === filterType : true;
                return matchesSearch && matchesStatus && matchesSport && matchesType;
            });

            if (filteredTournaments.length === 0) {
                listDiv.innerHTML = '<p class="no-data">No tournaments found matching your criteria.</p>';
                return;
            }

            filteredTournaments.forEach(tournament => {
                const card = document.createElement('div');
                card.className = 'tournament-card';
                card.innerHTML = `
                    <h3>${tournament.name}</h3>
                    <p><strong>Sport:</strong> ${tournament.sport}</p>
                    <p><strong>Type:</strong> ${tournament.type}</p>
                    <p><strong>Participants:</strong> ${tournament.participants.length} ${tournament.maxParticipants ? `/ ${tournament.maxParticipants}` : ''}</p>
                    <span class="status ${tournament.status.toLowerCase().replace(' ', '-')}">${tournament.status}</span>
                `;
                card.onclick = () => viewTournamentDetails(tournament.id);
                listDiv.appendChild(card);
            });
        }

        function viewTournamentDetails(id) {
            currentTournamentId = id;
            const tournament = tournaments.find(t => t.id === id);
            if (!tournament) {
                showAlert('Tournament not found!', 'error');
                showSection('dashboardSection');
                return;
            }

            document.getElementById('detailTournamentName').textContent = tournament.name;

            const infoDisplay = document.getElementById('tournamentInfoDisplay');
            infoDisplay.innerHTML = `
                <div class="tournament-info-item"><strong>Sport:</strong> ${tournament.sport}</div>
                <div class="tournament-info-item"><strong>Type:</strong> ${tournament.type}</div>
                <div class="tournament-info-item"><strong>Status:</strong> <span class="status ${tournament.status.toLowerCase().replace(' ', '-')}">${tournament.status}</span></div>
                <div class="tournament-info-item"><strong>Start Date:</strong> ${tournament.startDate || 'N/A'}</div>
                <div class="tournament-info-item"><strong>End Date:</strong> ${tournament.endDate || 'N/A'}</div>
                <div class="tournament-info-item"><strong>Max Participants:</strong> ${tournament.maxParticipants || 'Unlimited'}</div>
                <div class="tournament-info-item"><strong>Entry Fee:</strong> $${tournament.entryFee.toFixed(2)}</div>
                <div class="tournament-info-item"><strong>Prize Pool:</strong> $${tournament.prizePool.toFixed(2)}</div>
                <div class="tournament-info-item" style="grid-column: 1 / -1;"><strong>Description:</strong> ${tournament.description || 'No description.'}</div>
                <div class="tournament-info-item"><strong>Set-Based Scoring:</strong> ${tournament.settings.setBasedScoring ? 'Yes' : 'No'}</div>
                <div class="tournament-info-item"><strong>Player Stats:</strong> ${tournament.settings.playerStatsFields && tournament.settings.playerStatsFields.length > 0 ? tournament.settings.playerStatsFields.join(', ') : 'None'}</div>
            `;
            if (tournament.settings.bestOf && (tournament.type === TOURNAMENT_TYPES.SINGLE_ELIMINATION || tournament.type === TOURNAMENT_TYPES.DOUBLE_ELIMINATION)) {
                infoDisplay.innerHTML += `<div class="tournament-info-item"><strong>Best-of-N:</strong> ${tournament.settings.bestOf}</div>`;
            }
            if (tournament.type === TOURNAMENT_TYPES.ROUND_ROBIN) {
                infoDisplay.innerHTML += `
                    <div class="tournament-info-item"><strong>Home/Away:</strong> ${tournament.settings.enableHomeAway ? 'Yes' : 'No'}</div>
                    <div class="tournament-info-item"><strong>Points (W/D/L):</strong> ${tournament.settings.pointsWin}/${tournament.settings.pointsDraw}/${tournament.settings.pointsLoss}</div>
                    <div class="tournament-info-item"><strong>Tie-breaker:</strong> ${tournament.settings.tieBreaker}</div>
                `;
            }
            if (tournament.type === TOURNAMENT_TYPES.GROUP_STAGE) { // NEW
                infoDisplay.innerHTML += `
                    <div class="tournament-info-item"><strong>Groups:</strong> ${tournament.settings.groupStage.groupsCount}</div>
                    <div class="tournament-info-item"><strong>Advance:</strong> ${tournament.settings.groupStage.advanceK} per group</div>
                    <div class="tournament-info-item"><strong>Points (W/D/L):</strong> ${tournament.settings.groupStage.pointsWin}/${tournament.settings.groupStage.pointsDraw}/${tournament.settings.groupStage.pointsLoss}</div>
                    <div class="tournament-info-item"><strong>Tie-breaker:</strong> ${tournament.settings.groupStage.tieBreaker}</div>
                `;
            }
            if (tournament.type === TOURNAMENT_TYPES.SWISS_SYSTEM) {
                infoDisplay.innerHTML += `<div class="tournament-info-item"><strong>Rounds:</strong> ${tournament.settings.swissRounds}</div>`;
            }


            // Update status dropdown
            const statusSelect = document.getElementById('changeTournamentStatus');
            statusSelect.value = tournament.status;

            // Show/hide bracket/round robin/multi-stage sections and buttons
            document.getElementById('eliminationBracketSection').classList.add('hidden');
            document.getElementById('doubleEliminationBracketSection').classList.add('hidden');
            document.getElementById('roundRobinMatchesSection').classList.add('hidden');
            document.getElementById('multiStageContainer').classList.add('hidden');
            document.getElementById('groupStageSection').classList.add('hidden'); // NEW
            document.getElementById('swissSection').classList.add('hidden');
            document.getElementById('gslSection').classList.add('hidden');
            document.getElementById('ladderSection').classList.add('hidden');

            document.getElementById('generateBracketBtn').classList.add('hidden');
            document.getElementById('generateDoubleEliminationBracketBtn').classList.add('hidden');
            document.getElementById('generateRoundRobinBtn').classList.add('hidden');
            document.getElementById('manageStagesBtn').classList.add('hidden');
            document.getElementById('generateGroupStageBtn').classList.add('hidden'); // NEW
            document.getElementById('generateSwissBtn').classList.add('hidden');
            document.getElementById('generateGSLBtn').classList.add('hidden');
            document.getElementById('manageLadderBtn').classList.add('hidden');


            if (tournament.type === TOURNAMENT_TYPES.SINGLE_ELIMINATION) {
                document.getElementById('eliminationBracketSection').classList.remove('hidden');
                document.getElementById('generateBracketBtn').classList.remove('hidden');
                renderBracket(tournament);
            } else if (tournament.type === TOURNAMENT_TYPES.DOUBLE_ELIMINATION) {
                document.getElementById('doubleEliminationBracketSection').classList.remove('hidden');
                document.getElementById('generateDoubleEliminationBracketBtn').classList.remove('hidden');
                renderDoubleEliminationBracket(tournament);
            } else if (tournament.type === TOURNAMENT_TYPES.ROUND_ROBIN) {
                document.getElementById('roundRobinMatchesSection').classList.remove('hidden');
                document.getElementById('generateRoundRobinBtn').classList.remove('hidden');
                renderRoundRobinMatches(tournament);
                renderRoundRobinStandings(tournament);
            } else if (tournament.type === TOURNAMENT_TYPES.MULTI_STAGE) {
                document.getElementById('multiStageContainer').classList.remove('hidden');
                document.getElementById('manageStagesBtn').classList.remove('hidden');
                renderMultiStages(tournament);
            } else if (tournament.type === TOURNAMENT_TYPES.GROUP_STAGE) { // NEW
                document.getElementById('groupStageSection').classList.remove('hidden');
                document.getElementById('generateGroupStageBtn').classList.remove('hidden');
                renderGroupStage(tournament);
                renderPlayerLeaderboards(tournament);
            } else if (tournament.type === TOURNAMENT_TYPES.SWISS_SYSTEM) {
                document.getElementById('swissSection').classList.remove('hidden');
                document.getElementById('generateSwissBtn').classList.remove('hidden');
                // renderSwissRounds(tournament); // Placeholder
                // renderSwissStandings(tournament); // Placeholder
            } else if (tournament.type === TOURNAMENT_TYPES.GSL_FORMAT) {
                document.getElementById('gslSection').classList.remove('hidden');
                document.getElementById('generateGSLBtn').classList.remove('hidden');
                // renderGSLGroups(tournament); // Placeholder
            } else if (tournament.type === TOURNAMENT_TYPES.LADDER) {
                document.getElementById('ladderSection').classList.remove('hidden');
                document.getElementById('manageLadderBtn').classList.remove('hidden');
                // renderLadder(tournament); // Placeholder
            }

            renderParticipantsList(tournament);
            showSection('tournamentDetailSection');
        }

        function editTournamentDetails() {
            const tournament = tournaments.find(t => t.id === currentTournamentId);
            if (!tournament) return;

            document.getElementById('editTournamentId').value = tournament.id;
            document.getElementById('editTournamentName').value = tournament.name;
            document.getElementById('editTournamentSport').value = tournament.sport;
            document.getElementById('editTournamentType').value = tournament.type; // Disabled, type cannot change
            document.getElementById('editTournamentStartDate').value = tournament.startDate;
            document.getElementById('editTournamentEndDate').value = tournament.endDate;
            document.getElementById('editTournamentMaxParticipants').value = tournament.maxParticipants;
            document.getElementById('editTournamentEntryFee').value = tournament.entryFee;
            document.getElementById('editTournamentPrizePool').value = tournament.prizePool;
            document.getElementById('editTournamentDescription').value = tournament.description;
            document.getElementById('editTournamentSetBasedScoring').checked = tournament.settings.setBasedScoring || false;
            document.getElementById('editTournamentPlayerStatsFields').value = (tournament.settings.playerStatsFields || []).join(', ');

            // Hide all specific settings first
            document.getElementById('editEliminationSettings').classList.add('hidden');
            document.getElementById('editRoundRobinSettings').classList.add('hidden');
            document.getElementById('editGroupStageSettings').classList.add('hidden'); // NEW
            document.getElementById('editSwissSettings').classList.add('hidden');
            document.getElementById('editGslSettings').classList.add('hidden');
            document.getElementById('editLadderSettings').classList.add('hidden');

            if (tournament.type === TOURNAMENT_TYPES.SINGLE_ELIMINATION || tournament.type === TOURNAMENT_TYPES.DOUBLE_ELIMINATION) {
                document.getElementById('editEliminationSettings').classList.remove('hidden');
                document.getElementById('editTournamentBestOf').value = tournament.settings.bestOf || 1;
            } else if (tournament.type === TOURNAMENT_TYPES.ROUND_ROBIN) {
                document.getElementById('editRoundRobinSettings').classList.remove('hidden');
                document.getElementById('editRrEnableHomeAway').checked = tournament.settings.enableHomeAway || false;
                document.getElementById('editRrPointsWin').value = tournament.settings.pointsWin;
                document.getElementById('editRrPointsDraw').value = tournament.settings.pointsDraw;
                document.getElementById('editRrPointsLoss').value = tournament.settings.pointsLoss;
                document.getElementById('editRrTieBreaker').value = tournament.settings.tieBreaker;
            } else if (tournament.type === TOURNAMENT_TYPES.GROUP_STAGE) { // NEW
                document.getElementById('editGroupStageSettings').classList.remove('hidden');
                document.getElementById('editGroupStageGroupsCount').value = tournament.settings.groupStage.groupsCount || 1;
                document.getElementById('editGroupStageAdvanceK').value = tournament.settings.groupStage.advanceK || 1;
                document.getElementById('editGroupStagePointsWin').value = tournament.settings.groupStage.pointsWin || 3;
                document.getElementById('editGroupStagePointsDraw').value = tournament.settings.groupStage.pointsDraw || 1;
                document.getElementById('editGroupStagePointsLoss').value = tournament.settings.groupStage.pointsLoss || 0;
                document.getElementById('editGroupStageTieBreaker').value = tournament.settings.groupStage.tieBreaker || 'Points';
            } else if (tournament.type === TOURNAMENT_TYPES.SWISS_SYSTEM) {
                document.getElementById('editSwissSettings').classList.remove('hidden');
                document.getElementById('editSwissRounds').value = tournament.settings.swissRounds || 5;
            }
            // Show/hide settings for other new types here

            openModal('editTournamentModal');
        }

        function saveEditedTournament(event) {
            event.preventDefault();
            const id = document.getElementById('editTournamentId').value;
            const tournament = tournaments.find(t => t.id === id);
            if (!tournament) return;

            tournament.name = document.getElementById('editTournamentName').value;
            tournament.sport = document.getElementById('editTournamentSport').value;
            tournament.startDate = document.getElementById('editTournamentStartDate').value;
            tournament.endDate = document.getElementById('editTournamentEndDate').value;
            tournament.maxParticipants = parseInt(document.getElementById('editTournamentMaxParticipants').value) || null;
            tournament.entryFee = parseFloat(document.getElementById('editTournamentEntryFee').value) || 0;
            tournament.prizePool = parseFloat(document.getElementById('editTournamentPrizePool').value) || 0;
            tournament.description = document.getElementById('editTournamentDescription').value;
            tournament.settings.setBasedScoring = document.getElementById('editTournamentSetBasedScoring').checked;
            tournament.settings.playerStatsFields = document.getElementById('editTournamentPlayerStatsFields').value.split(',').map(s => s.trim()).filter(s => s);

            if (tournament.type === TOURNAMENT_TYPES.SINGLE_ELIMINATION || tournament.type === TOURNAMENT_TYPES.DOUBLE_ELIMINATION) {
                tournament.settings.bestOf = parseInt(document.getElementById('editTournamentBestOf').value) || 1;
            } else if (tournament.type === TOURNAMENT_TYPES.ROUND_ROBIN) {
                tournament.settings.enableHomeAway = document.getElementById('editRrEnableHomeAway').checked;
                tournament.settings.pointsWin = parseInt(document.getElementById('editRrPointsWin').value) || 3;
                tournament.settings.pointsDraw = parseInt(document.getElementById('editRrPointsDraw').value) || 1;
                tournament.settings.pointsLoss = parseInt(document.getElementById('editRrPointsLoss').value) || 0;
                tournament.settings.tieBreaker = document.getElementById('editRrTieBreaker').value || 'Points';
            } else if (tournament.type === TOURNAMENT_TYPES.GROUP_STAGE) { // NEW
                tournament.settings.groupStage.groupsCount = parseInt(document.getElementById('editGroupStageGroupsCount').value) || 1;
                tournament.settings.groupStage.advanceK = parseInt(document.getElementById('editGroupStageAdvanceK').value) || 1;
                tournament.settings.groupStage.pointsWin = parseInt(document.getElementById('editGroupStagePointsWin').value) || 3;
                tournament.settings.groupStage.pointsDraw = parseInt(document.getElementById('editGroupStagePointsDraw').value) || 1;
                tournament.settings.groupStage.pointsLoss = parseInt(document.getElementById('editGroupStagePointsLoss').value) || 0;
                tournament.settings.groupStage.tieBreaker = document.getElementById('editGroupStageTieBreaker').value || 'Points';
            } else if (tournament.type === TOURNAMENT_TYPES.SWISS_SYSTEM) {
                tournament.settings.swissRounds = parseInt(document.getElementById('editSwissRounds').value) || 5;
            }
            // Save settings for other new types here

            saveData();
            showAlert('Tournament updated successfully!');
            closeModal('editTournamentModal');
            viewTournamentDetails(id); // Re-render details
        }

        function deleteTournament() {
            if (!confirm('Are you sure you want to delete this tournament and all its data?')) {
                return;
            }
            tournaments = tournaments.filter(t => t.id !== currentTournamentId);
            saveData();
            showAlert('Tournament deleted successfully!', 'danger');
            showSection('dashboardSection');
        }

        function changeTournamentStatus(event) {
            const newStatus = event.target.value;
            const tournament = tournaments.find(t => t.id === currentTournamentId);
            if (tournament) {
                tournament.status = newStatus;
                saveData();
                showAlert(`Tournament status changed to ${newStatus}.`);
                viewTournamentDetails(currentTournamentId); // Re-render details
            }
        }

        // --- Participant Management ---
        function renderParticipantsList(tournament) {
            const listDiv = document.getElementById('participantsList');
            listDiv.innerHTML = '';
            document.getElementById('participantCount').textContent = tournament.participants.length;
            document.getElementById('maxParticipants').textContent = tournament.maxParticipants || '∞';

            if (tournament.participants.length === 0) {
                listDiv.innerHTML = '<p class="no-data">No participants added yet.</p>';
                return;
            }

            tournament.participants.sort((a, b) => (a.seed || Infinity) - (b.seed || Infinity)); // Sort by seed

            tournament.participants.forEach(p => {
                const item = document.createElement('div');
                item.className = 'participant-item';
                item.innerHTML = `
                    <div>
                        <strong>${p.name}</strong>
                        ${p.seed ? ` (Seed: ${p.seed})` : ''}
                        ${p.rating ? ` (Rating: ${p.rating})` : ''}
                        ${p.contact ? `<br><small>${p.contact}</small>` : ''}
                    </div>
                    <div class="actions">
                        <button class="btn btn-secondary" onclick="editParticipant('${p.id}')">Edit</button>
                        <button class="btn btn-danger" onclick="deleteParticipant('${p.id}')">Delete</button>
                    </div>
                `;
                listDiv.appendChild(item);
            });
        }

        function openAddParticipantModal() {
            document.getElementById('participantModalTitle').textContent = 'Add Participant';
            document.getElementById('participantForm').reset();
            document.getElementById('participantId').value = '';
            openModal('participantModal');
        }

        function addOrUpdateParticipant(event) {
            event.preventDefault();
            const tournament = tournaments.find(t => t.id === currentTournamentId);
            if (!tournament) return;

            const participantId = document.getElementById('participantId').value;
            const name = document.getElementById('participantName').value;
            const seed = parseInt(document.getElementById('participantSeed').value) || null;
            const rating = parseFloat(document.getElementById('participantRating').value) || null;
            const contact = document.getElementById('participantContact').value;
            const notes = document.getElementById('participantNotes').value;

            if (!name) {
                showAlert('Participant name is required.', 'error');
                return;
            }

            if (tournament.maxParticipants && tournament.participants.length >= tournament.maxParticipants && !participantId) {
                showAlert(`Cannot add more participants. Max is ${tournament.maxParticipants}.`, 'error');
                return;
            }

            if (participantId) {
                // Update existing participant
                const participant = tournament.participants.find(p => p.id === participantId);
                if (participant) {
                    participant.name = name;
                    participant.seed = seed;
                    participant.rating = rating;
                    participant.contact = contact;
                    participant.notes = notes;
                    showAlert('Participant updated successfully!');
                }
            } else {
                // Add new participant
                const newParticipant = {
                    id: generateUniqueId(),
                    name, seed, rating, contact, notes,
                    // Stats for Round Robin / Swiss / Group Stage
                    wins: 0, losses: 0, draws: 0, scoreFor: 0, scoreAgainst: 0, points: 0,
                    // NEW: Aggregated player stats
                    stats: { matchesPlayed: 0, goals: 0, assists: 0, saves: 0, cardsYellow: 0, cardsRed: 0, minutesPlayed: 0, kills: 0, deaths: 0, damage: 0, custom: {} }
                };
                tournament.participants.push(newParticipant);
                showAlert('Participant added successfully!');
            }

            saveData();
            renderParticipantsList(tournament);
            closeModal('participantModal');
        }

        function deleteParticipant(participantId) {
            if (!confirm('Are you sure you want to delete this participant? This will also reset any generated brackets/matches in all stages.')) {
                return;
            }
            const tournament = tournaments.find(t => t.id === currentTournamentId);
            if (tournament) {
                tournament.participants = tournament.participants.filter(p => p.id !== participantId);
                // Reset all brackets/matches if participants change
                tournament.rounds = [];
                tournament.winnerBracket = [];
                tournament.loserBracket = [];
                tournament.grandFinal = [];
                tournament.matches = [];
                tournament.swissRounds = [];
                tournament.gslGroups = [];
                tournament.ladderRanks = [];
                tournament.groups = []; // NEW
                tournament.stages.forEach(stage => {
                    stage.participants = stage.participants.filter(pId => pId !== participantId);
                    stage.matches = [];
                    stage.rounds = [];
                });
                saveData();
                showAlert('Participant deleted successfully!', 'danger');
                viewTournamentDetails(currentTournamentId); // Re-render details
            }
        }

        function openBulkImportModal() {
            document.getElementById('bulkImportFileInput').value = '';
            openModal('bulkImportModal');
        }

        function processBulkImport() {
            const fileInput = document.getElementById('bulkImportFileInput');
            const file = fileInput.files[0];
            if (!file) {
                showAlert('Please select a CSV file.', 'error');
                return;
            }

            const reader = new FileReader();
            reader.onload = (e) => {
                const csv = e.target.result;
                const names = csv.split('\n').map(line => line.trim()).filter(line => line);
                const tournament = tournaments.find(t => t.id === currentTournamentId);

                if (!tournament) {
                    showAlert('Tournament not found.', 'error');
                    return;
                }

                let addedCount = 0;
                names.forEach(name => {
                    if (tournament.maxParticipants && tournament.participants.length >= tournament.maxParticipants) {
                        showAlert(`Max participants reached. Stopped importing at "${name}".`, 'error');
                        return;
                    }
                    tournament.participants.push({
                        id: generateUniqueId(),
                        name, seed: null, rating: null, contact: '', notes: '',
                        wins: 0, losses: 0, draws: 0, scoreFor: 0, scoreAgainst: 0, points: 0,
                        stats: { matchesPlayed: 0, goals: 0, assists: 0, saves: 0, cardsYellow: 0, cardsRed: 0, minutesPlayed: 0, kills: 0, deaths: 0, damage: 0, custom: {} }
                    });
                    addedCount++;
                });

                saveData();
                showAlert(`${addedCount} participants imported successfully!`);
                renderParticipantsList(tournament);
                closeModal('bulkImportModal');
            };
            reader.readAsText(file);
        }

        function openCopyParticipantsModal() {
            const select = document.getElementById('copyFromTournamentSelect');
            select.innerHTML = '<option value="">-- Select a Tournament --</option>';
            tournaments.forEach(t => {
                if (t.id !== currentTournamentId) {
                    const option = document.createElement('option');
                    option.value = t.id;
                    option.textContent = t.name;
                    select.appendChild(option);
                }
            });
            openModal('copyParticipantsModal');
        }

        function processCopyParticipants() {
            const fromTournamentId = document.getElementById('copyFromTournamentSelect').value;
            if (!fromTournamentId) {
                showAlert('Please select a tournament to copy participants from.', 'error');
                return;
            }

            const sourceTournament = tournaments.find(t => t.id === fromTournamentId);
            const targetTournament = tournaments.find(t => t.id === currentTournamentId);

            if (!sourceTournament || !targetTournament) {
                showAlert('Source or target tournament not found.', 'error');
                return;
            }

            let copiedCount = 0;
            sourceTournament.participants.forEach(p => {
                if (targetTournament.maxParticipants && targetTournament.participants.length >= targetTournament.maxParticipants) {
                    showAlert(`Max participants reached in target tournament. Stopped copying.`, 'error');
                    return;
                }
                // Only copy if participant name doesn't already exist to avoid duplicates
                if (!targetTournament.participants.some(tp => tp.name === p.name)) {
                    targetTournament.participants.push({
                        id: generateUniqueId(), // New ID for the copied participant
                        name: p.name,
                        seed: p.seed,
                        rating: p.rating,
                        contact: p.contact,
                        notes: p.notes,
                        wins: 0, losses: 0, draws: 0, scoreFor: 0, scoreAgainst: 0, points: 0,
                        stats: { matchesPlayed: 0, goals: 0, assists: 0, saves: 0, cardsYellow: 0, cardsRed: 0, minutesPlayed: 0, kills: 0, deaths: 0, damage: 0, custom: {} }
                    });
                    copiedCount++;
                }
            });

            saveData();
            showAlert(`${copiedCount} participants copied successfully!`);
            renderParticipantsList(targetTournament);
            closeModal('copyParticipantsModal');
        }

        // --- Elimination Bracket Logic (Common for SE & DE) ---
        function generateEliminationBracket(tournament, bracketType, stageId = null) {
            let participantsInStage;
            let targetBracket;
            let bestOf = tournament.settings.bestOf || 1;
            let confirmMessage;

            if (stageId) {
                const stage = tournament.stages.find(s => s.id === stageId);
                if (!stage) return;
                participantsInStage = tournament.participants.filter(p => stage.participants.includes(p.id));
                targetBracket = stage.rounds;
                bestOf = stage.settings.bestOf || tournament.settings.bestOf || 1;
                confirmMessage = `Bracket for stage "${stage.name}" already generated. Regenerating will clear all scores. Continue?`;
            } else {
                participantsInStage = tournament.participants;
                targetBracket = tournament.rounds;
                if (bracketType === TOURNAMENT_TYPES.DOUBLE_ELIMINATION) {
                    targetBracket = tournament.winnerBracket;
                }
                confirmMessage = 'Bracket already generated. Regenerating will clear all scores. Continue?';
            }

            if (participantsInStage.length < 2) {
                showAlert('Need at least 2 participants to generate a bracket.', 'error');
                return;
            }

            if (targetBracket.length > 0 && !confirm(confirmMessage)) {
                return;
            }

            // Clear existing brackets
            if (stageId) {
                const stage = tournament.stages.find(s => s.id === stageId);
                stage.rounds = [];
            } else {
                tournament.rounds = [];
                tournament.winnerBracket = [];
                tournament.loserBracket = [];
                tournament.grandFinal = [];
            }

            // Sort participants by seed, then randomly for unseeded
            let sortedParticipants = [...participantsInStage].sort((a, b) => {
                if (a.seed && b.seed) return a.seed - b.seed;
                if (a.seed) return -1; // Seeded players first
                if (b.seed) return 1;
                return Math.random() - 0.5; // Random for unseeded
            });

            const numParticipants = sortedParticipants.length;
            let numRounds = Math.ceil(Math.log2(numParticipants));
            let totalSlots = Math.pow(2, numRounds);
            let byes = totalSlots - numParticipants;

            let initialBracketParticipants = [];
            // Place seeds into a standard bracket order (1 vs N, 2 vs N-1, etc.)
            // This is a simplified version for power-of-2 brackets.
            // For non-power-of-2, byes are assigned to highest seeds.
            let tempParticipants = [...sortedParticipants];
            let byeParticipants = [];
            for(let i=0; i<byes; i++) {
                byeParticipants.push(tempParticipants.shift()); // Highest seeds get byes
            }

            // Standard bracket seeding for remaining participants
            let seededOrder = [];
            let remaining = tempParticipants.length;
            let topHalf = tempParticipants.slice(0, Math.ceil(remaining / 2));
            let bottomHalf = tempParticipants.slice(Math.ceil(remaining / 2));
            bottomHalf.reverse(); // Reverse bottom half for pairing

            for (let i = 0; i < Math.max(topHalf.length, bottomHalf.length); i++) {
                if (topHalf[i]) seededOrder.push(topHalf[i]);
                if (bottomHalf[i]) seededOrder.push(bottomHalf[i]);
            }

            // Insert byes into the seeded order (e.g., 1st bye at slot 1, 2nd bye at slot 2, etc.)
            // This is a very basic insertion. A more complex system would place byes strategically.
            let finalParticipantsForPairing = [];
            let byeIndex = 0;
            for(let i=0; i<totalSlots; i++) {
                if (i < byes) { // Assign byes to the first 'byes' slots
                    finalParticipantsForPairing.push({ participant: byeParticipants[byeIndex++], bye: true });
                } else {
                    finalParticipantsForPairing.push({ participant: seededOrder.shift(), bye: false });
                }
            }
            // Shuffle non-bye participants to mix them up, keeping byes at the start
            const nonByeParticipants = finalParticipantsForPairing.filter(p => !p.bye).sort(() => Math.random() - 0.5);
            finalParticipantsForPairing = finalParticipantsForPairing.filter(p => p.bye).concat(nonByeParticipants);


            // Create initial matches for Round 1
            let round1Matches = [];
            for (let i = 0; i < finalParticipantsForPairing.length; i += 2) {
                const p1Entry = finalParticipantsForPairing[i];
                const p2Entry = finalParticipantsForPairing[i + 1];

                const p1 = p1Entry?.participant;
                const p2 = p2Entry?.participant;

                if (p1Entry?.bye && p2Entry?.bye) {
                    // This case should ideally not happen with proper bye distribution
                    // but as a fallback, treat as a match between two byes, one advances
                    round1Matches.push(createMatchObject(p1.id, null, tournament.settings.playerStatsFields, p1.id, 'Completed - Bye', bestOf));
                } else if (p1Entry?.bye) { // P1 has a bye, P2 advances
                    round1Matches.push(createMatchObject(p2.id, null, tournament.settings.playerStatsFields, p2.id, 'Completed - Bye', bestOf));
                } else if (p2Entry?.bye) { // P2 has a bye, P1 advances
                    round1Matches.push(createMatchObject(p1.id, null, tournament.settings.playerStatsFields, p1.id, 'Completed - Bye', bestOf));
                } else if (p1 && p2) {
                    round1Matches.push(createMatchObject(p1.id, p2.id, tournament.settings.playerStatsFields, null, 'Upcoming', bestOf));
                } else if (p1) { // Odd number of participants, last one gets a bye (should be handled by initial bye assignment)
                    round1Matches.push(createMatchObject(p1.id, null, tournament.settings.playerStatsFields, p1.id, 'Completed - Bye', bestOf));
                }
            }

            if (bracketType === TOURNAMENT_TYPES.SINGLE_ELIMINATION) {
                if (stageId) {
                    const stage = tournament.stages.find(s => s.id === stageId);
                    stage.rounds.push({ name: 'Round 1', matches: round1Matches });
                    for (let r = 1; r < numRounds; r++) {
                        let nextRoundMatches = [];
                        const numMatchesInRound = Math.ceil(round1Matches.length / Math.pow(2, r));
                        for (let i = 0; i < numMatchesInRound; i++) {
                            nextRoundMatches.push(createMatchObject(null, null, tournament.settings.playerStatsFields, null, 'Upcoming', bestOf));
                        }
                        if (nextRoundMatches.length > 0) {
                            stage.rounds.push({ name: `Round ${r + 1}`, matches: nextRoundMatches });
                        }
                    }
                } else {
                    tournament.rounds.push({ name: 'Round 1', matches: round1Matches });
                    for (let r = 1; r < numRounds; r++) {
                        let nextRoundMatches = [];
                        const numMatchesInRound = Math.ceil(round1Matches.length / Math.pow(2, r));
                        for (let i = 0; i < numMatchesInRound; i++) {
                            nextRoundMatches.push(createMatchObject(null, null, tournament.settings.playerStatsFields, null, 'Upcoming', bestOf));
                        }
                        if (nextRoundMatches.length > 0) {
                            tournament.rounds.push({ name: `Round ${r + 1}`, matches: nextRoundMatches });
                        }
                    }
                }
            } else if (bracketType === TOURNAMENT_TYPES.DOUBLE_ELIMINATION) {
                // Initialize Winner's Bracket
                tournament.winnerBracket.push({ name: 'Winner\'s Round 1', matches: round1Matches });
                for (let r = 1; r < numRounds; r++) {
                    let nextRoundMatches = [];
                    const numMatchesInRound = Math.ceil(round1Matches.length / Math.pow(2, r));
                    for (let i = 0; i < numMatchesInRound; i++) {
                        nextRoundMatches.push(createMatchObject(null, null, tournament.settings.playerStatsFields, null, 'Upcoming', bestOf));
                    }
                    if (nextRoundMatches.length > 0) {
                        tournament.winnerBracket.push({ name: `Winner\'s Round ${r + 1}`, matches: nextRoundMatches });
                    }
                }

                // Initialize Loser's Bracket (simplified structure)
                // Loser's bracket rounds are more complex, often having more matches and rounds.
                // This is a basic placeholder.
                const numLoserBracketRounds = numRounds * 2 - 2; // A common pattern
                for (let r = 0; r < numLoserBracketRounds; r++) {
                    tournament.loserBracket.push({ name: `Loser\'s Round ${r + 1}`, matches: [] });
                }

                // Grand Final
                tournament.grandFinal.push({ name: 'Grand Final', matches: [createMatchObject(null, null, tournament.settings.playerStatsFields, null, 'Upcoming', bestOf)] });
            }

            saveData();
            showAlert('Bracket generated successfully!');
            if (stageId) {
                renderMultiStages(tournament);
            } else if (bracketType === TOURNAMENT_TYPES.SINGLE_ELIMINATION) {
                renderBracket(tournament);
            } else {
                renderDoubleEliminationBracket(tournament);
            }
        }

        function createMatchObject(player1Id, player2Id, playerStatsFields, winnerId = null, status = 'Upcoming', bestOf = 1, homePlayerId = null, awayPlayerId = null) {
            const match = {
                id: generateUniqueId(),
                player1Id,
                player2Id,
                homePlayerId: homePlayerId || player1Id, // Default player1 is home
                awayPlayerId: awayPlayerId || player2Id, // Default player2 is away
                score1: null,
                score2: null,
                sets: null, // For set-based scoring
                winnerId,
                status,
                bestOf, // New: Best-of-N series
                date: null,
                time: null,
                venue: null,
                referee: null,
                player1Stats: {},
                player2Stats: {}
            };
            playerStatsFields.forEach(field => {
                match.player1Stats[field] = null;
                match.player2Stats[field] = null;
            });
            return match;
        }

        function renderBracket(tournament, targetElementId = 'bracketVisualizer', roundsArray = tournament.rounds, stageId = null) {
            const bracketVisualizer = document.getElementById(targetElementId);
            bracketVisualizer.innerHTML = '';

            if (roundsArray.length === 0) {
                bracketVisualizer.innerHTML = '<p class="no-data">Bracket not generated. Add participants and click "Generate Bracket".</p>';
                return;
            }

            roundsArray.forEach((round, roundIndex) => {
                const roundDiv = document.createElement('div');
                roundDiv.className = 'bracket-round-simple';
                roundDiv.innerHTML = `<h4>${round.name}</h4>`;

                round.matches.forEach(match => {
                    roundDiv.appendChild(createMatchElementHTML(match, tournament, roundIndex, 'rounds', stageId));
                });
                bracketVisualizer.appendChild(roundDiv);
            });

            // Check for overall winner
            const lastRound = roundsArray[roundsArray.length - 1];
            if (lastRound && lastRound.matches.length === 1 && lastRound.matches[0].winnerId) {
                const winner = tournament.participants.find(p => p.id === lastRound.matches[0].winnerId);
                bracketVisualizer.insertAdjacentHTML('beforeend', `<h3 class="text-center" style="margin-top: 30px; color: var(--accent-color);">🏆 Tournament Winner: ${winner.name} 🏆</h3>`);
            }
        }

        function renderDoubleEliminationBracket(tournament) {
            const deWrapper = document.getElementById('doubleEliminationWrapper');
            deWrapper.innerHTML = '';

            if (tournament.winnerBracket.length === 0) {
                deWrapper.innerHTML = '<p class="no-data">Double Elimination Bracket not generated. Add participants and click "Generate DE Bracket".</p>';
                return;
            }

            // Render Winner's Bracket
            const wbDiv = document.createElement('div');
            wbDiv.innerHTML = '<h3>Winner\'s Bracket</h3>';
            const wbVisualizer = document.createElement('div');
            wbVisualizer.className = 'bracket-visualizer';
            tournament.winnerBracket.forEach((round, roundIndex) => {
                const roundDiv = document.createElement('div');
                roundDiv.className = 'bracket-round-simple';
                roundDiv.innerHTML = `<h4>${round.name}</h4>`;
                round.matches.forEach(match => {
                    roundDiv.appendChild(createMatchElementHTML(match, tournament, roundIndex, 'winnerBracket'));
                });
                wbVisualizer.appendChild(roundDiv);
            });
            wbDiv.appendChild(wbVisualizer);
            deWrapper.appendChild(wbDiv);

            // Render Loser's Bracket
            const lbDiv = document.createElement('div');
            lbDiv.innerHTML = '<h3>Loser\'s Bracket</h3>';
            const lbVisualizer = document.createElement('div');
            lbVisualizer.className = 'bracket-visualizer';
            tournament.loserBracket.forEach((round, roundIndex) => {
                const roundDiv = document.createElement('div');
                roundDiv.className = 'bracket-round-simple';
                roundDiv.innerHTML = `<h4>${round.name}</h4>`;
                round.matches.forEach(match => {
                    roundDiv.appendChild(createMatchElementHTML(match, tournament, roundIndex, 'loserBracket'));
                });
                lbVisualizer.appendChild(roundDiv);
            });
            lbDiv.appendChild(lbVisualizer);
            deWrapper.appendChild(lbDiv);

            // Render Grand Final
            const gfDiv = document.createElement('div');
            gfDiv.innerHTML = '<h3>Grand Final</h3>';
            const gfVisualizer = document.createElement('div');
            gfVisualizer.className = 'bracket-visualizer';
            tournament.grandFinal.forEach((round, roundIndex) => { // Grand Final is typically one round
                const roundDiv = document.createElement('div');
                roundDiv.className = 'bracket-round-simple';
                round.matches.forEach(match => {
                    roundDiv.appendChild(createMatchElementHTML(match, tournament, roundIndex, 'grandFinal'));
                });
                gfVisualizer.appendChild(roundDiv);
            });
            gfDiv.appendChild(gfVisualizer);
            deWrapper.appendChild(gfDiv);

            // Check for overall winner
            const grandFinalMatch = tournament.grandFinal[0]?.matches[0];
            if (grandFinalMatch && grandFinalMatch.winnerId) {
                const winner = tournament.participants.find(p => p.id === grandFinalMatch.winnerId);
                deWrapper.insertAdjacentHTML('beforeend', `<h3 class="text-center" style="margin-top: 30px; color: var(--accent-color);">🏆 Tournament Winner: ${winner.name} 🏆</h3>`);
            }
        }

        function createMatchElementHTML(match, tournament, roundIndex, bracketType, stageId = null, groupId = null) { // Added groupId
            const p1 = tournament.participants.find(p => p.id === match.player1Id);
            const p2 = tournament.participants.find(p => p.id === match.player2Id);

            const scoreInputHtml1 = p1 ? (tournament.settings.setBasedScoring ?
                `<input type="text" class="sets-input" value="${match.sets !== null ? match.sets.split('-')[0] : ''}" data-player="1" ${match.status !== 'Upcoming' ? 'disabled' : ''}>` :
                `<input type="number" class="score-input" value="${match.score1 !== null ? match.score1 : ''}" data-player="1" ${match.status !== 'Upcoming' ? 'disabled' : ''}>`) : '';
            const scoreInputHtml2 = p2 ? (tournament.settings.setBasedScoring ?
                `<input type="text" class="sets-input" value="${match.sets !== null ? match.sets.split('-')[1] : ''}" data-player="2" ${match.status !== 'Upcoming' ? 'disabled' : ''}>` :
                `<input type="number" class="score-input" value="${match.score2 !== null ? match.score2 : ''}" data-player="2" ${match.status !== 'Upcoming' ? 'disabled' : ''}>`) : '';

            const matchDiv = document.createElement('div');
            matchDiv.className = `bracket-match-simple ${match.winnerId ? 'winner' : ''}`;
            matchDiv.innerHTML = `
                <div class="player-line ${match.winnerId === p1?.id ? 'winner-player' : ''}">
                    <span>${p1 ? p1.name : 'TBD'}</span>
                    ${scoreInputHtml1}
                </div>
                <div class="player-line ${match.winnerId === p2?.id ? 'winner-player' : ''}">
                    <span>${p2 ? p2.name : 'TBD'}</span>
                    ${scoreInputHtml2}
                </div>
                <div class="match-actions">
                    <button class="btn btn-outline" onclick="openMatchDetailsModal('${match.id}', ${roundIndex}, '${bracketType}', '${stageId || ''}', '${groupId || ''}')">Details</button>
                    ${match.status === 'Upcoming' && p1 && p2 ? `<button class="btn btn-primary" onclick="recordScore('${match.id}', ${roundIndex}, '${bracketType}', '${stageId || ''}', '${groupId || ''}')">Record Score</button>` : ''}
                    ${match.status === 'Completed' ? `<span style="color: var(--primary-color); font-weight: bold;">Winner: ${tournament.participants.find(p => p.id === match.winnerId)?.name || 'N/A'}</span>` : ''}
                    ${match.status === 'Completed - Bye' ? `<span style="color: var(--secondary-color); font-weight: bold;">BYE - ${p1?.name || 'N/A'} Advances</span>` : ''}
                </div>
            `;
            return matchDiv;
        }

        // Consolidated record score function for all types
        function recordScore(matchId, roundIndex, bracketType, stageId = null, groupId = null) {
            const tournament = tournaments.find(t => t.id === currentTournamentId);
            if (!tournament) return;

            let matchesArray, bracket, rrSettings, bestOf;
            let participantsForMatch = tournament.participants; // Default to all tournament participants

            if (stageId) {
                const stage = tournament.stages.find(s => s.id === stageId);
                if (!stage) return;
                participantsForMatch = tournament.participants.filter(p => stage.participants.includes(p.id));
                bestOf = stage.settings.bestOf || tournament.settings.bestOf || 1;
                if (bracketType === 'matches') { // RR stage
                    matchesArray = stage.matches;
                    rrSettings = stage.settings;
                } else { // SE stage
                    bracket = stage.rounds;
                }
            } else if (groupId) { // NEW: Group Stage
                const group = tournament.groups.find(g => g.id === groupId);
                if (!group) return;
                matchesArray = group.matches;
                participantsForMatch = tournament.participants.filter(p => group.participants.includes(p.id));
                rrSettings = tournament.settings.groupStage; // Use group stage specific settings
                bestOf = 1; // Group stage matches are typically best of 1
            } else { // Main tournament (SE, DE, RR)
                bestOf = tournament.settings.bestOf || 1;
                if (bracketType === 'matches') { // RR tournament
                    matchesArray = tournament.matches;
                    rrSettings = tournament.settings;
                } else { // SE/DE tournament
                    bracket = tournament[bracketType];
                }
            }

            let match;
            if (bracketType === 'matches' || bracketType === 'groupMatches') { // RR or Group Stage matches
                match = matchesArray.find(m => m.id === matchId);
            } else { // Elimination brackets
                match = bracket[roundIndex].matches.find(m => m.id === matchId);
            }

            if (!match) return;

            const matchElement = document.querySelector(`[onclick*="recordScore('${matchId}'"]`).closest('.bracket-match-simple, tr');
            let score1, score2;

            if (tournament.settings.setBasedScoring) {
                const setsInput1 = matchElement.querySelector('input[data-player="1"]');
                const setsInput2 = matchElement.querySelector('input[data-player="2"]');
                const sets1 = parseInt(setsInput1.value);
                const sets2 = parseInt(setsInput2.value);

                if (isNaN(sets1) || isNaN(sets2)) {
                    showAlert('Please enter valid set scores for both players.', 'error');
                    return;
                }
                match.sets = `${sets1}-${sets2}`;
                score1 = sets1; // Use sets for winner determination
                score2 = sets2;
            } else {
                const scoreInput1 = matchElement.querySelector('input[data-player="1"]');
                const scoreInput2 = matchElement.querySelector('input[data-player="2"]');
                score1 = parseInt(scoreInput1.value);
                score2 = parseInt(scoreInput2.value);

                if (isNaN(score1) || isNaN(score2)) {
                    showAlert('Please enter valid scores for both players.', 'error');
                    return;
                }
                match.score1 = score1;
                match.score2 = score2;
            }

            let loserId = null;
            if (score1 > score2) {
                match.winnerId = match.player1Id;
                loserId = match.player2Id;
            } else if (score2 > score1) {
                match.winnerId = match.player2Id;
                loserId = match.player1Id;
            } else {
                if (bracketType === 'rounds' || bracketType === 'winnerBracket' || bracketType === 'loserBracket' || bracketType === 'grandFinal') {
                    showAlert('Scores cannot be tied in elimination brackets. Please enter a clear winner.', 'error');
                    return;
                }
                match.winnerId = null; // Draw for RR/Group Stage
            }
            match.status = 'Completed';

            // NEW: Update aggregated player stats
            updateAggregatedPlayerStats(tournament, match, participantsForMatch);

            // Logic for advancing winners/losers (only for elimination brackets)
            if (bracketType === 'rounds') { // Single Elimination
                if (roundIndex < bracket.length - 1) {
                    advanceWinner(bracket[roundIndex + 1].matches, match.winnerId);
                }
            } else if (bracketType === 'winnerBracket') { // Double Elimination - Winner's Bracket
                if (roundIndex < tournament.winnerBracket.length - 1) {
                    advanceWinner(tournament.winnerBracket[roundIndex + 1].matches, match.winnerId);
                } else { // Winner of WB goes to Grand Final
                    const grandFinalMatch = tournament.grandFinal[0]?.matches[0];
                    if (grandFinalMatch) {
                        grandFinalMatch.player1Id = match.winnerId; // WB winner is P1 in GF
                    }
                }
                if (loserId) {
                    const lbRoundIndex = roundIndex;
                    if (tournament.loserBracket[lbRoundIndex]) {
                        let foundSlot = false;
                        for (const lbMatch of tournament.loserBracket[lbRoundIndex].matches) {
                            if (!lbMatch.player1Id) { lbMatch.player1Id = loserId; foundSlot = true; break; }
                            if (!lbMatch.player2Id) { lbMatch.player2Id = loserId; foundSlot = true; break; }
                        }
                        if (!foundSlot) {
                            tournament.loserBracket[lbRoundIndex].matches.push(createMatchObject(loserId, null, tournament.settings.playerStatsFields, null, 'Upcoming', bestOf));
                        }
                    } else {
                        tournament.loserBracket.push({ name: `Loser's Round ${tournament.loserBracket.length + 1}`, matches: [createMatchObject(loserId, null, tournament.settings.playerStatsFields, null, 'Upcoming', bestOf)] });
                    }
                }
            } else if (bracketType === 'loserBracket') { // Double Elimination - Loser's Bracket
                if (roundIndex < tournament.loserBracket.length - 1) {
                    advanceWinner(tournament.loserBracket[roundIndex + 1].matches, match.winnerId);
                } else { // Winner of LB goes to Grand Final
                    const grandFinalMatch = tournament.grandFinal[0]?.matches[0];
                    if (grandFinalMatch) {
                        grandFinalMatch.player2Id = match.winnerId; // LB winner is P2 in GF
                    }
                }
            } else if (bracketType === 'grandFinal') {
                // Grand Final winner is tournament winner
            }

            saveData();
            showAlert(`Score recorded for match. ${participantsForMatch.find(p => p.id === match.winnerId)?.name || 'Draw'}!`);

            // Re-render relevant sections
            if (stageId) {
                renderMultiStages(tournament);
            } else if (groupId) { // NEW: Group Stage
                renderGroupStage(tournament);
                renderPlayerLeaderboards(tournament);
            } else if (bracketType === 'rounds') {
                renderBracket(tournament);
            } else if (bracketType === 'winnerBracket' || bracketType === 'loserBracket' || bracketType === 'grandFinal') {
                renderDoubleEliminationBracket(tournament);
            } else if (bracketType === 'matches') { // For Round Robin
                renderRoundRobinMatches(tournament);
                renderRoundRobinStandings(tournament);
            }
        }

        function advanceWinner(nextRoundMatches, winnerId) {
            let foundSlot = false;
            for (const nextMatch of nextRoundMatches) {
                if (!nextMatch.player1Id) {
                    nextMatch.player1Id = winnerId;
                    foundSlot = true;
                    break;
                } else if (!nextMatch.player2Id) {
                    nextMatch.player2Id = winnerId;
                    foundSlot = true;
                    break;
                }
            }
            // If no empty slot found, it means the bracket logic needs to be more robust
            // For now, we assume slots are available or created.
            // A more advanced system would pre-create empty matches for future rounds.
        }

        // --- Match Details Modal ---
        function openMatchDetailsModal(matchId, roundIndex, bracketType, stageId = null, groupId = null) { // Added groupId
            const tournament = tournaments.find(t => t.id === currentTournamentId);
            if (!tournament) return;

            let match;
            let participantsForMatch;

            if (stageId) {
                const stage = tournament.stages.find(s => s.id === stageId);
                if (bracketType === 'matches') { // RR stage
                    match = stage.matches.find(m => m.id === matchId);
                } else { // SE stage
                    match = stage.rounds[roundIndex].matches.find(m => m.id === matchId);
                }
                participantsForMatch = tournament.participants.filter(p => stage.participants.includes(p.id));
            } else if (groupId) { // NEW: Group Stage
                const group = tournament.groups.find(g => g.id === groupId);
                if (!group) return;
                match = group.matches.find(m => m.id === matchId);
                participantsForMatch = tournament.participants.filter(p => group.participants.includes(p.id));
            } else {
                if (bracketType === 'matches') { // RR tournament
                    match = tournament.matches.find(m => m.id === matchId);
                } else { // SE/DE tournament
                    match = tournament[bracketType][roundIndex].matches.find(m => m.id === matchId);
                }
                participantsForMatch = tournament.participants;
            }

            if (!match) return;

            document.getElementById('matchDetailsModalTitle').textContent = `Match: ${participantsForMatch.find(p => p.id === match.player1Id)?.name || 'TBD'} vs ${participantsForMatch.find(p => p.id === match.player2Id)?.name || 'TBD'}`;
            document.getElementById('matchDetailsMatchId').value = match.id;
            document.getElementById('matchDetailsRoundIndex').value = roundIndex;
            document.getElementById('matchDetailsBracketType').value = bracketType;
            document.getElementById('matchDetailsStageId').value = stageId;
            document.getElementById('matchDetailsGroupId').value = groupId; // NEW

            document.getElementById('matchDetailsPlayer1').value = participantsForMatch.find(p => p.id === match.player1Id)?.name || 'BYE';
            document.getElementById('matchDetailsPlayer2').value = participantsForMatch.find(p => p.id === match.player2Id)?.name || 'BYE';
            document.getElementById('matchDetailsBestOf').value = match.bestOf || 1;
            document.getElementById('matchDetailsDate').value = match.date || '';
            document.getElementById('matchDetailsTime').value = match.time || '';
            document.getElementById('matchDetailsVenue').value = match.venue || '';
            document.getElementById('matchDetailsReferee').value = match.referee || '';

            // Render player stats inputs
            const player1StatsInputsDiv = document.getElementById('player1StatsInputs');
            const player2StatsInputsDiv = document.getElementById('player2StatsInputs');
            player1StatsInputsDiv.innerHTML = `<h4>${participantsForMatch.find(p => p.id === match.player1Id)?.name || 'Player 1'} Stats</h4>`;
            player2StatsInputsDiv.innerHTML = `<h4>${participantsForMatch.find(p => p.id === match.player2Id)?.name || 'Player 2'} Stats</h4>`;

            tournament.settings.playerStatsFields.forEach(field => {
                player1StatsInputsDiv.innerHTML += `
                    <div class="form-group">
                        <label for="p1_stat_${field}">${field}</label>
                        <input type="number" id="p1_stat_${field}" value="${match.player1Stats[field] !== null ? match.player1Stats[field] : ''}" data-player="1" data-stat="${field}">
                    </div>
                `;
                player2StatsInputsDiv.innerHTML += `
                    <div class="form-group">
                        <label for="p2_stat_${field}">${field}</label>
                        <input type="number" id="p2_stat_${field}" value="${match.player2Stats[field] !== null ? match.player2Stats[field] : ''}" data-player="2" data-stat="${field}">
                    </div>
                `;
            });

            openModal('matchDetailsModal');
        }

        function saveMatchDetails(event) {
            event.preventDefault();
            const tournament = tournaments.find(t => t.id === currentTournamentId);
            if (!tournament) return;

            const matchId = document.getElementById('matchDetailsMatchId').value;
            const roundIndex = parseInt(document.getElementById('matchDetailsRoundIndex').value);
            const bracketType = document.getElementById('matchDetailsBracketType').value;
            const stageId = document.getElementById('matchDetailsStageId').value;
            const groupId = document.getElementById('matchDetailsGroupId').value; // NEW

            let match;
            if (stageId) {
                const stage = tournament.stages.find(s => s.id === stageId);
                if (bracketType === 'matches') {
                    match = stage.matches.find(m => m.id === matchId);
                } else {
                    match = stage.rounds[roundIndex].matches.find(m => m.id === matchId);
                }
            } else if (groupId) { // NEW: Group Stage
                const group = tournament.groups.find(g => g.id === groupId);
                if (!group) return;
                match = group.matches.find(m => m.id === matchId);
            } else {
                if (bracketType === 'matches') {
                    match = tournament.matches.find(m => m.id === matchId);
                } else {
                    match = tournament[bracketType][roundIndex].matches.find(m => m.id === matchId);
                }
            }

            if (!match) return;

            match.bestOf = parseInt(document.getElementById('matchDetailsBestOf').value) || 1;
            match.date = document.getElementById('matchDetailsDate').value;
            match.time = document.getElementById('matchDetailsTime').value;
            match.venue = document.getElementById('matchDetailsVenue').value;
            match.referee = document.getElementById('matchDetailsReferee').value;

            // Save player stats
            tournament.settings.playerStatsFields.forEach(field => {
                match.player1Stats[field] = parseInt(document.getElementById(`p1_stat_${field}`).value) || 0;
                match.player2Stats[field] = parseInt(document.getElementById(`p2_stat_${field}`).value) || 0;
            });

            saveData();
            showAlert('Match details updated successfully!');
            closeModal('matchDetailsModal');
            if (stageId) {
                renderMultiStages(tournament);
            } else if (groupId) { // NEW: Group Stage
                renderGroupStage(tournament);
                renderPlayerLeaderboards(tournament);
            } else if (bracketType === 'rounds') {
                renderBracket(tournament);
            } else if (bracketType === 'winnerBracket' || bracketType === 'loserBracket' || bracketType === 'grandFinal') {
                renderDoubleEliminationBracket(tournament);
            } else if (bracketType === 'matches') { // For Round Robin
                renderRoundRobinMatches(tournament);
                renderRoundRobinStandings(tournament);
            }
        }

        // --- Round Robin Logic ---
        // Implements the "Circle Method" for scheduling
        function generateRoundRobinMatches(tournament, stageId = null, group = null) { // Added group parameter
            let participantsInScope;
            let matchesArray;
            let rrSettings;
            let playerStatsFields = tournament.settings.playerStatsFields;
            let confirmMessage;

            if (group) { // NEW: For a specific group
                participantsInScope = tournament.participants.filter(p => group.participants.includes(p.id));
                matchesArray = group.matches;
                rrSettings = tournament.settings.groupStage; // Use group stage settings for RR within groups
                confirmMessage = `Matches for group "${group.name}" already generated. Regenerating will clear all scores. Continue?`;
            } else if (stageId) {
                const stage = tournament.stages.find(s => s.id === stageId);
                if (!stage) return;
                participantsInScope = tournament.participants.filter(p => stage.participants.includes(p.id));
                matchesArray = stage.matches;
                rrSettings = stage.settings;
                confirmMessage = `Matches for stage "${stage.name}" already generated. Regenerating will clear all scores. Continue?`;
            } else { // Main tournament RR
                participantsInScope = tournament.participants;
                matchesArray = tournament.matches;
                rrSettings = tournament.settings;
                confirmMessage = 'Matches already generated. Regenerating will clear all scores. Continue?';
            }

            if (participantsInScope.length < 2) {
                showAlert('Need at least 2 participants to generate matches.', 'error');
                return []; // Return empty array if not enough participants
            }

            if (matchesArray.length > 0 && !confirm(confirmMessage)) {
                return matchesArray; // Return existing matches if user cancels
            }

            // Clear existing matches
            if (group) {
                group.matches = [];
            } else if (stageId) {
                const stage = tournament.stages.find(s => s.id === stageId);
                stage.matches = [];
            } else {
                tournament.matches = [];
            }

            const participants = participantsInScope;
            let numParticipants = participants.length;
            let tempParticipants = [...participants];

            // If odd number of participants, add a "BYE" placeholder
            const hasBye = numParticipants % 2 !== 0;
            if (hasBye) {
                tempParticipants.push({ id: 'BYE', name: 'BYE' });
                numParticipants++; // Adjust count for scheduling
            }

            const rounds = numParticipants - 1;
            const allMatches = [];

            for (let r = 0; r < rounds; r++) {
                for (let i = 0; i < numParticipants / 2; i++) {
                    const p1 = tempParticipants[i];
                    const p2 = tempParticipants[numParticipants - 1 - i];

                    if (p1.id === 'BYE' || p2.id === 'BYE') {
                        // This is a bye round for one participant, no match generated
                        continue;
                    }

                    // Match 1: p1 vs p2
                    allMatches.push(createMatchObject(p1.id, p2.id, playerStatsFields, null, 'Upcoming', 1, p1.id, p2.id));
                    if (rrSettings.enableHomeAway) {
                        // Match 2: p2 vs p1 (home/away swapped)
                        allMatches.push(createMatchObject(p2.id, p1.id, playerStatsFields, null, 'Upcoming', 1, p2.id, p1.id));
                    }
                }

                // Rotate participants (except the first one)
                const fixed = tempParticipants[0];
                const last = tempParticipants.pop();
                tempParticipants.splice(1, 0, last);
                tempParticipants[0] = fixed;
            }

            if (group) {
                group.matches = allMatches;
            } else if (stageId) {
                const stage = tournament.stages.find(s => s.id === stageId);
                stage.matches = allMatches;
            } else {
                tournament.matches = allMatches;
            }

            saveData();
            showAlert('Round Robin matches generated successfully!');
            return allMatches; // Return the generated matches
        }

        function renderRoundRobinMatches(tournament, targetElementId = 'roundRobinMatches', matchesArray = tournament.matches, participantsArray = tournament.participants, rrSettings = tournament.settings, stageId = null, groupId = null) { // Added groupId
            const matchesDiv = document.getElementById(targetElementId);
            matchesDiv.innerHTML = '';

            if (matchesArray.length === 0) {
                matchesDiv.innerHTML = '<p class="no-data">Matches not generated. Add participants and click "Generate Matches".</p>';
                return;
            }

            const table = document.createElement('table');
            table.className = 'round-robin-table';
            table.innerHTML = `
                <thead>
                    <tr>
                        <th>Match</th>
                        <th>Home Player</th>
                        <th>Score</th>
                        <th>Away Player</th>
                        <th>Status</th>
                        <th>Schedule</th>
                        <th>Actions</th>
                    </tr>
                </thead>
                <tbody></tbody>
            `;
            const tbody = table.querySelector('tbody');

            matchesArray.forEach(match => {
                const p1 = participantsArray.find(p => p.id === match.player1Id);
                const p2 = participantsArray.find(p => p.id === match.player2Id);
                const homePlayer = participantsArray.find(p => p.id === match.homePlayerId);
                const awayPlayer = participantsArray.find(p => p.id === match.awayPlayerId);

                const scoreInputHtml1 = tournament.settings.setBasedScoring ?
                    `<input type="text" class="sets-input" value="${match.sets !== null ? match.sets.split('-')[0] : ''}" data-match-id="${match.id}" data-player="1" ${match.status !== 'Upcoming' ? 'disabled' : ''}>` :
                    `<input type="number" class="score-input" value="${match.score1 !== null ? match.score1 : ''}" data-match-id="${match.id}" data-player="1" ${match.status !== 'Upcoming' ? 'disabled' : ''}>`;
                const scoreInputHtml2 = tournament.settings.setBasedScoring ?
                    `<input type="text" class="sets-input" value="${match.sets !== null ? match.sets.split('-')[1] : ''}" data-match-id="${match.id}" data-player="2" ${match.status !== 'Upcoming' ? 'disabled' : ''}>` :
                    `<input type="number" class="score-input" value="${match.score2 !== null ? match.score2 : ''}" data-match-id="${match.id}" data-player="2" ${match.status !== 'Upcoming' ? 'disabled' : ''}>`;

                const row = document.createElement('tr');
                row.innerHTML = `
                    <td>${homePlayer?.name || 'N/A'} vs ${awayPlayer?.name || 'N/A'}</td>
                    <td>${homePlayer?.name || 'N/A'}</td>
                    <td>
                        ${scoreInputHtml1}
                        -
                        ${scoreInputHtml2}
                    </td>
                    <td>${awayPlayer?.name || 'N/A'}</td>
                    <td>${match.status}</td>
                    <td>${match.date || 'N/A'} ${match.time || ''}</td>
                    <td>
                        <button class="btn btn-outline btn-sm" onclick="openMatchDetailsModal('${match.id}', 0, 'matches', '${stageId || ''}', '${groupId || ''}')">Details</button>
                        ${match.status === 'Upcoming' ? `<button class="btn btn-primary btn-sm" onclick="recordScore('${match.id}', 0, 'matches', '${stageId || ''}', '${groupId || ''}')">Record</button>` : ''}
                        ${match.status === 'Completed' ? `<span style="color: var(--primary-color); font-weight: bold;">Winner: ${participantsArray.find(p => p.id === match.winnerId)?.name || 'Draw'}</span>` : ''}
                    </td>
                `;
                tbody.appendChild(row);
            });
            matchesDiv.appendChild(table);
        }

        function renderRoundRobinStandings(tournament, targetElementId = 'roundRobinStandings', matchesArray = tournament.matches, participantsArray = tournament.participants, rrSettings = tournament.settings) {
            const standingsDiv = document.getElementById(targetElementId);
            standingsDiv.innerHTML = '';

            if (matchesArray.length === 0) {
                standingsDiv.innerHTML = '<p class="no-data">Standings will appear after matches are generated and scores recorded.</p>';
                return;
            }

            const participantStats = {};
            participantsArray.forEach(p => {
                participantStats[p.id] = {
                    id: p.id,
                    name: p.name,
                    played: 0, wins: 0, losses: 0, draws: 0,
                    scoreFor: 0, scoreAgainst: 0,
                    scoreDiff: 0,
                    points: 0,
                    headToHead: {} // Store head-to-head results
                };
                // Initialize custom stats for standings display
                tournament.settings.playerStatsFields.forEach(field => {
                    participantStats[p.id][field] = 0;
                });
            });

            matchesArray.forEach(match => {
                if (match.status === 'Completed') {
                    const p1Stats = participantStats[match.player1Id];
                    const p2Stats = participantStats[match.player2Id];

                    if (!p1Stats || !p2Stats) return; // Should not happen (e.g., BYE participant)

                    let score1 = tournament.settings.setBasedScoring ? parseInt(match.sets.split('-')[0]) : match.score1;
                    let score2 = tournament.settings.setBasedScoring ? parseInt(match.sets.split('-')[1]) : match.score2;

                    p1Stats.played++;
                    p2Stats.played++;

                    p1Stats.scoreFor += score1;
                    p1Stats.scoreAgainst += score2;
                    p2Stats.scoreFor += score2;
                    p2Stats.scoreAgainst += score1;

                    tournament.settings.playerStatsFields.forEach(field => {
                        p1Stats[field] += match.player1Stats[field] || 0;
                        p2Stats[field] += match.player2Stats[field] || 0;
                    });

                    if (match.winnerId === match.player1Id) {
                        p1Stats.wins++;
                        p2Stats.losses++;
                        p1Stats.points += rrSettings.pointsWin;
                        p2Stats.points += rrSettings.pointsLoss;
                        p1Stats.headToHead[p2Stats.id] = (p1Stats.headToHead[p2Stats.id] || 0) + 1;
                        p2Stats.headToHead[p1Stats.id] = (p2Stats.headToHead[p1Stats.id] || 0) - 1;
                    } else if (match.winnerId === match.player2Id) {
                        p2Stats.wins++;
                        p1Stats.losses++;
                        p2Stats.points += rrSettings.pointsWin;
                        p1Stats.points += rrSettings.pointsLoss;
                        p2Stats.headToHead[p1Stats.id] = (p2Stats.headToHead[p1Stats.id] || 0) + 1;
                        p1Stats.headToHead[p2Stats.id] = (p1Stats.headToHead[p2Stats.id] || 0) - 1;
                    } else { // Draw
                        p1Stats.draws++;
                        p2Stats.draws++;
                        p1Stats.points += rrSettings.pointsDraw;
                        p2Stats.points += rrSettings.pointsDraw;
                    }
                }
            });

            let standings = Object.values(participantStats);

            // Calculate score difference
            standings.forEach(stats => {
                stats.scoreDiff = stats.scoreFor - stats.scoreAgainst;
            });

            // Sort standings
            standings.sort((a, b) => {
                if (b.points !== a.points) return b.points - a.points;

                // Tie-breaking rules
                switch (rrSettings.tieBreaker) {
                    case 'Head-to-Head':
                        // For head-to-head, we need to compare only the matches between a and b
                        // This is a simplified H2H: just checking who won more direct matches
                        const h2h_a = a.headToHead[b.id] || 0;
                        const h2h_b = b.headToHead[a.id] || 0;
                        if (h2h_a !== h2h_b) return h2h_a - h2h_b; // Higher value means more wins against opponent
                        // Fallback to score difference if H2H is tied
                        return b.scoreDiff - a.scoreDiff;
                    case 'Score Difference':
                        return b.scoreDiff - a.scoreDiff;
                    case 'Score For':
                        return b.scoreFor - a.scoreFor;
                    case 'Random':
                    default:
                        return Math.random() - 0.5;
                }
            });

            const table = document.createElement('table');
            table.className = 'standings-table';
            let headerHtml = `
                <thead>
                    <tr>
                        <th>Rank</th>
                        <th>Participant</th>
                        <th>P</th>
                        <th>W</th>
                        <th>L</th>
                        <th>D</th>
                        <th>GF</th>
                        <th>GA</th>
                        <th>GD</th>
            `;
            tournament.settings.playerStatsFields.forEach(field => {
                headerHtml += `<th>${field}</th>`;
            });
            headerHtml += `<th>Pts</th></tr></thead><tbody></tbody>`;
            table.innerHTML = headerHtml;
            const tbody = table.querySelector('tbody');

            standings.forEach((stats, index) => {
                let rowHtml = `
                    <td class="rank">${index + 1}</td>
                    <td>${stats.name}</td>
                    <td>${stats.played}</td>
                    <td>${stats.wins}</td>
                    <td>${stats.losses}</td>
                    <td>${stats.draws}</td>
                    <td>${stats.scoreFor}</td>
                    <td>${stats.scoreAgainst}</td>
                    <td>${stats.scoreDiff}</td>
                `;
                tournament.settings.playerStatsFields.forEach(field => {
                    rowHtml += `<td>${stats[field]}</td>`;
                });
                rowHtml += `<td>${stats.points}</td>`;

                const row = document.createElement('tr');
                row.innerHTML = rowHtml;
                tbody.appendChild(row);
            });
            standingsDiv.appendChild(table);
            return standings; // Return standings for potential use (e.g., qualifiers)
        }

        // --- Multi-Stage Management ---
        function renderMultiStages(tournament) {
            const stagesListDiv = document.getElementById('stagesList');
            stagesListDiv.innerHTML = '';

            if (tournament.stages.length === 0) {
                stagesListDiv.innerHTML = '<p class="no-data">No stages defined. Click "Manage Stages" to add them.</p>';
                return;
            }

            tournament.stages.forEach(stage => {
                const stageCard = document.createElement('div');
                stageCard.className = 'stage-card';
                stageCard.innerHTML = `
                    <div class="flex-between">
                        <h4>${stage.name} (${stage.type})</h4>
                        <div class="btn-group">
                            <button class="btn btn-secondary btn-sm" onclick="editStage('${stage.id}')">Edit Stage</button>
                            <button class="btn btn-danger btn-sm" onclick="deleteStage('${stage.id}')">Delete Stage</button>
                            <button class="btn btn-outline btn-sm" onclick="openAdvanceParticipantsModal('${stage.id}')">Add Participants</button>
                            ${stage.type === TOURNAMENT_TYPES.ROUND_ROBIN ?
                                `<button class="btn btn-primary btn-sm" onclick="generateRoundRobinMatches(tournaments.find(t => t.id === currentTournamentId), '${stage.id}')">Generate Matches</button>` :
                                `<button class="btn btn-primary btn-sm" onclick="generateEliminationBracket(tournaments.find(t => t.id === currentTournamentId), '${TOURNAMENT_TYPES.SINGLE_ELIMINATION}', '${stage.id}')">Generate Bracket</button>`
                            }
                        </div>
                    </div>
                    <p>Participants: ${stage.participants.length} / ${tournament.participants.length}</p>
                    <div class="stage-content" id="stageContent_${stage.id}">
                        <!-- Stage specific content will be rendered here -->
                    </div>
                `;
                stagesListDiv.appendChild(stageCard);

                const stageContentDiv = document.getElementById(`stageContent_${stage.id}`);
                const stageParticipants = tournament.participants.filter(p => stage.participants.includes(p.id));

                if (stage.type === TOURNAMENT_TYPES.ROUND_ROBIN) {
                    const matchesDiv = document.createElement('div');
                    matchesDiv.id = `stageMatches_${stage.id}`;
                    stageContentDiv.appendChild(matchesDiv);
                    renderRoundRobinMatches(tournament, `stageMatches_${stage.id}`, stage.matches, stageParticipants, stage.settings, stage.id);

                    const standingsDiv = document.createElement('div');
                    standingsDiv.id = `stageStandings_${stage.id}`;
                    stageContentDiv.appendChild(standingsDiv);
                    renderRoundRobinStandings(tournament, `stageStandings_${stage.id}`, stage.matches, stageParticipants, stage.settings);
                } else if (stage.type === TOURNAMENT_TYPES.SINGLE_ELIMINATION) {
                    const bracketDiv = document.createElement('div');
                    bracketDiv.className = 'bracket-visualizer';
                    bracketDiv.id = `stageBracket_${stage.id}`;
                    stageContentDiv.appendChild(bracketDiv);
                    renderBracket(tournament, `stageBracket_${stage.id}`, stage.rounds, stage.id);
                }
            });
        }

        function openManageStagesModal() {
            renderCurrentStagesList();
            openModal('manageStagesModal');
        }

        function renderCurrentStagesList() {
            const listDiv = document.getElementById('currentStagesList');
            listDiv.innerHTML = '';
            const tournament = tournaments.find(t => t.id === currentTournamentId);
            if (!tournament || tournament.stages.length === 0) {
                listDiv.innerHTML = '<p class="no-data">No stages added yet.</p>';
                return;
            }

            tournament.stages.forEach(stage => {
                const item = document.createElement('div');
                item.className = 'participant-item'; // Reusing style
                item.innerHTML = `
                    <div>
                        <strong>${stage.name}</strong> (${stage.type})
                        <br><small>Participants: ${stage.participants.length}</small>
                    </div>
                    <div class="actions">
                        <button class="btn btn-secondary" onclick="editStage('${stage.id}')">Edit</button>
                        <button class="btn btn-danger" onclick="deleteStage('${stage.id}')">Delete</button>
                    </div>
                `;
                listDiv.appendChild(item);
            });
        }

        function openAddStageModal() {
            document.getElementById('stageModalTitle').textContent = 'Add Stage';
            document.getElementById('stageForm').reset();
            document.getElementById('stageId').value = '';
            document.getElementById('stageEliminationSettings').classList.add('hidden');
            document.getElementById('stageRoundRobinSettings').classList.add('hidden');
            openModal('stageModal');
        }

        function addOrUpdateStage(event) {
            event.preventDefault();
            const tournament = tournaments.find(t => t.id === currentTournamentId);
            if (!tournament) return;

            const stageId = document.getElementById('stageId').value;
            const name = document.getElementById('stageName').value;
            const type = document.getElementById('stageType').value;

            if (!name || !type) {
                showAlert('Stage name and type are required.', 'error');
                return;
            }

            const stageSettings = {
                setBasedScoring: tournament.settings.setBasedScoring, // Inherit from tournament
                playerStatsFields: tournament.settings.playerStatsFields // Inherit from tournament
            };

            if (type === TOURNAMENT_TYPES.SINGLE_ELIMINATION) {
                stageSettings.bestOf = parseInt(document.getElementById('stageBestOf').value) || 1;
            } else if (type === TOURNAMENT_TYPES.ROUND_ROBIN) {
                stageSettings.enableHomeAway = document.getElementById('stageRrEnableHomeAway').checked;
                stageSettings.pointsWin = parseInt(document.getElementById('stageRrPointsWin').value) || 3;
                stageSettings.pointsDraw = parseInt(document.getElementById('stageRrPointsDraw').value) || 1;
                stageSettings.pointsLoss = parseInt(document.getElementById('stageRrPointsLoss').value) || 0;
                stageSettings.tieBreaker = document.getElementById('stageRrTieBreaker').value || 'Points';
            }

            if (stageId) {
                const stage = tournament.stages.find(s => s.id === stageId);
                if (stage) {
                    stage.name = name;
                    stage.type = type;
                    stage.settings = stageSettings;
                    showAlert('Stage updated successfully!');
                }
            } else {
                const newStage = {
                    id: generateUniqueId(),
                    name, type,
                    participants: [], // Participants for this specific stage
                    matches: [], // For RR
                    rounds: [], // For SE
                    settings: stageSettings
                };
                tournament.stages.push(newStage);
                showAlert('Stage added successfully!');
            }

            saveData();
            renderMultiStages(tournament);
            renderCurrentStagesList();
            closeModal('stageModal');
        }

        function editStage(stageId) {
            const tournament = tournaments.find(t => t.id === currentTournamentId);
            const stage = tournament.stages.find(s => s.id === stageId);
            if (!stage) return;

            document.getElementById('stageModalTitle').textContent = 'Edit Stage';
            document.getElementById('stageId').value = stage.id;
            document.getElementById('stageName').value = stage.name;
            document.getElementById('stageType').value = stage.type;

            document.getElementById('stageEliminationSettings').classList.add('hidden');
            document.getElementById('stageRoundRobinSettings').classList.add('hidden');

            if (stage.type === TOURNAMENT_TYPES.SINGLE_ELIMINATION) {
                document.getElementById('stageEliminationSettings').classList.remove('hidden');
                document.getElementById('stageBestOf').value = stage.settings.bestOf || 1;
            } else if (stage.type === TOURNAMENT_TYPES.ROUND_ROBIN) {
                document.getElementById('stageRoundRobinSettings').classList.remove('hidden');
                document.getElementById('stageRrEnableHomeAway').checked = stage.settings.enableHomeAway || false;
                document.getElementById('stageRrPointsWin').value = stage.settings.pointsWin;
                document.getElementById('stageRrPointsDraw').value = stage.settings.pointsDraw;
                document.getElementById('stageRrPointsLoss').value = stage.settings.pointsLoss;
                document.getElementById('stageRrTieBreaker').value = stage.settings.tieBreaker;
            }

            openModal('stageModal');
        }

        function deleteStage(stageId) {
            if (!confirm('Are you sure you want to delete this stage and all its matches/brackets?')) {
                return;
            }
            const tournament = tournaments.find(t => t.id === currentTournamentId);
            if (tournament) {
                tournament.stages = tournament.stages.filter(s => s.id !== stageId);
                saveData();
                showAlert('Stage deleted successfully!', 'danger');
                renderMultiStages(tournament);
                renderCurrentStagesList();
            }
        }

        function openAdvanceParticipantsModal(stageId) {
            const tournament = tournaments.find(t => t.id === currentTournamentId);
            const stage = tournament.stages.find(s => s.id === stageId);
            if (!tournament || !stage) return;

            document.getElementById('advanceStageId').value = stageId;
            const availableParticipantsList = document.getElementById('availableParticipantsList');
            availableParticipantsList.innerHTML = '';

            tournament.participants.forEach(p => {
                const checkboxDiv = document.createElement('div');
                checkboxDiv.className = 'checkbox-group';
                checkboxDiv.innerHTML = `
                    <input type="checkbox" id="adv_p_${p.id}" value="${p.id}" ${stage.participants.includes(p.id) ? 'checked' : ''}>
                    <label for="adv_p_${p.id}">${p.name}</label>
                `;
                availableParticipantsList.appendChild(checkboxDiv);
            });

            openModal('advanceParticipantsModal');
        }

        function processAdvanceParticipants() {
            const tournament = tournaments.find(t => t.id === currentTournamentId);
            const stageId = document.getElementById('advanceStageId').value;
            const stage = tournament.stages.find(s => s.id === stageId);
            if (!tournament || !stage) return;

            const selectedParticipantIds = Array.from(document.querySelectorAll('#availableParticipantsList input[type="checkbox"]:checked'))
                                                .map(cb => cb.value);

            stage.participants = selectedParticipantIds;
            // Reset matches/rounds for the stage if participants change
            stage.matches = [];
            stage.rounds = [];

            saveData();
            showAlert('Participants updated for stage successfully!');
            renderMultiStages(tournament);
            renderCurrentStagesList();
            closeModal('advanceParticipantsModal');
        }

        // --- NEW: Group Stage Logic ---
        function generateGroupStage(tournament) {
            const participants = tournament.participants;
            const groupsCount = tournament.settings.groupStage.groupsCount;
            const advanceK = tournament.settings.groupStage.advanceK;

            if (participants.length < groupsCount * 2) { // At least 2 participants per group
                showAlert(`Not enough participants (${participants.length}) for ${groupsCount} groups. Need at least ${groupsCount * 2}.`, 'error');
                return;
            }
            if (advanceK > participants.length / groupsCount) {
                showAlert(`Cannot advance ${advanceK} teams per group. Max is ${Math.floor(participants.length / groupsCount)}.`, 'error');
                return;
            }

            if (tournament.groups.length > 0 && !confirm('Groups already generated. Regenerating will clear all matches and standings. Continue?')) {
                return;
            }

            tournament.groups = []; // Clear existing groups

            // 1. Split into groups (serpentine seeding)
            const sortedParticipants = [...participants].sort((a, b) => (a.seed || Infinity) - (b.seed || Infinity));
            const groups = Array.from({ length: groupsCount }, (_, i) => ({
                id: generateUniqueId(),
                name: `Group ${String.fromCharCode(65 + i)}`, // A, B, C...
                participants: [], // Participant IDs
                matches: [],
                standings: []
            }));

            for (let i = 0; i < sortedParticipants.length; i++) {
                const groupIndex = i % groupsCount;
                groups[groupIndex].participants.push(sortedParticipants[i].id);
            }
            tournament.groups = groups;

            // 2. Schedule matches (round robin inside each group)
            tournament.groups.forEach(group => {
                group.matches = generateRoundRobinMatches(tournament, null, group); // Pass group object
            });

            // 3. Initialize standings (will be updated on score record)
            tournament.groups.forEach(group => {
                group.standings = renderRoundRobinStandings(tournament, null, group.matches, tournament.participants.filter(p => group.participants.includes(p.id)), tournament.settings.groupStage);
            });

            saveData();
            showAlert('Group Stage generated successfully!');
            renderGroupStage(tournament);
            renderPlayerLeaderboards(tournament);
        }

        function renderGroupStage(tournament) {
            const groupsDisplayDiv = document.getElementById('groupsDisplay');
            groupsDisplayDiv.innerHTML = '';

            if (tournament.groups.length === 0) {
                groupsDisplayDiv.innerHTML = '<p class="no-data">Groups not generated. Add participants and click "Generate Groups".</p>';
                return;
            }

            tournament.groups.forEach(group => {
                const groupCard = document.createElement('div');
                groupCard.className = 'group-card';
                groupCard.innerHTML = `
                    <h4>${group.name}</h4>
                    <p>Participants: ${group.participants.length}</p>
                    <div class="group-content">
                        <h5>Matches</h5>
                        <div id="groupMatches_${group.id}"></div>
                        <h5 style="margin-top: 20px;">Standings</h5>
                        <div id="groupStandings_${group.id}"></div>
                    </div>
                `;
                groupsDisplayDiv.appendChild(groupCard);

                const groupParticipants = tournament.participants.filter(p => group.participants.includes(p.id));
                renderRoundRobinMatches(tournament, `groupMatches_${group.id}`, group.matches, groupParticipants, tournament.settings.groupStage, null, group.id);
                group.standings = renderRoundRobinStandings(tournament, `groupStandings_${group.id}`, group.matches, groupParticipants, tournament.settings.groupStage);
            });

            // Determine qualifiers (optional, can be done after all matches are played)
            const qualifiers = [];
            tournament.groups.forEach(group => {
                const topK = group.standings.slice(0, tournament.settings.groupStage.advanceK);
                qualifiers.push(...topK.map(p => p.name));
            });
            if (qualifiers.length > 0) {
                groupsDisplayDiv.insertAdjacentHTML('beforeend', `<h3 style="margin-top: 30px;">Qualifiers for Next Stage:</h3><p>${qualifiers.join(', ')}</p>`);
            }
        }

        // --- NEW: Player Stats Management ---
        function updateAggregatedPlayerStats(tournament, match, participantsInScope) {
            const p1 = participantsInScope.find(p => p.id === match.player1Id);
            const p2 = participantsInScope.find(p => p.id === match.player2Id);

            if (!p1 || !p2) return; // Skip if BYE or participant not found

            // Reset stats for this match to avoid double counting if re-recorded
            // This is a simplified approach; a more robust system would track match-specific stats separately
            // and re-aggregate all matches. For now, we'll just update.

            p1.stats.matchesPlayed = (p1.stats.matchesPlayed || 0) + 1;
            p2.stats.matchesPlayed = (p2.stats.matchesPlayed || 0) + 1;

            tournament.settings.playerStatsFields.forEach(field => {
                p1.stats[field] = (p1.stats[field] || 0) + (match.player1Stats[field] || 0);
                p2.stats[field] = (p2.stats[field] || 0) + (match.player2Stats[field] || 0);
            });
        }

        function renderPlayerLeaderboards(tournament) {
            const leaderboardsDiv = document.getElementById('playerLeaderboardsDisplay');
            leaderboardsDiv.innerHTML = '';

            if (tournament.participants.length === 0) {
                leaderboardsDiv.innerHTML = '<p class="no-data">No participants to display leaderboards.</p>';
                return;
            }

            if (tournament.settings.playerStatsFields.length === 0) {
                leaderboardsDiv.innerHTML = '<p class="no-data">No custom player stats fields defined for this tournament.</p>';
                return;
            }

            tournament.settings.playerStatsFields.forEach(field => {
                const fieldName = field.charAt(0).toUpperCase() + field.slice(1); // Capitalize for display
                const leaderboardTable = document.createElement('table');
                leaderboardTable.className = 'leaderboard-table';
                leaderboardTable.innerHTML = `
                    <thead>
                        <tr>
                            <th>Rank</th>
                            <th>Player</th>
                            <th>${fieldName}</th>
                            <th>Matches Played</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                `;
                const tbody = leaderboardTable.querySelector('tbody');

                const sortedPlayers = [...tournament.participants].sort((a, b) => {
                    const statA = a.stats[field] || 0;
                    const statB = b.stats[field] || 0;
                    return statB - statA; // Descending order
                });

                sortedPlayers.forEach((player, index) => {
                    if (player.id === 'BYE') return; // Skip BYE placeholder
                    const row = document.createElement('tr');
                    row.innerHTML = `
                        <td class="rank">${index + 1}</td>
                        <td>${player.name}</td>
                        <td>${player.stats[field] || 0}</td>
                        <td>${player.stats.matchesPlayed || 0}</td>
                    `;
                    tbody.appendChild(row);
                });

                const fieldHeader = document.createElement('h4');
                fieldHeader.textContent = `${fieldName} Leaderboard`;
                leaderboardsDiv.appendChild(fieldHeader);
                leaderboardsDiv.appendChild(leaderboardTable);
            });
        }


        // --- Import/Export ---
        function exportData() {
            const dataStr = JSON.stringify(tournaments, null, 2);
            const blob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `tournament_manager_data_${new Date().toISOString().slice(0,10)}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            showAlert('Data exported successfully!');
        }

        function importData(event) {
            const file = event.target.files[0];
            if (!file) {
                showAlert('No file selected.', 'error');
                return;
            }

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const importedData = JSON.parse(e.target.result);
                    if (!Array.isArray(importedData)) {
                        throw new Error('Invalid JSON format. Expected an array of tournaments.');
                    }

                    if (confirm('Do you want to REPLACE all existing data with the imported data? Click Cancel to MERGE (add new, update existing by ID).')) {
                        tournaments = importedData;
                        showAlert('All data replaced successfully!', 'success');
                    } else {
                        importedData.forEach(importedTournament => {
                            const existingIndex = tournaments.findIndex(t => t.id === importedTournament.id);
                            if (existingIndex !== -1) {
                                tournaments[existingIndex] = importedTournament; // Update existing
                            } else {
                                tournaments.push(importedTournament); // Add new
                            }
                        });
                        showAlert('Data merged successfully!', 'success');
                    }

                    saveData();
                    renderTournamentList();
                    showSection('dashboardSection');
                    document.getElementById('importFileInput').value = ''; // Clear file input
                } catch (error) {
                    showAlert(`Error importing data: ${error.message}`, 'error');
                }
            };
            reader.readAsText(file);
        }

        // --- QR Code ---
        function showQrCode() {
            const tournament = tournaments.find(t => t.id === currentTournamentId);
            if (!tournament) return;

            const qrCodeContainer = document.getElementById('qrCodeContainer');
            qrCodeContainer.innerHTML = ''; // Clear previous QR code

            // Use the inlined QRCode generator
            new QRCode({
                element: qrCodeContainer,
                value: tournament.id,
                size: 200,
                background: document.body.classList.contains('dark-mode') ? '#3a3a3a' : '#ffffff',
                foreground: document.body.classList.contains('dark-mode') ? '#e0e0e0' : '#000000'
            });

            document.getElementById('qrTournamentId').textContent = tournament.id;
            openModal('qrCodeModal');
        }


        // --- Event Listeners ---
        document.addEventListener('DOMContentLoaded', () => {
            // Load theme
            const savedTheme = localStorage.getItem(LS_THEME_KEY) || 'light';
            applyTheme(savedTheme);

            loadData();
            renderTournamentList(); // Initial render

            // Navigation
            document.getElementById('navDashboard').addEventListener('click', () => showSection('dashboardSection'));
            document.getElementById('navCreateTournament').addEventListener('click', () => {
                showSection('createTournamentSection');
                document.getElementById('createTournamentForm').reset();
                // Reset specific settings visibility
                document.getElementById('eliminationSettings').classList.add('hidden');
                document.getElementById('roundRobinSettings').classList.add('hidden');
                document.getElementById('groupStageSettings').classList.add('hidden'); // NEW
                document.getElementById('swissSettings').classList.add('hidden');
                document.getElementById('gslSettings').classList.add('hidden');
                document.getElementById('ladderSettings').classList.add('hidden');
                document.getElementById('tournamentSetBasedScoring').checked = false;
                document.getElementById('tournamentPlayerStatsFields').value = '';
            });
            document.getElementById('navImportExport').addEventListener('click', () => showSection('importExportSection'));

            // Theme Toggle
            document.getElementById('themeToggle').addEventListener('click', toggleTheme);

            // Create Tournament Form
            document.getElementById('createTournamentForm').addEventListener('submit', createTournament);
            document.getElementById('tournamentType').addEventListener('change', (e) => {
                // Hide all specific settings first
                document.getElementById('eliminationSettings').classList.add('hidden');
                document.getElementById('roundRobinSettings').classList.add('hidden');
                document.getElementById('groupStageSettings').classList.add('hidden'); // NEW
                document.getElementById('swissSettings').classList.add('hidden');
                document.getElementById('gslSettings').classList.add('hidden');
                document.getElementById('ladderSettings').classList.add('hidden');

                // Show relevant settings based on type
                if (e.target.value === TOURNAMENT_TYPES.SINGLE_ELIMINATION || e.target.value === TOURNAMENT_TYPES.DOUBLE_ELIMINATION) {
                    document.getElementById('eliminationSettings').classList.remove('hidden');
                } else if (e.target.value === TOURNAMENT_TYPES.ROUND_ROBIN) {
                    document.getElementById('roundRobinSettings').classList.remove('hidden');
                } else if (e.target.value === TOURNAMENT_TYPES.GROUP_STAGE) { // NEW
                    document.getElementById('groupStageSettings').classList.remove('hidden');
                } else if (e.target.value === TOURNAMENT_TYPES.SWISS_SYSTEM) {
                    document.getElementById('swissSettings').classList.remove('hidden');
                } else if (e.target.value === TOURNAMENT_TYPES.GSL_FORMAT) {
                    document.getElementById('gslSettings').classList.remove('hidden');
                } else if (e.target.value === TOURNAMENT_TYPES.LADDER) {
                    document.getElementById('ladderSettings').classList.remove('hidden');
                }
            });

            // Tournament Detail Actions
            document.getElementById('backToDashboardBtn').addEventListener('click', () => showSection('dashboardSection'));
            document.getElementById('editTournamentBtn').addEventListener('click', editTournamentDetails);
            document.getElementById('deleteTournamentBtn').addEventListener('click', deleteTournament);
            document.getElementById('changeTournamentStatus').addEventListener('change', changeTournamentStatus);
            document.getElementById('showQrCodeBtn').addEventListener('click', showQrCode);


            // Edit Tournament Modal Form
            document.getElementById('editTournamentForm').addEventListener('submit', saveEditedTournament);
            document.getElementById('editTournamentType').addEventListener('change', (e) => {
                // Hide all specific settings first
                document.getElementById('editEliminationSettings').classList.add('hidden');
                document.getElementById('editRoundRobinSettings').classList.add('hidden');
                document.getElementById('editGroupStageSettings').classList.add('hidden'); // NEW
                document.getElementById('editSwissSettings').classList.add('hidden');
                document.getElementById('editGslSettings').classList.add('hidden');
                document.getElementById('editLadderSettings').classList.add('hidden');

                // Show relevant settings based on type
                if (e.target.value === TOURNAMENT_TYPES.SINGLE_ELIMINATION || e.target.value === TOURNAMENT_TYPES.DOUBLE_ELIMINATION) {
                    document.getElementById('editEliminationSettings').classList.remove('hidden');
                } else if (e.target.value === TOURNAMENT_TYPES.ROUND_ROBIN) {
                    document.getElementById('editRoundRobinSettings').classList.remove('hidden');
                } else if (e.target.value === TOURNAMENT_TYPES.GROUP_STAGE) { // NEW
                    document.getElementById('editGroupStageSettings').classList.remove('hidden');
                } else if (e.target.value === TOURNAMENT_TYPES.SWISS_SYSTEM) {
                    document.getElementById('editSwissSettings').classList.remove('hidden');
                } else if (e.target.value === TOURNAMENT_TYPES.GSL_FORMAT) {
                    document.getElementById('editGslSettings').classList.remove('hidden');
                } else if (e.target.value === TOURNAMENT_TYPES.LADDER) {
                    document.getElementById('editLadderSettings').classList.remove('hidden');
                }
            });


            // Participant Management
            document.getElementById('addParticipantBtn').addEventListener('click', openAddParticipantModal);
            document.getElementById('participantForm').addEventListener('submit', addOrUpdateParticipant);
            document.getElementById('bulkImportParticipantsBtn').addEventListener('click', openBulkImportModal);
            document.getElementById('processBulkImportBtn').addEventListener('click', processBulkImport);
            document.getElementById('copyParticipantsBtn').addEventListener('click', openCopyParticipantsModal);
            document.getElementById('processCopyParticipantsBtn').addEventListener('click', processCopyParticipants);


            // Bracket/Match Generation
            document.getElementById('generateBracketBtn').addEventListener('click', () => {
                const tournament = tournaments.find(t => t.id === currentTournamentId);
                if (tournament) generateEliminationBracket(tournament, TOURNAMENT_TYPES.SINGLE_ELIMINATION);
            });
            document.getElementById('generateDoubleEliminationBracketBtn').addEventListener('click', () => {
                const tournament = tournaments.find(t => t.id === currentTournamentId);
                if (tournament) generateEliminationBracket(tournament, TOURNAMENT_TYPES.DOUBLE_ELIMINATION);
            });
            document.getElementById('generateRoundRobinBtn').addEventListener('click', () => {
                const tournament = tournaments.find(t => t.id === currentTournamentId);
                if (tournament) generateRoundRobinMatches(tournament);
            });
            document.getElementById('generateGroupStageBtn').addEventListener('click', () => { // NEW
                const tournament = tournaments.find(t => t.id === currentTournamentId);
                if (tournament) generateGroupStage(tournament);
            });
            // New format generation buttons (placeholders)
            document.getElementById('generateSwissBtn').addEventListener('click', () => showAlert('Swiss System generation not yet implemented.', 'info'));
            document.getElementById('generateGSLBtn').addEventListener('click', () => showAlert('GSL Format generation not yet implemented.', 'info'));
            document.getElementById('manageLadderBtn').addEventListener('click', () => showAlert('Ladder management not yet implemented.', 'info'));


            // Multi-Stage Management
            document.getElementById('manageStagesBtn').addEventListener('click', openManageStagesModal);
            document.getElementById('addStageBtn').addEventListener('click', openAddStageModal);
            document.getElementById('stageForm').addEventListener('submit', addOrUpdateStage);
            document.getElementById('stageType').addEventListener('change', (e) => {
                document.getElementById('stageEliminationSettings').classList.add('hidden');
                document.getElementById('stageRoundRobinSettings').classList.add('hidden');
                if (e.target.value === TOURNAMENT_TYPES.SINGLE_ELIMINATION) {
                    document.getElementById('stageEliminationSettings').classList.remove('hidden');
                } else if (e.target.value === TOURNAMENT_TYPES.ROUND_ROBIN) {
                    document.getElementById('stageRoundRobinSettings').classList.remove('hidden');
                }
            });
            document.getElementById('processAdvanceParticipantsBtn').addEventListener('click', processAdvanceParticipants);


            // Match Details Modal
            document.getElementById('matchDetailsForm').addEventListener('submit', saveMatchDetails);

            // Search and Filter
            document.getElementById('tournamentSearch').addEventListener('input', renderTournamentList);
            document.getElementById('tournamentFilterStatus').addEventListener('change', renderTournamentList);
            document.getElementById('tournamentFilterSport').addEventListener('change', renderTournamentList);
            document.getElementById('tournamentFilterType').addEventListener('change', renderTournamentList);

            // Import/Export
            document.getElementById('exportDataBtn').addEventListener('click', exportData);
            document.getElementById('importFileInput').addEventListener('change', importData);
        });
    </script>
</body>
</html>

-------------------------------------------------------------------------------------------------

Any kind of tournament will have random scheduling, and in case of the round-robin scheduling, you can use random scheduling plus circular scheduling so that home and away matches are played properly. Please understand this that the multi-stage tournaments will have two stages predefined. First one will be group stage where various groups will be created just as the format group stage is working right now and after group stage there will come the knockout stage under which the promoting or the qualifying members from the group stage will play matches against each other and in case of the group stage randomization will be there, scheduling will be there for their specific things and in case of all the types of tournaments there will be team leaderboards and player leaderboards separately because the participants of all the tournaments are teams not players. Teams play against each other and there will be a section for player stats where player related stats will be stored there and could be edited, managed anytime, modified anytime the user wants. You can call the team leaderboards as standings. Just like as it is done right now.I want the player leaderboards to be editable, modifiable even after the tournament is started so that we can add player names, add new players or edit the existing player's stats while the creation of the tournament which stats to record for each player in player stats will be customized by the user the fields will be created by the user as per the user's choice. In each match's details, there will be fields for the player names and their statistics to be added up as per the user specified, and that will reflect on the player's statistics or player leaderboards.
