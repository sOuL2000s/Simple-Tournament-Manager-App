<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ultimate Tournament Manager (Score7 Inspired)</title>
    <style>
        /* --- Global Styles & Variables --- */
        :root {
            --bg-color: #f4f7f6;
            --text-color: #333;
            --primary-color: #4CAF50;
            --primary-dark: #388E3C;
            --secondary-color: #2196F3;
            --accent-color: #FFC107;
            --border-color: #ddd;
            --card-bg: #fff;
            --input-bg: #f9f9f9;
            --shadow: 0 2px 5px rgba(0,0,0,0.1);
            --radius: 8px;
            --font-family: 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
        }

        body.dark-mode {
            --bg-color: #2c2c2c;
            --text-color: #e0e0e0;
            --primary-color: #66BB6A;
            --primary-dark: #43A047;
            --secondary-color: #64B5F6;
            --accent-color: #FFEB3B;
            --border-color: #555;
            --card-bg: #3a3a3a;
            --input-bg: #444;
            --shadow: 0 2px 5px rgba(0,0,0,0.3);
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: var(--font-family);
            background-color: var(--bg-color);
            color: var(--text-color);
            line-height: 1.6;
            transition: background-color 0.3s, color 0.3s;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        /* --- Layout --- */
        .container {
            max-width: 1200px;
            margin: 20px auto;
            padding: 0 20px;
            flex-grow: 1;
        }

        header {
            background-color: var(--primary-color);
            color: white;
            padding: 15px 20px;
            text-align: center;
            box-shadow: var(--shadow);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        header h1 {
            margin: 0;
            font-size: 1.8em;
        }

        .theme-toggle {
            background: none;
            border: none;
            color: white;
            font-size: 1.5em;
            cursor: pointer;
            padding: 5px;
            border-radius: var(--radius);
            transition: background-color 0.2s;
        }
        .theme-toggle:hover {
            background-color: rgba(255,255,255,0.2);
        }

        nav {
            background-color: var(--card-bg);
            box-shadow: var(--shadow);
            border-radius: var(--radius);
            margin-top: 20px;
            display: flex;
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
        }

        nav button {
            flex: 1;
            min-width: 120px;
            background: none;
            border: none;
            padding: 15px 20px;
            font-size: 1.1em;
            cursor: pointer;
            color: var(--text-color);
            transition: background-color 0.3s, color 0.3s;
            border-bottom: 3px solid transparent;
        }

        nav button:hover {
            background-color: var(--bg-color);
        }

        nav button.active {
            color: var(--primary-color);
            border-bottom-color: var(--primary-color);
            font-weight: bold;
        }

        .content-section {
            background-color: var(--card-bg);
            padding: 30px;
            border-radius: var(--radius);
            box-shadow: var(--shadow);
            margin-top: 20px;
        }

        /* --- Typography --- */
        h2, h3, h4 {
            color: var(--primary-color);
            margin-bottom: 15px;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 10px;
        }

        h2 { font-size: 1.8em; }
        h3 { font-size: 1.4em; }
        h4 { font-size: 1.2em; }

        /* --- Forms --- */
        .form-group {
            margin-bottom: 15px;
        }

        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: var(--text-color);
        }

        .form-group input[type="text"],
        .form-group input[type="number"],
        .form-group input[type="date"],
        .form-group input[type="time"],
        .form-group select,
        .form-group textarea {
            width: 100%;
            padding: 10px 12px;
            border: 1px solid var(--border-color);
            border-radius: var(--radius);
            background-color: var(--input-bg);
            color: var(--text-color);
            font-size: 1em;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .form-group input:focus,
        .form-group select:focus,
        .form-group textarea:focus {
            border-color: var(--primary-color);
            box-shadow: 0 0 0 2px rgba(var(--primary-color-rgb, 76, 175, 80), 0.2);
            outline: none;
        }

        .form-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
        }
        .checkbox-group input[type="checkbox"] {
            width: auto;
            margin-right: 5px;
        }

        /* --- Buttons --- */
        .btn {
            display: inline-block;
            padding: 10px 20px;
            border-radius: var(--radius);
            cursor: pointer;
            font-size: 1em;
            font-weight: bold;
            text-align: center;
            text-decoration: none;
            transition: background-color 0.2s, transform 0.1s;
            border: none;
        }

        .btn-primary {
            background-color: var(--primary-color);
            color: white;
        }
        .btn-primary:hover {
            background-color: var(--primary-dark);
            transform: translateY(-1px);
        }

        .btn-secondary {
            background-color: var(--secondary-color);
            color: white;
        }
        .btn-secondary:hover {
            background-color: #1976D2; /* Darker secondary */
            transform: translateY(-1px);
        }

        .btn-danger {
            background-color: #f44336;
            color: white;
        }
        .btn-danger:hover {
            background-color: #d32f2f;
            transform: translateY(-1px);
        }

        .btn-outline {
            background-color: transparent;
            color: var(--primary-color);
            border: 2px solid var(--primary-color);
        }
        .btn-outline:hover {
            background-color: var(--primary-color);
            color: white;
            transform: translateY(-1px);
        }

        .btn-group {
            display: flex;
            gap: 10px;
            margin-top: 20px;
            flex-wrap: wrap;
        }
        .btn-sm {
            padding: 8px 12px;
            font-size: 0.9em;
        }

        /* --- Lists & Cards --- */
        .tournament-list {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
        }

        .tournament-card {
            background-color: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: var(--radius);
            padding: 20px;
            box-shadow: var(--shadow);
            transition: transform 0.2s, box-shadow 0.2s;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .tournament-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 4px 10px rgba(0,0,0,0.15);
        }

        .tournament-card h3 {
            margin-top: 0;
            margin-bottom: 10px;
            border-bottom: none;
            padding-bottom: 0;
            color: var(--primary-color);
        }

        .tournament-card p {
            margin-bottom: 8px;
            font-size: 0.95em;
        }

        .tournament-card .status {
            display: inline-block;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 0.8em;
            font-weight: bold;
            margin-top: 10px;
        }

        .status.upcoming { background-color: var(--secondary-color); color: white; }
        .status.active { background-color: var(--primary-color); color: white; }
        .status.completed { background-color: #9E9E9E; color: white; }

        .no-data {
            text-align: center;
            padding: 40px;
            font-style: italic;
            color: var(--text-color);
            opacity: 0.7;
        }

        /* --- Tournament Detail Specifics --- */
        .tournament-detail-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 15px;
        }

        .tournament-detail-header h2 {
            margin: 0;
            border-bottom: none;
            padding-bottom: 0;
        }

        .tournament-info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .tournament-info-item {
            background-color: var(--input-bg);
            padding: 15px;
            border-radius: var(--radius);
            border: 1px solid var(--border-color);
        }
        .tournament-info-item strong {
            display: block;
            margin-bottom: 5px;
            color: var(--primary-color);
        }

        .participants-list, .matches-list {
            list-style: none;
            padding: 0;
        }

        .participant-item, .match-item, .player-item { /* Added .player-item */
            background-color: var(--input-bg);
            border: 1px solid var(--border-color);
            border-radius: var(--radius);
            padding: 15px;
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 10px;
        }

        .participant-item .actions, .match-item .actions, .player-item .actions {
            display: flex;
            gap: 8px;
        }

        .participant-item .actions .btn, .match-item .actions .btn, .player-item .actions .btn {
            padding: 8px 12px;
            font-size: 0.9em;
        }

        /* --- Bracket Display (Single/Double Elimination) --- */
        .bracket-visualizer {
            display: flex;
            justify-content: center;
            align-items: flex-start; /* Align rounds at the top */
            overflow-x: auto;
            padding: 20px 0;
            gap: 40px; /* Space between rounds */
        }

        .bracket-round-simple {
            display: flex;
            flex-direction: column;
            gap: 20px; /* Gap between matches in a round */
            position: relative;
            min-width: 250px;
        }

        .bracket-round-simple h4 {
            text-align: center;
            margin-bottom: 15px;
            color: var(--primary-color);
            border-bottom: none;
            padding-bottom: 0;
        }

        .bracket-match-simple {
            background-color: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: var(--radius);
            padding: 10px;
            box-shadow: var(--shadow);
            position: relative;
        }

        .bracket-match-simple .player-line {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 5px 0;
            border-bottom: 1px dashed var(--border-color);
        }
        .bracket-match-simple .player-line:last-of-type {
            border-bottom: none;
        }
        .bracket-match-simple .player-line.winner-player {
            background-color: var(--primary-color);
            color: white;
            border-radius: 5px;
            padding: 5px 10px;
            margin: 2px -5px;
        }

        .bracket-match-simple .score-input {
            width: 60px;
            padding: 3px;
            margin-left: 5px;
            border: 1px solid var(--border-color);
            border-radius: 3px;
            background-color: var(--bg-color);
            color: var(--text-color);
            text-align: center;
        }
        .bracket-match-simple .sets-input {
            width: 100px;
            padding: 3px;
            margin-left: 5px;
            border: 1px solid var(--border-color);
            border-radius: 3px;
            background-color: var(--bg-color);
            color: var(--text-color);
            text-align: center;
        }

        .bracket-match-simple .match-actions {
            margin-top: 10px;
            text-align: right;
            display: flex;
            gap: 5px;
            justify-content: flex-end;
            flex-wrap: wrap;
        }
        .bracket-match-simple .match-actions .btn {
            padding: 5px 10px;
            font-size: 0.8em;
        }

        .match-details-popup {
            position: absolute;
            background-color: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: var(--radius);
            padding: 15px;
            box-shadow: var(--shadow);
            z-index: 10;
            min-width: 250px;
            max-width: 350px;
            top: 100%; /* Position below the match */
            left: 0;
            margin-top: 5px;
            display: none; /* Hidden by default */
        }
        .match-details-popup.active {
            display: block;
        }
        .match-details-popup p {
            margin-bottom: 5px;
            font-size: 0.9em;
        }
        .match-details-popup strong {
            color: var(--primary-color);
        }
        .match-details-popup .player-stats-display {
            margin-top: 10px;
            border-top: 1px dashed var(--border-color);
            padding-top: 10px;
        }
        .match-details-popup .player-stats-display div {
            margin-bottom: 3px;
        }
        .match-details-popup .player-stats-display strong {
            color: var(--secondary-color);
        }

        /* Double Elimination Specifics */
        .double-elimination-wrapper {
            display: flex;
            flex-direction: column;
            gap: 30px;
            width: 100%;
            align-items: center;
        }
        .double-elimination-wrapper > div {
            width: 100%;
            max-width: 100%;
            overflow-x: auto;
            padding-bottom: 10px; /* For scrollbar */
        }
        .double-elimination-wrapper h3 {
            text-align: center;
            width: 100%;
            margin-top: 20px;
            color: var(--secondary-color);
        }
        .double-elimination-wrapper .bracket-visualizer {
            justify-content: flex-start; /* Align rounds to the left */
        }

        /* Multi-Stage Specifics */
        .multi-stage-container .stage-card {
            background-color: var(--input-bg);
            border: 1px solid var(--border-color);
            border-radius: var(--radius);
            padding: 15px;
            margin-bottom: 15px;
            box-shadow: var(--shadow);
        }
        .multi-stage-container .stage-card h4 {
            margin-top: 0;
            margin-bottom: 10px;
            border-bottom: none;
            padding-bottom: 0;
            color: var(--secondary-color);
        }
        .multi-stage-container .stage-card .stage-content {
            margin-top: 15px;
            border-top: 1px dashed var(--border-color);
            padding-top: 15px;
        }

        /* Group Stage Specifics */
        .group-card {
            background-color: var(--input-bg);
            border: 1px solid var(--border-color);
            border-radius: var(--radius);
            padding: 15px;
            margin-bottom: 20px;
            box-shadow: var(--shadow);
        }
        .group-card h4 {
            margin-top: 0;
            margin-bottom: 10px;
            border-bottom: none;
            padding-bottom: 0;
            color: var(--secondary-color);
        }
        .group-card .group-content {
            margin-top: 15px;
            border-top: 1px dashed var(--border-color);
            padding-top: 15px;
        }

        /* --- Round Robin Table --- */
        .round-robin-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }
        .round-robin-table th, .round-robin-table td {
            border: 1px solid var(--border-color);
            padding: 10px;
            text-align: left;
        }
        .round-robin-table th {
            background-color: var(--primary-color);
            color: white;
            font-weight: bold;
        }
        .round-robin-table tr:nth-child(even) {
            background-color: var(--input-bg);
        }
        .round-robin-table tr:hover {
            background-color: var(--bg-color);
        }

        .round-robin-table .score-input, .round-robin-table .sets-input {
            width: 60px;
            padding: 5px;
            border: 1px solid var(--border-color);
            border-radius: 5px;
            background-color: var(--bg-color);
            color: var(--text-color);
            text-align: center;
        }
        .round-robin-table .sets-input {
            width: 100px;
        }

        /* --- Standings Table --- */
        .standings-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }
        .standings-table th, .standings-table td {
            border: 1px solid var(--border-color);
            padding: 10px;
            text-align: left;
        }
        .standings-table th {
            background-color: var(--secondary-color);
            color: white;
            font-weight: bold;
        }
        .standings-table tr:nth-child(even) {
            background-color: var(--input-bg);
        }
        .standings-table tr:hover {
            background-color: var(--bg-color);
        }
        .standings-table td.rank {
            font-weight: bold;
            text-align: center;
        }

        /* --- Leaderboard Table --- */
        .leaderboard-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }
        .leaderboard-table th, .leaderboard-table td {
            border: 1px solid var(--border-color);
            padding: 10px;
            text-align: left;
        }
        .leaderboard-table th {
            background-color: var(--accent-color);
            color: var(--text-color);
            font-weight: bold;
        }
        .leaderboard-table tr:nth-child(even) {
            background-color: var(--input-bg);
        }
        .leaderboard-table tr:hover {
            background-color: var(--bg-color);
        }
        .leaderboard-table td.rank {
            font-weight: bold;
            text-align: center;
        }


        /* --- Modals --- */
        .modal {
            display: none; /* Hidden by default */
            position: fixed; /* Stay in place */
            z-index: 1000; /* Sit on top */
            left: 0;
            top: 0;
            width: 100%; /* Full width */
            height: 100%; /* Full height */
            overflow: auto; /* Enable scroll if needed */
            background-color: rgba(0,0,0,0.6); /* Black w/ opacity */
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
            padding-top: 60px;
        }

        .modal-content {
            background-color: var(--card-bg);
            margin: 5% auto;
            padding: 30px;
            border-radius: var(--radius);
            box-shadow: var(--shadow);
            width: 90%;
            max-width: 700px;
            position: relative;
            animation: fadeIn 0.3s ease-out;
        }

        .modal-content h3 {
            margin-top: 0;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 10px;
            margin-bottom: 20px;
            color: var(--primary-color);
        }

        .close-button {
            color: var(--text-color);
            position: absolute;
            top: 15px;
            right: 25px;
            font-size: 30px;
            font-weight: bold;
            cursor: pointer;
            transition: color 0.2s;
        }

        .close-button:hover,
        .close-button:focus {
            color: var(--primary-color);
            text-decoration: none;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* --- Utility & Responsive --- */
        .hidden {
            display: none !important;
        }

        .text-center {
            text-align: center;
        }

        .flex-between {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 10px;
        }

        .flex-gap-10 {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .alert {
            padding: 15px;
            margin-bottom: 20px;
            border-radius: var(--radius);
            font-weight: bold;
        }
        .alert-success {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        .alert-error {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .search-filter-bar {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        .search-filter-bar input, .search-filter-bar select {
            flex: 1;
            min-width: 150px;
        }

        footer {
            text-align: center;
            padding: 20px;
            margin-top: 40px;
            background-color: var(--card-bg);
            color: var(--text-color);
            border-top: 1px solid var(--border-color);
            font-size: 0.9em;
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .container {
                margin: 10px auto;
                padding: 0 10px;
            }
            header h1 {
                font-size: 1.5em;
            }
            nav button {
                padding: 12px 15px;
                font-size: 1em;
            }
            .content-section {
                padding: 20px;
            }
            .form-grid {
                grid-template-columns: 1fr;
            }
            .tournament-list {
                grid-template-columns: 1fr;
            }
            .tournament-detail-header {
                flex-direction: column;
                align-items: flex-start;
            }
            .tournament-detail-header .btn-group {
                width: 100%;
                justify-content: flex-start;
            }
            .bracket-visualizer {
                justify-content: flex-start;
            }
            .bracket-round-simple {
                margin-right: 20px;
            }
        }
    </style>
</head>
<body>
    <header>
        <h1>Ultimate Tournament Manager</h1>
        <button id="themeToggle" class="theme-toggle">💡</button>
    </header>

    <div class="container">
        <nav>
            <button id="navDashboard" class="active">Dashboard</button>
            <button id="navCreateTournament">Create Tournament</button>
            <button id="navImportExport">Import/Export</button>
        </nav>

        <main id="appContent">
            <!-- Dashboard Section -->
            <section id="dashboardSection" class="content-section">
                <h2>All Tournaments</h2>
                <div class="search-filter-bar">
                    <input type="text" id="tournamentSearch" placeholder="Search tournaments...">
                    <select id="tournamentFilterStatus">
                        <option value="">All Statuses</option>
                        <option value="Upcoming">Upcoming</option>
                        <option value="Active">Active</option>
                        <option value="Completed">Completed</option>
                    </select>
                    <select id="tournamentFilterSport">
                        <option value="">All Sports</option>
                        <option value="Football">Football</option>
                        <option value="Basketball">Basketball</option>
                        <option value="Tennis">Tennis</option>
                        <option value="Esports">Esports</option>
                        <option value="Chess">Chess</option>
                        <option value="Volleyball">Volleyball</option>
                        <option value="Badminton">Badminton</option>
                        <option value="Table Tennis">Table Tennis</option>
                        <option value="Cricket">Cricket</option>
                        <option value="Rugby">Rugby</option>
                        <option value="Hockey">Hockey</option>
                        <option value="Baseball">Baseball</option>
                        <option value="Softball">Softball</option>
                        <option value="Swimming">Swimming</option>
                        <option value="Athletics">Athletics</option>
                        <option value="Boxing">Boxing</option>
                        <option value="MMA">MMA</option>
                        <option value="Golf">Golf</option>
                        <option value="Darts">Darts</option>
                        <option value="Pool">Pool</option>
                        <option value="Other">Other</option>
                    </select>
                    <select id="tournamentFilterType">
                        <option value="">All Types</option>
                        <option value="Single Elimination">Single Elimination</option>
                        <option value="Double Elimination">Double Elimination</option>
                        <option value="Round Robin">Round Robin</option>
                        <option value="Multi-Stage">Multi-Stage</option>
                        <option value="Group Stage">Group Stage</option>
                        <option value="Swiss System">Swiss System</option>
                        <option value="GSL Format">GSL Format</option>
                        <option value="Ladder">Ladder</option>
                    </select>
                </div>
                <div id="tournamentList" class="tournament-list">
                    <p class="no-data">No tournaments created yet. Go to "Create Tournament" to get started!</p>
                </div>
            </section>

            <!-- Create Tournament Section -->
            <section id="createTournamentSection" class="content-section hidden">
                <h2>Create New Tournament</h2>
                <form id="createTournamentForm">
                    <div class="form-grid">
                        <div class="form-group">
                            <label for="tournamentName">Tournament Name <span style="color:red">*</span></label>
                            <input type="text" id="tournamentName" required>
                        </div>
                        <div class="form-group">
                            <label for="tournamentSport">Sport <span style="color:red">*</span></label>
                            <select id="tournamentSport" required>
                                <option value="">Select Sport</option>
                                <option value="Football">Football</option>
                                <option value="Basketball">Basketball</option>
                                <option value="Tennis">Tennis</option>
                                <option value="Esports">Esports</option>
                                <option value="Chess">Chess</option>
                                <option value="Volleyball">Volleyball</option>
                                <option value="Badminton">Badminton</option>
                                <option value="Table Tennis">Table Tennis</option>
                                <option value="Cricket">Cricket</option>
                                <option value="Rugby">Rugby</option>
                                <option value="Hockey">Hockey</option>
                                <option value="Baseball">Baseball</option>
                                <option value="Softball">Softball</option>
                                <option value="Swimming">Swimming</option>
                                <option value="Athletics">Athletics</option>
                                <option value="Boxing">Boxing</option>
                                <option value="MMA">MMA</option>
                                <option value="Golf">Golf</option>
                                <option value="Darts">Darts</option>
                                <option value="Pool">Pool</option>
                                <option value="Other">Other</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label for="tournamentType">Tournament Type <span style="color:red">*</span></label>
                            <select id="tournamentType" required>
                                <option value="">Select Type</option>
                                <option value="Single Elimination">Single Elimination</option>
                                <option value="Double Elimination">Double Elimination</option>
                                <option value="Round Robin">Round Robin</option>
                                <option value="Multi-Stage">Multi-Stage</option>
                                <option value="Group Stage">Group Stage</option>
                                <option value="Swiss System">Swiss System</option>
                                <option value="GSL Format">GSL Format</option>
                                <option value="Ladder">Ladder</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label for="tournamentStartDate">Start Date</label>
                            <input type="date" id="tournamentStartDate">
                        </div>
                        <div class="form-group">
                            <label for="tournamentEndDate">End Date</label>
                            <input type="date" id="tournamentEndDate">
                        </div>
                        <div class="form-group">
                            <label for="tournamentMaxParticipants">Max Participants (Teams)</label>
                            <input type="number" id="tournamentMaxParticipants" min="2" placeholder="Optional">
                        </div>
                        <div class="form-group">
                            <label for="tournamentEntryFee">Entry Fee ($)</label>
                            <input type="number" id="tournamentEntryFee" min="0" step="0.01" value="0">
                        </div>
                        <div class="form-group">
                            <label for="tournamentPrizePool">Prize Pool ($)</label>
                            <input type="number" id="tournamentPrizePool" min="0" step="0.01" value="0">
                        </div>
                    </div>
                    <div class="form-group">
                        <label for="tournamentDescription">Description</label>
                        <textarea id="tournamentDescription" rows="3"></textarea>
                    </div>

                    <div id="eliminationSettings" class="hidden">
                        <h3>Elimination Specific Settings</h3>
                        <div class="form-group">
                            <label for="tournamentBestOf">Best-of-N Series (e.g., 1 for single match, 3 for best of 3)</label>
                            <input type="number" id="tournamentBestOf" min="1" value="1">
                        </div>
                    </div>

                    <div class="checkbox-group">
                        <input type="checkbox" id="tournamentSetBasedScoring">
                        <label for="tournamentSetBasedScoring">Enable Set-Based Scoring (e.g., "3-0, 2-1")</label>
                    </div>

                    <div class="form-group">
                        <label for="tournamentPlayerStatsFields">Custom Player Stats Fields (comma-separated, e.g., Goals, Assists, Kills, Deaths)</label>
                        <input type="text" id="tournamentPlayerStatsFields" placeholder="e.g., Goals, Assists">
                    </div>

                    <div id="roundRobinSettings" class="hidden">
                        <h3>Round Robin Specific Settings</h3>
                        <div class="checkbox-group">
                            <input type="checkbox" id="rrEnableHomeAway">
                            <label for="rrEnableHomeAway">Enable Home/Away Games</label>
                        </div>
                        <div class="form-grid">
                            <div class="form-group">
                                <label for="rrPointsWin">Points for Win</label>
                                <input type="number" id="rrPointsWin" value="3" min="0">
                            </div>
                            <div class="form-group">
                                <label for="rrPointsDraw">Points for Draw</label>
                                <input type="number" id="rrPointsDraw" value="1" min="0">
                            </div>
                            <div class="form-group">
                                <label for="rrPointsLoss">Points for Loss</label>
                                <input type="number" id="rrPointsLoss" value="0" min="0">
                            </div>
                            <div class="form-group">
                                <label for="rrTieBreaker">Tie-breaker Preference</label>
                                <select id="rrTieBreaker">
                                    <option value="Points">Points (default)</option>
                                    <option value="Head-to-Head">Head-to-Head</option>
                                    <option value="Score Difference">Score Difference</option>
                                    <option value="Score For">Score For</option>
                                    <option value="Random">Random</option>
                                </select>
                            </div>
                        </div>
                    </div>

                    <div id="groupStageSettings" class="hidden">
                        <h3>Group Stage Specific Settings</h3>
                        <div class="form-grid">
                            <div class="form-group">
                                <label for="groupStageGroupsCount">Number of Groups <span style="color:red">*</span></label>
                                <input type="number" id="groupStageGroupsCount" min="1" value="4" required>
                            </div>
                            <div class="form-group">
                                <label for="groupStageAdvanceK">Teams to Advance per Group <span style="color:red">*</span></label>
                                <input type="number" id="groupStageAdvanceK" min="1" value="2" required>
                            </div>
                            <div class="form-group">
                                <label for="groupStagePointsWin">Points for Win</label>
                                <input type="number" id="groupStagePointsWin" value="3" min="0">
                            </div>
                            <div class="form-group">
                                <label for="groupStagePointsDraw">Points for Draw</label>
                                <input type="number" id="groupStagePointsDraw" value="1" min="0">
                            </div>
                            <div class="form-group">
                                <label for="groupStagePointsLoss">Points for Loss</label>
                                <input type="number" id="groupStagePointsLoss" value="0" min="0">
                            </div>
                            <div class="form-group">
                                <label for="groupStageTieBreaker">Tie-breaker Preference</label>
                                <select id="groupStageTieBreaker">
                                    <option value="Points">Points (default)</option>
                                    <option value="Head-to-Head">Head-to-Head</option>
                                    <option value="Score Difference">Score Difference</option>
                                    <option value="Score For">Score For</option>
                                    <option value="Random">Random</option>
                                </select>
                            </div>
                        </div>
                    </div>

                    <div id="multiStageSettings" class="hidden">
                        <h3>Multi-Stage Specific Settings (for initial Group Stage)</h3>
                        <div class="form-grid">
                            <div class="form-group">
                                <label for="multiStageGroupsCount">Number of Groups <span style="color:red">*</span></label>
                                <input type="number" id="multiStageGroupsCount" min="1" value="4" required>
                            </div>
                            <div class="form-group">
                                <label for="multiStageAdvanceK">Teams to Advance per Group <span style="color:red">*</span></label>
                                <input type="number" id="multiStageAdvanceK" min="1" value="2" required>
                            </div>
                            <div class="form-group">
                                <label for="multiStagePointsWin">Points for Win</label>
                                <input type="number" id="multiStagePointsWin" value="3" min="0">
                            </div>
                            <div class="form-group">
                                <label for="multiStagePointsDraw">Points for Draw</label>
                                <input type="number" id="multiStagePointsDraw" value="1" min="0">
                            </div>
                            <div class="form-group">
                                <label for="multiStagePointsLoss">Points for Loss</label>
                                <input type="number" id="multiStagePointsLoss" value="0" min="0">
                            </div>
                            <div class="form-group">
                                <label for="multiStageTieBreaker">Tie-breaker Preference</label>
                                <select id="multiStageTieBreaker">
                                    <option value="Points">Points (default)</option>
                                    <option value="Head-to-Head">Head-to-Head</option>
                                    <option value="Score Difference">Score Difference</option>
                                    <option value="Score For">Score For</option>
                                    <option value="Random">Random</option>
                                </select>
                            </div>
                        </div>
                        <h4>Knockout Stage Settings</h4>
                        <div class="form-group">
                            <label for="multiStageKnockoutBestOf">Best-of-N Series for Knockout Matches</label>
                            <input type="number" id="multiStageKnockoutBestOf" min="1" value="1">
                        </div>
                    </div>

                    <div id="swissSettings" class="hidden">
                        <h3>Swiss System Specific Settings</h3>
                        <div class="form-group">
                            <label for="swissRounds">Number of Rounds</label>
                            <input type="number" id="swissRounds" value="5" min="1">
                        </div>
                        <p><i>(Advanced pairing logic and tiebreakers not yet implemented)</i></p>
                    </div>

                    <div id="gslSettings" class="hidden">
                        <h3>GSL Format Specific Settings</h3>
                        <p><i>(GSL format logic not yet implemented)</i></p>
                    </div>

                    <div id="ladderSettings" class="hidden">
                        <h3>Ladder Specific Settings</h3>
                        <p><i>(Ladder format logic not yet implemented)</i></p>
                    </div>


                    <div class="btn-group">
                        <button type="submit" class="btn btn-primary">Create Tournament</button>
                        <button type="reset" class="btn btn-outline">Clear Form</button>
                    </div>
                </form>
            </section>

            <!-- Tournament Detail Section (Dynamically loaded) -->
            <section id="tournamentDetailSection" class="content-section hidden">
                <div class="tournament-detail-header">
                    <h2 id="detailTournamentName"></h2>
                    <div class="btn-group">
                        <button id="editTournamentBtn" class="btn btn-secondary">Edit Tournament</button>
                        <button id="deleteTournamentBtn" class="btn btn-danger">Delete Tournament</button>
                        <select id="changeTournamentStatus" class="btn btn-outline">
                            <option value="Upcoming">Set Upcoming</option>
                            <option value="Active">Set Active</option>
                            <option value="Completed">Set Completed</option>
                        </select>
                        <button id="showQrCodeBtn" class="btn btn-outline">Show QR Code</button>
                        <button id="backToDashboardBtn" class="btn btn-outline">Back to Dashboard</button>
                    </div>
                </div>

                <div class="tournament-info-grid" id="tournamentInfoDisplay">
                    <!-- Info items will be loaded here -->
                </div>

                <hr style="margin: 30px 0; border-color: var(--border-color);">

                <h3>Participants (Teams) (<span id="participantCount">0</span>/<span id="maxParticipants">∞</span>)</h3>
                <div class="flex-between" style="margin-bottom: 15px;">
                    <div class="flex-gap-10">
                        <button id="addParticipantBtn" class="btn btn-primary">Add Team</button>
                        <button id="bulkImportParticipantsBtn" class="btn btn-secondary">Bulk Import (CSV)</button>
                        <button id="copyParticipantsBtn" class="btn btn-secondary">Copy from Tournament</button>
                    </div>
                    <div class="flex-gap-10">
                        <button id="generateBracketBtn" class="btn btn-secondary hidden">Generate Bracket</button>
                        <button id="generateDoubleEliminationBracketBtn" class="btn btn-secondary hidden">Generate DE Bracket</button>
                        <button id="generateRoundRobinBtn" class="btn btn-secondary hidden">Generate Matches</button>
                        <button id="manageStagesBtn" class="btn btn-secondary hidden">Manage Stages</button>
                        <button id="generateGroupStageBtn" class="btn btn-secondary hidden">Generate Groups</button>
                        <!-- New buttons for future formats -->
                        <button id="generateSwissBtn" class="btn btn-secondary hidden">Generate Swiss Rounds</button>
                        <button id="generateGSLBtn" class="btn btn-secondary hidden">Generate GSL Group</button>
                        <button id="manageLadderBtn" class="btn btn-secondary hidden">Manage Ladder</button>
                    </div>
                </div>
                <div id="participantsList" class="participants-list">
                    <p class="no-data">No teams added yet.</p>
                </div>

                <hr style="margin: 30px 0; border-color: var(--border-color);">

                <div id="eliminationBracketSection" class="hidden">
                    <h3>Bracket</h3>
                    <div id="bracketVisualizer" class="bracket-visualizer">
                        <p class="no-data">Bracket not generated. Add teams and click "Generate Bracket".</p>
                    </div>
                </div>

                <div id="doubleEliminationBracketSection" class="hidden">
                    <h3>Double Elimination Bracket</h3>
                    <div id="doubleEliminationWrapper" class="double-elimination-wrapper">
                        <p class="no-data">Double Elimination Bracket not generated. Add teams and click "Generate DE Bracket".</p>
                    </div>
                </div>

                <div id="roundRobinMatchesSection" class="hidden">
                    <h3>Matches</h3>
                    <div id="roundRobinMatches">
                        <p class="no-data">Matches not generated. Add teams and click "Generate Matches".</p>
                    </div>
                    <h3 style="margin-top: 30px;">Team Standings</h3>
                    <div id="roundRobinStandings">
                        <p class="no-data">Standings will appear after matches are generated and scores recorded.</p>
                    </div>
                </div>

                <div id="multiStageContainer" class="hidden">
                    <h3>Tournament Stages</h3>
                    <div id="stagesList">
                        <p class="no-data">No stages defined. Click "Manage Stages" to add them.</p>
                    </div>
                </div>

                <div id="groupStageSection" class="hidden">
                    <h3>Groups</h3>
                    <div id="groupsDisplay">
                        <p class="no-data">Groups not generated. Add teams and click "Generate Groups".</p>
                    </div>
                    <h3 style="margin-top: 30px;">Team Standings</h3>
                    <div id="groupStageStandingsDisplay">
                        <p class="no-data">Team standings will appear after matches are played.</p>
                    </div>
                </div>

                <div id="playerLeaderboardsSection" class="hidden">
                    <h3 style="margin-top: 30px;">Player Leaderboards</h3>
                    <div id="playerLeaderboardsDisplay">
                        <p class="no-data">Player stats will appear after matches are played and player stats are recorded.</p>
                    </div>
                </div>

                <!-- Placeholders for future tournament types -->
                <div id="swissSection" class="hidden">
                    <h3>Swiss System Rounds</h3>
                    <div id="swissRoundsDisplay">
                        <p class="no-data">Swiss rounds not generated.</p>
                    </div>
                    <h3 style="margin-top: 30px;">Swiss Standings</h3>
                    <div id="swissStandingsDisplay">
                        <p class="no-data">Swiss standings will appear after rounds are generated and scores recorded.</p>
                    </div>
                </div>

                <div id="gslSection" class="hidden">
                    <h3>GSL Groups</h3>
                    <div id="gslGroupsDisplay">
                        <p class="no-data">GSL groups not generated.</p>
                    </div>
                </div>

                <div id="ladderSection" class="hidden">
                    <h3>Ladder Rankings</h3>
                    <div id="ladderRankingsDisplay">
                        <p class="no-data">Ladder not initialized.</p>
                    </div>
                </div>

            </section>

            <!-- Import/Export Section -->
            <section id="importExportSection" class="content-section hidden">
                <h2>Import / Export Data</h2>
                <div class="form-group">
                    <label>Export All Tournament Data</label>
                    <button id="exportDataBtn" class="btn btn-primary">Download Data (JSON)</button>
                    <p style="font-size: 0.9em; margin-top: 5px; opacity: 0.8;">This will download all your tournament data as a JSON file.</p>
                </div>
                <hr style="margin: 30px 0; border-color: var(--border-color);">
                <div class="form-group">
                    <label for="importFileInput">Import Tournament Data</label>
                    <input type="file" id="importFileInput" accept=".json">
                    <button id="importDataBtn" class="btn btn-secondary" style="margin-top: 10px;">Upload & Import Data</button>
                    <p style="font-size: 0.9em; margin-top: 5px; opacity: 0.8;">Upload a JSON file to restore or add tournament data. Existing tournaments with the same ID will be overwritten.</p>
                </div>
            </section>
        </main>
    </div>

    <footer>
        <p>&copy; 2023 Ultimate Tournament Manager. All data saved locally in your browser.</p>
    </footer>

    <!-- Modals -->

    <!-- Add/Edit Participant (Team) Modal -->
    <div id="participantModal" class="modal">
        <div class="modal-content">
            <span class="close-button" onclick="closeModal('participantModal')">&times;</span>
            <h3 id="participantModalTitle">Add Team</h3>
            <form id="participantForm">
                <input type="hidden" id="participantId">
                <div class="form-group">
                    <label for="participantName">Team Name <span style="color:red">*</span></label>
                    <input type="text" id="participantName" required>
                </div>
                <div class="form-group">
                    <label for="participantSeed">Seed (lower number = higher seed, for Elimination brackets)</label>
                    <input type="number" id="participantSeed" min="1" placeholder="Optional">
                </div>
                <div class="form-group">
                    <label for="participantRating">Rating (e.g., Elo, for Swiss/Ladder)</label>
                    <input type="number" id="participantRating" placeholder="Optional">
                </div>
                <div class="form-group">
                    <label for="participantContact">Contact Info</label>
                    <input type="text" id="participantContact" placeholder="Email, Phone, etc.">
                </div>
                <div class="form-group">
                    <label for="participantNotes">Notes</label>
                    <textarea id="participantNotes" rows="2"></textarea>
                </div>
                <div class="btn-group">
                    <button type="submit" class="btn btn-primary">Save Team</button>
                    <button type="button" class="btn btn-secondary" id="managePlayersBtnForTeam">Manage Players</button>
                    <button type="button" class="btn btn-outline" onclick="closeModal('participantModal')">Cancel</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Manage Players Modal -->
    <div id="managePlayersModal" class="modal">
        <div class="modal-content">
            <span class="close-button" onclick="closeModal('managePlayersModal')">&times;</span>
            <h3 id="managePlayersModalTitle">Manage Players for [Team Name]</h3>
            <input type="hidden" id="managePlayersTeamId">
            <div id="playersList" class="participants-list" style="max-height: 300px; overflow-y: auto; border: 1px solid var(--border-color); padding: 10px; border-radius: var(--radius);">
                <p class="no-data">No players added to this team yet.</p>
            </div>
            <div class="btn-group">
                <button id="addPlayerBtn" class="btn btn-primary">Add Player</button>
                <button type="button" class="btn btn-outline" onclick="closeModal('managePlayersModal')">Done</button>
            </div>
        </div>
    </div>

    <!-- Add/Edit Player Modal -->
    <div id="addEditPlayerModal" class="modal">
        <div class="modal-content">
            <span class="close-button" onclick="closeModal('addEditPlayerModal')">&times;</span>
            <h3 id="addEditPlayerModalTitle">Add Player</h3>
            <form id="addEditPlayerForm">
                <input type="hidden" id="addEditPlayerTeamId">
                <input type="hidden" id="addEditPlayerId">
                <div class="form-group">
                    <label for="playerName">Player Name <span style="color:red">*</span></label>
                    <input type="text" id="playerName" required>
                </div>
                <div id="playerInitialStats" class="form-grid">
                    <!-- Dynamic fields for custom player stats -->
                </div>
                <div class="btn-group">
                    <button type="submit" class="btn btn-primary">Save Player</button>
                    <button type="button" class="btn btn-outline" onclick="closeModal('addEditPlayerModal')">Cancel</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Edit Tournament Modal -->
    <div id="editTournamentModal" class="modal">
        <div class="modal-content">
            <span class="close-button" onclick="closeModal('editTournamentModal')">&times;</span>
            <h3>Edit Tournament</h3>
            <form id="editTournamentForm">
                <input type="hidden" id="editTournamentId">
                <div class="form-grid">
                    <div class="form-group">
                        <label for="editTournamentName">Tournament Name <span style="color:red">*</span></label>
                        <input type="text" id="editTournamentName" required>
                    </div>
                    <div class="form-group">
                        <label for="editTournamentSport">Sport <span style="color:red">*</span></label>
                        <select id="editTournamentSport" required>
                            <option value="Football">Football</option>
                            <option value="Basketball">Basketball</option>
                            <option value="Tennis">Tennis</option>
                            <option value="Esports">Esports</option>
                            <option value="Chess">Chess</option>
                            <option value="Volleyball">Volleyball</option>
                            <option value="Badminton">Badminton</option>
                            <option value="Table Tennis">Table Tennis</option>
                            <option value="Cricket">Cricket</option>
                            <option value="Rugby">Rugby</option>
                            <option value="Hockey">Hockey</option>
                            <option value="Baseball">Baseball</option>
                            <option value="Softball">Softball</option>
                            <option value="Swimming">Swimming</option>
                            <option value="Athletics">Athletics</option>
                            <option value="Boxing">Boxing</option>
                            <option value="MMA">MMA</option>
                            <option value="Golf">Golf</option>
                            <option value="Darts">Darts</option>
                            <option value="Pool">Pool</option>
                            <option value="Other">Other</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label for="editTournamentType">Tournament Type <span style="color:red">*</span></label>
                        <select id="editTournamentType" required disabled>
                            <option value="Single Elimination">Single Elimination</option>
                            <option value="Double Elimination">Double Elimination</option>
                            <option value="Round Robin">Round Robin</option>
                            <option value="Multi-Stage">Multi-Stage</option>
                            <option value="Group Stage">Group Stage</option>
                            <option value="Swiss System">Swiss System</option>
                            <option value="GSL Format">GSL Format</option>
                            <option value="Ladder">Ladder</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label for="editTournamentStartDate">Start Date</label>
                        <input type="date" id="editTournamentStartDate">
                    </div>
                    <div class="form-group">
                        <label for="editTournamentEndDate">End Date</label>
                        <input type="date" id="editTournamentEndDate">
                    </div>
                    <div class="form-group">
                        <label for="editTournamentMaxParticipants">Max Participants (Teams)</label>
                        <input type="number" id="editTournamentMaxParticipants" min="2">
                    </div>
                    <div class="form-group">
                        <label for="editTournamentEntryFee">Entry Fee ($)</label>
                        <input type="number" id="editTournamentEntryFee" min="0" step="0.01">
                    </div>
                    <div class="form-group">
                        <label for="editTournamentPrizePool">Prize Pool ($)</label>
                        <input type="number" id="editTournamentPrizePool" min="0" step="0.01">
                    </div>
                </div>
                <div class="form-group">
                    <label for="editTournamentDescription">Description</label>
                    <textarea id="editTournamentDescription" rows="3"></textarea>
                </div>

                <div id="editEliminationSettings" class="hidden">
                    <h3>Elimination Specific Settings</h3>
                    <div class="form-group">
                        <label for="editTournamentBestOf">Best-of-N Series (e.g., 1 for single match, 3 for best of 3)</label>
                        <input type="number" id="editTournamentBestOf" min="1">
                    </div>
                </div>

                <div class="checkbox-group">
                    <input type="checkbox" id="editTournamentSetBasedScoring">
                    <label for="editTournamentSetBasedScoring">Enable Set-Based Scoring (e.g., "3-0, 2-1")</label>
                </div>

                <div class="form-group">
                    <label for="editTournamentPlayerStatsFields">Custom Player Stats Fields (comma-separated, e.g., Goals, Assists, Kills, Deaths)</label>
                    <input type="text" id="editTournamentPlayerStatsFields" placeholder="e.g., Goals, Assists">
                </div>

                <div id="editRoundRobinSettings" class="hidden">
                    <h3>Round Robin Specific Settings</h3>
                    <div class="checkbox-group">
                        <input type="checkbox" id="editRrEnableHomeAway">
                        <label for="editRrEnableHomeAway">Enable Home/Away Games</label>
                    </div>
                    <div class="form-grid">
                        <div class="form-group">
                            <label for="editRrPointsWin">Points for Win</label>
                            <input type="number" id="editRrPointsWin" min="0">
                        </div>
                        <div class="form-group">
                            <label for="editRrPointsDraw">Points for Draw</label>
                            <input type="number" id="editRrPointsDraw" min="0">
                        </div>
                        <div class="form-group">
                            <label for="editRrPointsLoss">Points for Loss</label>
                            <input type="number" id="editRrPointsLoss" min="0">
                        </div>
                        <div class="form-group">
                            <label for="editRrTieBreaker">Tie-breaker Preference</label>
                            <select id="editRrTieBreaker">
                                <option value="Points">Points (default)</option>
                                <option value="Head-to-Head">Head-to-Head</option>
                                <option value="Score Difference">Score Difference</option>
                                <option value="Score For">Score For</option>
                                <option value="Random">Random</option>
                            </select>
                        </div>
                    </div>
                </div>

                <div id="editGroupStageSettings" class="hidden">
                    <h3>Group Stage Specific Settings</h3>
                    <div class="form-grid">
                        <div class="form-group">
                            <label for="editGroupStageGroupsCount">Number of Groups <span style="color:red">*</span></label>
                            <input type="number" id="editGroupStageGroupsCount" min="1" required>
                        </div>
                        <div class="form-group">
                            <label for="editGroupStageAdvanceK">Teams to Advance per Group <span style="color:red">*</span></label>
                            <input type="number" id="editGroupStageAdvanceK" min="1" required>
                        </div>
                        <div class="form-group">
                            <label for="editGroupStagePointsWin">Points for Win</label>
                            <input type="number" id="editGroupStagePointsWin" min="0">
                        </div>
                        <div class="form-group">
                            <label for="editGroupStagePointsDraw">Points for Draw</label>
                            <input type="number" id="editGroupStagePointsDraw" min="0">
                        </div>
                        <div class="form-group">
                            <label for="editGroupStagePointsLoss">Points for Loss</label>
                            <input type="number" id="editGroupStagePointsLoss" min="0">
                        </div>
                        <div class="form-group">
                            <label for="editGroupStageTieBreaker">Tie-breaker Preference</label>
                            <select id="editGroupStageTieBreaker">
                                <option value="Points">Points (default)</option>
                                <option value="Head-to-Head">Head-to-Head</option>
                                <option value="Score Difference">Score Difference</option>
                                <option value="Score For">Score For</option>
                                <option value="Random">Random</option>
                            </select>
                        </div>
                    </div>
                </div>

                <div id="editMultiStageSettings" class="hidden">
                    <h3>Multi-Stage Specific Settings (for initial Group Stage)</h3>
                    <div class="form-grid">
                        <div class="form-group">
                            <label for="editMultiStageGroupsCount">Number of Groups <span style="color:red">*</span></label>
                            <input type="number" id="editMultiStageGroupsCount" min="1" required>
                        </div>
                        <div class="form-group">
                            <label for="editMultiStageAdvanceK">Teams to Advance per Group <span style="color:red">*</span></label>
                            <input type="number" id="editMultiStageAdvanceK" min="1" required>
                        </div>
                        <div class="form-group">
                            <label for="editMultiStagePointsWin">Points for Win</label>
                            <input type="number" id="editMultiStagePointsWin" min="0">
                        </div>
                        <div class="form-group">
                            <label for="editMultiStagePointsDraw">Points for Draw</label>
                            <input type="number" id="editMultiStagePointsDraw" min="0">
                        </div>
                        <div class="form-group">
                            <label for="editMultiStagePointsLoss">Points for Loss</label>
                            <input type="number" id="editMultiStagePointsLoss" min="0">
                        </div>
                        <div class="form-group">
                            <label for="editMultiStageTieBreaker">Tie-breaker Preference</label>
                            <select id="editMultiStageTieBreaker">
                                <option value="Points">Points (default)</option>
                                <option value="Head-to-Head">Head-to-Head</option>
                                <option value="Score Difference">Score Difference</option>
                                <option value="Score For">Score For</option>
                                <option value="Random">Random</option>
                            </select>
                        </div>
                    </div>
                    <h4>Knockout Stage Settings</h4>
                    <div class="form-group">
                        <label for="editMultiStageKnockoutBestOf">Best-of-N Series for Knockout Matches</label>
                        <input type="number" id="editMultiStageKnockoutBestOf" min="1">
                    </div>
                </div>

                <div id="editSwissSettings" class="hidden">
                    <h3>Swiss System Specific Settings</h3>
                    <div class="form-group">
                        <label for="editSwissRounds">Number of Rounds</label>
                        <input type="number" id="editSwissRounds" min="1">
                    </div>
                    <p><i>(Advanced pairing logic and tiebreakers not yet implemented)</i></p>
                </div>

                <div id="editGslSettings" class="hidden">
                    <h3>GSL Format Specific Settings</h3>
                    <p><i>(GSL format logic not yet implemented)</i></p>
                </div>

                <div id="editLadderSettings" class="hidden">
                    <h3>Ladder Specific Settings</h3>
                    <p><i>(Ladder format logic not yet implemented)</i></p>
                </div>

                <div class="btn-group">
                    <button type="submit" class="btn btn-primary">Save Changes</button>
                    <button type="button" class="btn btn-outline" onclick="closeModal('editTournamentModal')">Cancel</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Bulk Import Participants Modal -->
    <div id="bulkImportModal" class="modal">
        <div class="modal-content">
            <span class="close-button" onclick="closeModal('bulkImportModal')">&times;</span>
            <h3>Bulk Import Teams (CSV)</h3>
            <p>Upload a CSV file with team names. Each name should be on a new line.</p>
            <div class="form-group">
                <label for="bulkImportFileInput">Select CSV File</label>
                <input type="file" id="bulkImportFileInput" accept=".csv">
            </div>
            <div class="btn-group">
                <button id="processBulkImportBtn" class="btn btn-primary">Import Teams</button>
                <button type="button" class="btn btn-outline" onclick="closeModal('bulkImportModal')">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Copy Participants Modal -->
    <div id="copyParticipantsModal" class="modal">
        <div class="modal-content">
            <span class="close-button" onclick="closeModal('copyParticipantsModal')">&times;</span>
            <h3>Copy Teams from Another Tournament</h3>
            <div class="form-group">
                <label for="copyFromTournamentSelect">Select Tournament to Copy From</label>
                <select id="copyFromTournamentSelect">
                    <option value="">-- Select a Tournament --</option>
                </select>
            </div>
            <div class="btn-group">
                <button id="processCopyParticipantsBtn" class="btn btn-primary">Copy Teams</button>
                <button type="button" class="btn btn-outline" onclick="closeModal('copyParticipantsModal')">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Match Details Modal (for editing schedule/stats) -->
    <div id="matchDetailsModal" class="modal">
        <div class="modal-content">
            <span class="close-button" onclick="closeModal('matchDetailsModal')">&times;</span>
            <h3 id="matchDetailsModalTitle">Match Details</h3>
            <form id="matchDetailsForm">
                <input type="hidden" id="matchDetailsMatchId">
                <input type="hidden" id="matchDetailsRoundIndex">
                <input type="hidden" id="matchDetailsBracketType"> <!-- 'rounds', 'winnerBracket', 'loserBracket', 'grandFinal', 'matches', 'groupMatches' -->
                <input type="hidden" id="matchDetailsStageId"> <!-- For multi-stage tournaments -->
                <input type="hidden" id="matchDetailsGroupId"> <!-- For group stage tournaments -->

                <div class="form-grid">
                    <div class="form-group">
                        <label for="matchDetailsPlayer1">Team 1</label>
                        <input type="text" id="matchDetailsPlayer1" disabled>
                    </div>
                    <div class="form-group">
                        <label for="matchDetailsPlayer2">Team 2</label>
                        <input type="text" id="matchDetailsPlayer2" disabled>
                    </div>
                    <div class="form-group">
                        <label for="matchDetailsBestOf">Best-of-N</label>
                        <input type="number" id="matchDetailsBestOf" min="1">
                    </div>
                    <div class="form-group">
                        <label for="matchDetailsDate">Date</label>
                        <input type="date" id="matchDetailsDate">
                    </div>
                    <div class="form-group">
                        <label for="matchDetailsTime">Time</label>
                        <input type="time" id="matchDetailsTime">
                    </div>
                    <div class="form-group">
                        <label for="matchDetailsVenue">Venue</label>
                        <input type="text" id="matchDetailsVenue" placeholder="e.g., Main Arena">
                    </div>
                    <div class="form-group">
                        <label for="matchDetailsReferee">Referee</label>
                        <input type="text" id="matchDetailsReferee" placeholder="e.g., John Doe">
                    </div>
                </div>

                <div id="matchDetailsPlayerStats" style="margin-top: 20px;">
                    <h4>Individual Player Stats for this Match</h4>
                    <div id="team1PlayerStatsInputs"></div>
                    <div id="team2PlayerStatsInputs"></div>
                </div>

                <div class="btn-group">
                    <button type="submit" class="btn btn-primary">Save Match Details</button>
                    <button type="button" class="btn btn-outline" onclick="closeModal('matchDetailsModal')">Cancel</button>
                </div>
            </form>
        </div>
    </div>

    <!-- QR Code Modal -->
    <div id="qrCodeModal" class="modal">
        <div class="modal-content text-center">
            <span class="close-button" onclick="closeModal('qrCodeModal')">&times;</span>
            <h3>Tournament QR Code</h3>
            <p>Scan this QR code to quickly identify this tournament (e.g., for sharing its ID).</p>
            <div id="qrCodeContainer" style="margin: 20px auto; width: 200px; height: 200px;"></div>
            <p style="font-size: 0.9em; opacity: 0.8;">Tournament ID: <span id="qrTournamentId"></span></p>
        </div>
    </div>

    <!-- Manage Stages Modal -->
    <div id="manageStagesModal" class="modal">
        <div class="modal-content">
            <span class="close-button" onclick="closeModal('manageStagesModal')">&times;</span>
            <h3>Manage Stages</h3>
            <div id="currentStagesList">
                <p class="no-data">No stages added yet.</p>
            </div>
            <div class="btn-group" id="manageStagesActions">
                <button id="addStageBtn" class="btn btn-primary">Add New Stage</button>
            </div>
        </div>
    </div>

    <!-- Add/Edit Stage Modal -->
    <div id="stageModal" class="modal">
        <div class="modal-content">
            <span class="close-button" onclick="closeModal('stageModal')">&times;</span>
            <h3 id="stageModalTitle">Add Stage</h3>
            <form id="stageForm">
                <input type="hidden" id="stageId">
                <div class="form-group">
                    <label for="stageName">Stage Name <span style="color:red">*</span></label>
                    <input type="text" id="stageName" required>
                </div>
                <div class="form-group">
                    <label for="stageType">Stage Type <span style="color:red">*</span></label>
                    <select id="stageType" required>
                        <option value="">Select Type</option>
                        <option value="Single Elimination">Single Elimination</option>
                        <option value="Round Robin">Round Robin</option>
                        <option value="Group Stage">Group Stage</option>
                    </select>
                </div>

                <div id="stageEliminationSettings" class="hidden">
                    <h4>Elimination Specific Settings</h4>
                    <div class="form-group">
                        <label for="stageBestOf">Best-of-N Series</label>
                        <input type="number" id="stageBestOf" min="1" value="1">
                    </div>
                </div>

                <div id="stageRoundRobinSettings" class="hidden">
                    <h4>Round Robin Specific Settings</h4>
                    <div class="checkbox-group">
                        <input type="checkbox" id="stageRrEnableHomeAway">
                        <label for="stageRrEnableHomeAway">Enable Home/Away Games</label>
                    </div>
                    <div class="form-grid">
                        <div class="form-group">
                            <label for="stageRrPointsWin">Points for Win</label>
                            <input type="number" id="stageRrPointsWin" value="3" min="0">
                        </div>
                        <div class="form-group">
                            <label for="stageRrPointsDraw">Points for Draw</label>
                            <input type="number" id="stageRrPointsDraw" value="1" min="0">
                        </div>
                        <div class="form-group">
                            <label for="stageRrPointsLoss">Points for Loss</label>
                            <input type="number" id="stageRrPointsLoss" value="0" min="0">
                        </div>
                        <div class="form-group">
                            <label for="stageRrTieBreaker">Tie-breaker Preference</label>
                            <select id="stageRrTieBreaker">
                                <option value="Points">Points (default)</option>
                                <option value="Head-to-Head">Head-to-Head</option>
                                <option value="Score Difference">Score Difference</option>
                                <option value="Score For">Score For</option>
                                <option value="Random">Random</option>
                            </select>
                        </div>
                    </div>
                </div>

                <div id="stageGroupStageSettings" class="hidden">
                    <h4>Group Stage Specific Settings</h4>
                    <div class="form-grid">
                        <div class="form-group">
                            <label for="stageGroupStageGroupsCount">Number of Groups <span style="color:red">*</span></label>
                            <input type="number" id="stageGroupStageGroupsCount" min="1" value="4" required>
                        </div>
                        <div class="form-group">
                            <label for="stageGroupStageAdvanceK">Teams to Advance per Group <span style="color:red">*</span></label>
                            <input type="number" id="stageGroupStageAdvanceK" min="1" value="2" required>
                        </div>
                        <div class="form-group">
                            <label for="stageGroupStagePointsWin">Points for Win</label>
                            <input type="number" id="stageGroupStagePointsWin" value="3" min="0">
                        </div>
                        <div class="form-group">
                            <label for="stageGroupStagePointsDraw">Points for Draw</label>
                            <input type="number" id="stageGroupStagePointsDraw" value="1" min="0">
                        </div>
                        <div class="form-group">
                            <label for="stageGroupStagePointsLoss">Points for Loss</label>
                            <input type="number" id="stageGroupStagePointsLoss" value="0" min="0">
                        </div>
                        <div class="form-group">
                            <label for="stageGroupStageTieBreaker">Tie-breaker Preference</label>
                            <select id="stageGroupStageTieBreaker">
                                <option value="Points">Points (default)</option>
                                <option value="Head-to-Head">Head-to-Head</option>
                                <option value="Score Difference">Score Difference</option>
                                <option value="Score For">Score For</option>
                                <option value="Random">Random</option>
                            </select>
                        </div>
                    </div>
                </div>

                <div class="btn-group">
                    <button type="submit" class="btn btn-primary">Save Stage</button>
                    <button type="button" class="btn btn-outline" onclick="closeModal('stageModal')">Cancel</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Advance Participants Modal -->
    <div id="advanceParticipantsModal" class="modal">
        <div class="modal-content">
            <span class="close-button" onclick="closeModal('advanceParticipantsModal')">&times;</span>
            <h3>Add Teams to Stage</h3>
            <p>Select teams from the tournament's overall team list to add to this stage.</p>
            <input type="hidden" id="advanceStageId">
            <div id="availableParticipantsList" class="participants-list" style="max-height: 300px; overflow-y: auto; border: 1px solid var(--border-color); padding: 10px; border-radius: var(--radius);">
                <!-- Checkboxes for participants -->
            </div>
            <div class="btn-group">
                <button id="processAdvanceParticipantsBtn" class="btn btn-primary">Add Selected Teams</button>
                <button type="button" class="btn btn-outline" onclick="closeModal('advanceParticipantsModal')">Cancel</button>
            </div>
        </div>
    </div>

    <script>
        // --- Inlined QR Code Generator (qrious.js - simplified for single file) ---
        // This is a very basic, self-contained QR code generator.
        // For more robust features, a full library would be used.
        // Source: https://github.com/neocult/qrious (simplified)
        (function() {
            function QRCode(options) {
                options = options || {};
                this.value = options.value || '';
                this.size = options.size || 100;
                this.level = options.level || 'L'; // L, M, Q, H
                this.background = options.background || '#ffffff';
                this.foreground = options.foreground || '#000000';
                this.element = options.element || null;

                this.canvas = document.createElement('canvas');
                this.canvas.width = this.size;
                this.canvas.height = this.size;
                this.context = this.canvas.getContext('2d');

                if (this.element) {
                    this.element.appendChild(this.canvas);
                }

                this.update = function() {
                    if (!this.value) {
                        this.context.clearRect(0, 0, this.size, this.size);
                        return;
                    }

                    // Simplified QR code generation (not a full QR library)
                    // This will just draw a simple pattern for demonstration.
                    // A real QR code library would involve complex encoding.
                    // For this single HTML file, we'll draw a placeholder.
                    this.context.fillStyle = this.background;
                    this.context.fillRect(0, 0, this.size, this.size);
                    this.context.fillStyle = this.foreground;

                    const cellSize = this.size / 10; // Simple grid
                    for (let i = 0; i < 10; i++) {
                        for (let j = 0; j < 10; j++) {
                            if ((i + j) % 2 === 0) {
                                this.context.fillRect(i * cellSize, j * cellSize, cellSize, cellSize);
                            }
                            // Add a simple "ID" text in the middle for visual confirmation
                            if (i === 4 && j === 4) {
                                this.context.fillStyle = this.background;
                                this.context.fillRect(this.size/4, this.size/2 - this.size/10, this.size/2, this.size/5);
                                this.context.fillStyle = this.foreground;
                                this.context.font = `${this.size / 8}px Arial`;
                                this.context.textAlign = 'center';
                                this.context.textBaseline = 'middle';
                                this.context.fillText("ID", this.size / 2, this.size / 2);
                            }
                        }
                    }
                    // End of simplified placeholder

                    // If you want a real QR code, you'd need a full library here.
                    // Example with a real library (if you were to include it):
                    /*
                    const qr = new QRious({
                        value: this.value,
                        size: this.size,
                        level: this.level,
                        background: this.background,
                        foreground: this.foreground
                    });
                    this.context.drawImage(qr.canvas, 0, 0);
                    */
                };
                this.update();
            }

            window.QRCode = QRCode;
        })();
        // --- End Inlined QR Code Generator ---


        // --- Global State & Constants ---
        const LS_KEY = 'tournamentManagerData';
        const LS_THEME_KEY = 'tournamentManagerTheme';
        let tournaments = [];
        let currentTournamentId = null;
        let currentTeamIdForPlayers = null; // New: To track which team's players are being managed

        const TOURNAMENT_TYPES = {
            SINGLE_ELIMINATION: 'Single Elimination',
            DOUBLE_ELIMINATION: 'Double Elimination',
            ROUND_ROBIN: 'Round Robin',
            MULTI_STAGE: 'Multi-Stage',
            GROUP_STAGE: 'Group Stage',
            SWISS_SYSTEM: 'Swiss System',
            GSL_FORMAT: 'GSL Format',
            LADDER: 'Ladder'
        };

        const TOURNAMENT_STATUS = {
            UPCOMING: 'Upcoming',
            ACTIVE: 'Active',
            COMPLETED: 'Completed'
        };

        // --- Utility Functions ---
        function generateUniqueId() {
            return Date.now().toString(36) + Math.random().toString(36).substr(2, 5);
        }

        function saveData() {
            localStorage.setItem(LS_KEY, JSON.stringify(tournaments));
        }

        function loadData() {
            const data = localStorage.getItem(LS_KEY);
            tournaments = data ? JSON.parse(data) : [];
            // Ensure new fields are initialized for old data
            tournaments.forEach(t => {
                if (!t.groups) t.groups = [];
                if (!t.swissRounds) t.swissRounds = [];
                if (!t.gslGroups) t.gslGroups = [];
                if (!t.ladderRanks) t.ladderRanks = [];
                if (!t.settings) t.settings = {}; // Ensure settings object exists
                if (!t.settings.groupStage) t.settings.groupStage = {};
                if (!t.settings.multiStage) t.settings.multiStage = {}; // New for Multi-Stage settings
                if (!t.settings.playerStatsFields) t.settings.playerStatsFields = [];
                if (t.settings.setBasedScoring === undefined) t.settings.setBasedScoring = false;
                if (t.settings.bestOf === undefined) t.settings.bestOf = 1;


                t.participants.forEach(p => {
                    if (!p.teamStats) {
                        p.teamStats = { matchesPlayed: 0, custom: {} };
                    }
                    // Ensure custom stats object exists for teamStats
                    if (!p.teamStats.custom) p.teamStats.custom = {};
                    t.settings.playerStatsFields.forEach(field => {
                        if (p.teamStats.custom[field] === undefined) p.teamStats.custom[field] = 0;
                    });

                    if (!p.players) {
                        p.players = [];
                    }
                    p.players.forEach(player => {
                        if (!player.stats) {
                            player.stats = { matchesPlayed: 0, custom: {} };
                        }
                        // Ensure custom stats object exists for player stats
                        if (!player.stats.custom) player.stats.custom = {};
                        t.settings.playerStatsFields.forEach(field => {
                            if (player.stats.custom[field] === undefined) player.stats.custom[field] = 0;
                        });
                    });
                });

                // Initialize new match stats structure for old matches and ensure stage/group IDs are present
                const initializeMatch = (m, stageId = null, groupId = null) => {
                    if (!m.team1MatchPlayerStats) m.team1MatchPlayerStats = [];
                    if (!m.team2MatchPlayerStats) m.team2MatchPlayerStats = [];
                    if (m.stageId === undefined && stageId !== null) m.stageId = stageId; // Set stageId if not present
                    if (m.groupId === undefined && groupId !== null) m.groupId = groupId; // Set groupId if not present
                    // Remove old player1Stats/player2Stats if they exist and are not arrays
                    if (m.player1Stats && !Array.isArray(m.player1Stats)) delete m.player1Stats;
                    if (m.player2Stats && !Array.isArray(m.player2Stats)) delete m.player2Stats;
                };

                if (t.rounds) t.rounds.forEach(r => r.matches.forEach(m => initializeMatch(m)));
                if (t.winnerBracket) t.winnerBracket.forEach(r => r.matches.forEach(m => initializeMatch(m)));
                if (t.loserBracket) t.loserBracket.forEach(r => r.matches.forEach(m => initializeMatch(m)));
                if (t.grandFinal) t.grandFinal.forEach(r => r.matches.forEach(m => initializeMatch(m)));
                if (t.matches) t.matches.forEach(m => initializeMatch(m));
                if (t.groups) t.groups.forEach(g => g.matches.forEach(m => initializeMatch(m, null, g.id)));
                if (t.stages) t.stages.forEach(s => {
                    if (s.matches) s.matches.forEach(m => initializeMatch(m, s.id));
                    if (s.rounds) s.rounds.forEach(r => r.matches.forEach(m => initializeMatch(m, s.id)));
                    if (s.groups) s.groups.forEach(g => g.matches.forEach(m => initializeMatch(m, s.id, g.id)));
                });
            });
            renderTournamentList();
        }

        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        function showSection(sectionId) {
            document.querySelectorAll('.content-section').forEach(section => {
                section.classList.add('hidden');
            });
            const targetSection = document.getElementById(sectionId);
            if (targetSection) {
                targetSection.classList.remove('hidden');
            }

            document.querySelectorAll('nav button').forEach(btn => {
                btn.classList.remove('active');
            });

            // Only activate nav buttons for primary sections
            const primaryNavSections = ['dashboardSection', 'createTournamentSection', 'importExportSection'];
            if (primaryNavSections.includes(sectionId)) {
                const navButtonId = `nav${sectionId.replace('Section', '')}`;
                const navButton = document.getElementById(navButtonId);
                if (navButton) {
                    navButton.classList.add('active');
                }
            }
        }

        function showAlert(message, type = 'success') {
            const alertDiv = document.createElement('div');
            alertDiv.className = `alert alert-${type}`;
            alertDiv.textContent = message;
            document.querySelector('.container').prepend(alertDiv);
            setTimeout(() => alertDiv.remove(), 5000);
        }

        function openModal(modalId) {
            document.getElementById(modalId).style.display = 'block';
        }

        function closeModal(modalId) {
            document.getElementById(modalId).style.display = 'none';
        }

        // --- Theme Toggle ---
        function applyTheme(theme) {
            document.body.classList.toggle('dark-mode', theme === 'dark');
            localStorage.setItem(LS_THEME_KEY, theme);
        }

        function toggleTheme() {
            const currentTheme = localStorage.getItem(LS_THEME_KEY) || 'light';
            applyTheme(currentTheme === 'light' ? 'dark' : 'light');
        }

        // --- Tournament Management ---
        function createTournament(event) {
            event.preventDefault();

            const name = document.getElementById('tournamentName').value;
            const sport = document.getElementById('tournamentSport').value;
            const type = document.getElementById('tournamentType').value;
            const startDate = document.getElementById('tournamentStartDate').value;
            const endDate = document.getElementById('tournamentEndDate').value;
            const maxParticipants = parseInt(document.getElementById('tournamentMaxParticipants').value) || null;
            const entryFee = parseFloat(document.getElementById('tournamentEntryFee').value) || 0;
            const prizePool = parseFloat(document.getElementById('tournamentPrizePool').value) || 0;
            const description = document.getElementById('tournamentDescription').value;
            const setBasedScoring = document.getElementById('tournamentSetBasedScoring').checked;
            const playerStatsFields = document.getElementById('tournamentPlayerStatsFields').value.split(',').map(s => s.trim()).filter(s => s);

            if (!name || !sport || !type) {
                showAlert('Please fill in all required fields (Name, Sport, Type).', 'error');
                return;
            }

            const newTournament = {
                id: generateUniqueId(),
                name, sport, type, startDate, endDate, description,
                maxParticipants, entryFee, prizePool,
                status: TOURNAMENT_STATUS.UPCOMING,
                participants: [], // Overall tournament teams
                rounds: [], // For single elimination
                winnerBracket: [], // For double elimination
                loserBracket: [], // For double elimination
                grandFinal: [], // For double elimination
                matches: [], // For round robin
                stages: [], // For multi-stage
                groups: [], // For Group Stage
                swissRounds: [],
                gslGroups: [],
                ladderRanks: [],
                settings: {
                    setBasedScoring,
                    playerStatsFields,
                    bestOf: 1, // Default for elimination
                    groupStage: {},
                    multiStage: {} // New for Multi-Stage settings
                }
            };

            if (type === TOURNAMENT_TYPES.SINGLE_ELIMINATION || type === TOURNAMENT_TYPES.DOUBLE_ELIMINATION) {
                newTournament.settings.bestOf = parseInt(document.getElementById('tournamentBestOf').value) || 1;
            } else if (type === TOURNAMENT_TYPES.ROUND_ROBIN) {
                newTournament.settings.enableHomeAway = document.getElementById('rrEnableHomeAway').checked;
                newTournament.settings.pointsWin = parseInt(document.getElementById('rrPointsWin').value) || 3;
                newTournament.settings.pointsDraw = parseInt(document.getElementById('rrPointsDraw').value) || 1;
                newTournament.settings.pointsLoss = parseInt(document.getElementById('rrPointsLoss').value) || 0;
                newTournament.settings.tieBreaker = document.getElementById('rrTieBreaker').value || 'Points';
            } else if (type === TOURNAMENT_TYPES.GROUP_STAGE) {
                newTournament.settings.groupStage.groupsCount = parseInt(document.getElementById('groupStageGroupsCount').value) || 1;
                newTournament.settings.groupStage.advanceK = parseInt(document.getElementById('groupStageAdvanceK').value) || 1;
                newTournament.settings.groupStage.pointsWin = parseInt(document.getElementById('groupStagePointsWin').value) || 3;
                newTournament.settings.groupStage.pointsDraw = parseInt(document.getElementById('groupStagePointsDraw').value) || 1;
                newTournament.settings.groupStage.pointsLoss = parseInt(document.getElementById('groupStagePointsLoss').value) || 0;
                newTournament.settings.groupStage.tieBreaker = document.getElementById('groupStageTieBreaker').value || 'Points';
            } else if (type === TOURNAMENT_TYPES.MULTI_STAGE) { // NEW: Multi-Stage specific settings
                newTournament.settings.multiStage.groupsCount = parseInt(document.getElementById('multiStageGroupsCount').value) || 1;
                newTournament.settings.multiStage.advanceK = parseInt(document.getElementById('multiStageAdvanceK').value) || 1;
                newTournament.settings.multiStage.pointsWin = parseInt(document.getElementById('multiStagePointsWin').value) || 3;
                newTournament.settings.multiStage.pointsDraw = parseInt(document.getElementById('multiStagePointsDraw').value) || 1;
                newTournament.settings.multiStage.pointsLoss = parseInt(document.getElementById('multiStagePointsLoss').value) || 0;
                newTournament.settings.multiStage.tieBreaker = document.getElementById('multiStageTieBreaker').value || 'Points';
                newTournament.settings.multiStage.knockoutBestOf = parseInt(document.getElementById('multiStageKnockoutBestOf').value) || 1;

                // Predefine Group Stage and Knockout Stage
                newTournament.stages.push({
                    id: generateUniqueId(),
                    name: 'Group Stage',
                    type: TOURNAMENT_TYPES.GROUP_STAGE,
                    participants: [], // Will be populated with all tournament participants
                    groups: [],
                    settings: { // Inherit/copy from multiStage settings
                        groupsCount: newTournament.settings.multiStage.groupsCount,
                        advanceK: newTournament.settings.multiStage.advanceK,
                        pointsWin: newTournament.settings.multiStage.pointsWin,
                        pointsDraw: newTournament.settings.multiStage.pointsDraw,
                        pointsLoss: newTournament.settings.multiStage.pointsLoss,
                        tieBreaker: newTournament.settings.multiStage.tieBreaker,
                        setBasedScoring: newTournament.settings.setBasedScoring, // Inherit
                        playerStatsFields: newTournament.settings.playerStatsFields // Inherit
                    }
                });
                newTournament.stages.push({
                    id: generateUniqueId(),
                    name: 'Knockout Stage',
                    type: TOURNAMENT_TYPES.SINGLE_ELIMINATION,
                    participants: [], // Will be populated by qualifiers
                    rounds: [],
                    settings: { // Inherit/copy from multiStage settings
                        bestOf: newTournament.settings.multiStage.knockoutBestOf,
                        setBasedScoring: newTournament.settings.setBasedScoring, // Inherit
                        playerStatsFields: newTournament.settings.playerStatsFields // Inherit
                    }
                });
            } else if (type === TOURNAMENT_TYPES.SWISS_SYSTEM) {
                newTournament.settings.swissRounds = parseInt(document.getElementById('swissRounds').value) || 5;
                // Add more Swiss settings here
            }
            // Add settings for other new types here

            tournaments.push(newTournament);
            saveData();
            showAlert('Tournament created successfully!');
            document.getElementById('createTournamentForm').reset();
            renderTournamentList();
            showSection('dashboardSection');
        }

        function renderTournamentList() {
            const listDiv = document.getElementById('tournamentList');
            listDiv.innerHTML = '';

            const searchTerm = document.getElementById('tournamentSearch').value.toLowerCase();
            const filterStatus = document.getElementById('tournamentFilterStatus').value;
            const filterSport = document.getElementById('tournamentFilterSport').value;
            const filterType = document.getElementById('tournamentFilterType').value;

            const filteredTournaments = tournaments.filter(t => {
                const matchesSearch = t.name.toLowerCase().includes(searchTerm);
                const matchesStatus = filterStatus ? t.status === filterStatus : true;
                const matchesSport = filterSport ? t.sport === filterSport : true;
                const matchesType = filterType ? t.type === filterType : true;
                return matchesSearch && matchesStatus && matchesSport && matchesType;
            });

            if (filteredTournaments.length === 0) {
                listDiv.innerHTML = '<p class="no-data">No tournaments found matching your criteria.</p>';
                return;
            }

            filteredTournaments.forEach(tournament => {
                const card = document.createElement('div');
                card.className = 'tournament-card';
                card.innerHTML = `
                    <h3>${tournament.name}</h3>
                    <p><strong>Sport:</strong> ${tournament.sport}</p>
                    <p><strong>Type:</strong> ${tournament.type}</p>
                    <p><strong>Teams:</strong> ${tournament.participants.length} ${tournament.maxParticipants ? `/ ${tournament.maxParticipants}` : ''}</p>
                    <span class="status ${tournament.status.toLowerCase().replace(' ', '-')}">${tournament.status}</span>
                `;
                card.onclick = () => viewTournamentDetails(tournament.id);
                listDiv.appendChild(card);
            });
        }

        function viewTournamentDetails(id) {
            currentTournamentId = id;
            const tournament = tournaments.find(t => t.id === id);
            if (!tournament) {
                showAlert('Tournament not found!', 'error');
                showSection('dashboardSection');
                return;
            }

            document.getElementById('detailTournamentName').textContent = tournament.name;

            const infoDisplay = document.getElementById('tournamentInfoDisplay');
            infoDisplay.innerHTML = `
                <div class="tournament-info-item"><strong>Sport:</strong> ${tournament.sport}</div>
                <div class="tournament-info-item"><strong>Type:</strong> ${tournament.type}</div>
                <div class="tournament-info-item"><strong>Status:</strong> <span class="status ${tournament.status.toLowerCase().replace(' ', '-')}">${tournament.status}</span></div>
                <div class="tournament-info-item"><strong>Start Date:</strong> ${tournament.startDate || 'N/A'}</div>
                <div class="tournament-info-item"><strong>End Date:</strong> ${tournament.endDate || 'N/A'}</div>
                <div class="tournament-info-item"><strong>Max Teams:</strong> ${tournament.maxParticipants || 'Unlimited'}</div>
                <div class="tournament-info-item"><strong>Entry Fee:</strong> $${tournament.entryFee.toFixed(2)}</div>
                <div class="tournament-info-item"><strong>Prize Pool:</strong> $${tournament.prizePool.toFixed(2)}</div>
                <div class="tournament-info-item" style="grid-column: 1 / -1;"><strong>Description:</strong> ${tournament.description || 'No description.'}</div>
                <div class="tournament-info-item"><strong>Set-Based Scoring:</strong> ${tournament.settings.setBasedScoring ? 'Yes' : 'No'}</div>
                <div class="tournament-info-item"><strong>Player Stats:</strong> ${tournament.settings.playerStatsFields && tournament.settings.playerStatsFields.length > 0 ? tournament.settings.playerStatsFields.join(', ') : 'None'}</div>
            `;
            if (tournament.settings.bestOf && (tournament.type === TOURNAMENT_TYPES.SINGLE_ELIMINATION || tournament.type === TOURNAMENT_TYPES.DOUBLE_ELIMINATION)) {
                infoDisplay.innerHTML += `<div class="tournament-info-item"><strong>Best-of-N:</strong> ${tournament.settings.bestOf}</div>`;
            }
            if (tournament.type === TOURNAMENT_TYPES.ROUND_ROBIN) {
                infoDisplay.innerHTML += `
                    <div class="tournament-info-item"><strong>Home/Away:</strong> ${tournament.settings.enableHomeAway ? 'Yes' : 'No'}</div>
                    <div class="tournament-info-item"><strong>Points (W/D/L):</strong> ${tournament.settings.pointsWin}/${tournament.settings.pointsDraw}/${tournament.settings.pointsLoss}</div>
                    <div class="tournament-info-item"><strong>Tie-breaker:</strong> ${tournament.settings.tieBreaker}</div>
                `;
            }
            if (tournament.type === TOURNAMENT_TYPES.GROUP_STAGE) {
                infoDisplay.innerHTML += `
                    <div class="tournament-info-item"><strong>Groups:</strong> ${tournament.settings.groupStage.groupsCount}</div>
                    <div class="tournament-info-item"><strong>Advance:</strong> ${tournament.settings.groupStage.advanceK} per group</div>
                    <div class="tournament-info-item"><strong>Points (W/D/L):</strong> ${tournament.settings.groupStage.pointsWin}/${tournament.settings.groupStage.pointsDraw}/${tournament.settings.groupStage.pointsLoss}</div>
                    <div class="tournament-info-item"><strong>Tie-breaker:</strong> ${tournament.settings.groupStage.tieBreaker}</div>
                `;
            }
            if (tournament.type === TOURNAMENT_TYPES.MULTI_STAGE) { // NEW: Multi-Stage settings display
                infoDisplay.innerHTML += `
                    <div class="tournament-info-item"><strong>Group Stage Groups:</strong> ${tournament.settings.multiStage.groupsCount}</div>
                    <div class="tournament-info-item"><strong>Group Stage Advance:</strong> ${tournament.settings.multiStage.advanceK} per group</div>
                    <div class="tournament-info-item"><strong>Group Stage Points (W/D/L):</strong> ${tournament.settings.multiStage.pointsWin}/${tournament.settings.multiStage.pointsDraw}/${tournament.settings.multiStage.pointsLoss}</div>
                    <div class="tournament-info-item"><strong>Group Stage Tie-breaker:</strong> ${tournament.settings.multiStage.tieBreaker}</div>
                    <div class="tournament-info-item"><strong>Knockout Best-of-N:</strong> ${tournament.settings.multiStage.knockoutBestOf}</div>
                `;
            }
            if (tournament.type === TOURNAMENT_TYPES.SWISS_SYSTEM) {
                infoDisplay.innerHTML += `<div class="tournament-info-item"><strong>Rounds:</strong> ${tournament.settings.swissRounds}</div>`;
            }


            // Update status dropdown
            const statusSelect = document.getElementById('changeTournamentStatus');
            statusSelect.value = tournament.status;

            // Show/hide bracket/round robin/multi-stage sections and buttons
            document.querySelectorAll('#tournamentDetailSection > div[id$="Section"], #tournamentDetailSection > div[id$="Container"]').forEach(el => el.classList.add('hidden'));
            document.querySelectorAll('.flex-gap-10 > button[id^="generate"], .flex-gap-10 > button[id^="manage"]').forEach(btn => btn.classList.add('hidden'));


            if (tournament.type === TOURNAMENT_TYPES.SINGLE_ELIMINATION) {
                document.getElementById('eliminationBracketSection').classList.remove('hidden');
                document.getElementById('generateBracketBtn').classList.remove('hidden');
                renderBracket(tournament);
            } else if (tournament.type === TOURNAMENT_TYPES.DOUBLE_ELIMINATION) {
                document.getElementById('doubleEliminationBracketSection').classList.remove('hidden');
                document.getElementById('generateDoubleEliminationBracketBtn').classList.remove('hidden');
                renderDoubleEliminationBracket(tournament);
            } else if (tournament.type === TOURNAMENT_TYPES.ROUND_ROBIN) {
                document.getElementById('roundRobinMatchesSection').classList.remove('hidden');
                document.getElementById('generateRoundRobinBtn').classList.remove('hidden');
                renderRoundRobinMatches(tournament);
                renderRoundRobinStandings(tournament);
            } else if (tournament.type === TOURNAMENT_TYPES.MULTI_STAGE) {
                document.getElementById('multiStageContainer').classList.remove('hidden');
                document.getElementById('manageStagesBtn').classList.remove('hidden');
                renderMultiStages(tournament);
            } else if (tournament.type === TOURNAMENT_TYPES.GROUP_STAGE) {
                document.getElementById('groupStageSection').classList.remove('hidden');
                document.getElementById('generateGroupStageBtn').classList.remove('hidden');
                generateGroupStage(tournament); // Call generateGroupStage directly for this type
                // Team standings for Group Stage are rendered within renderGroupStage
            } else if (tournament.type === TOURNAMENT_TYPES.SWISS_SYSTEM) {
                document.getElementById('swissSection').classList.remove('hidden');
                document.getElementById('generateSwissBtn').classList.remove('hidden');
                // renderSwissRounds(tournament); // Placeholder
                // renderSwissStandings(tournament); // Placeholder
            } else if (tournament.type === TOURNAMENT_TYPES.GSL_FORMAT) {
                document.getElementById('gslSection').classList.remove('hidden');
                document.getElementById('generateGSLBtn').classList.remove('hidden');
                // renderGSLGroups(tournament); // Placeholder
            } else if (tournament.type === TOURNAMENT_TYPES.LADDER) {
                document.getElementById('ladderSection').classList.remove('hidden');
                document.getElementById('manageLadderBtn').classList.remove('hidden');
                // renderLadder(tournament); // Placeholder
            }

            // Always render player leaderboards if custom fields are defined
            if (tournament.settings.playerStatsFields && tournament.settings.playerStatsFields.length > 0) {
                document.getElementById('playerLeaderboardsSection').classList.remove('hidden');
                updateAggregatedPlayerStats(tournament); // Ensure stats are fresh before rendering
                renderPlayerLeaderboards(tournament);
            } else {
                document.getElementById('playerLeaderboardsSection').classList.add('hidden');
            }

            renderParticipantsList(tournament);
            showSection('tournamentDetailSection');
        }

        function editTournamentDetails() {
            const tournament = tournaments.find(t => t.id === currentTournamentId);
            if (!tournament) return;

            document.getElementById('editTournamentId').value = tournament.id;
            document.getElementById('editTournamentName').value = tournament.name;
            document.getElementById('editTournamentSport').value = tournament.sport;
            document.getElementById('editTournamentType').value = tournament.type; // Disabled, type cannot change
            document.getElementById('editTournamentStartDate').value = tournament.startDate;
            document.getElementById('editTournamentEndDate').value = tournament.endDate;
            document.getElementById('editTournamentMaxParticipants').value = tournament.maxParticipants;
            document.getElementById('editTournamentEntryFee').value = tournament.entryFee;
            document.getElementById('editTournamentPrizePool').value = tournament.prizePool;
            document.getElementById('editTournamentDescription').value = tournament.description;
            document.getElementById('editTournamentSetBasedScoring').checked = tournament.settings.setBasedScoring || false;
            document.getElementById('editTournamentPlayerStatsFields').value = (tournament.settings.playerStatsFields || []).join(', ');

            // Hide all specific settings first
            document.getElementById('editEliminationSettings').classList.add('hidden');
            document.getElementById('editRoundRobinSettings').classList.add('hidden');
            document.getElementById('editGroupStageSettings').classList.add('hidden');
            document.getElementById('editMultiStageSettings').classList.add('hidden'); // NEW
            document.getElementById('editSwissSettings').classList.add('hidden');
            document.getElementById('editGslSettings').classList.add('hidden');
            document.getElementById('editLadderSettings').classList.add('hidden');

            if (tournament.type === TOURNAMENT_TYPES.SINGLE_ELIMINATION || tournament.type === TOURNAMENT_TYPES.DOUBLE_ELIMINATION) {
                document.getElementById('editEliminationSettings').classList.remove('hidden');
                document.getElementById('editTournamentBestOf').value = tournament.settings.bestOf || 1;
            } else if (tournament.type === TOURNAMENT_TYPES.ROUND_ROBIN) {
                document.getElementById('editRoundRobinSettings').classList.remove('hidden');
                document.getElementById('editRrEnableHomeAway').checked = tournament.settings.enableHomeAway || false;
                document.getElementById('editRrPointsWin').value = tournament.settings.pointsWin;
                document.getElementById('editRrPointsDraw').value = tournament.settings.pointsDraw;
                document.getElementById('editRrPointsLoss').value = tournament.settings.pointsLoss;
                document.getElementById('editRrTieBreaker').value = tournament.settings.tieBreaker;
            } else if (tournament.type === TOURNAMENT_TYPES.GROUP_STAGE) {
                document.getElementById('editGroupStageSettings').classList.remove('hidden');
                document.getElementById('editGroupStageGroupsCount').value = tournament.settings.groupStage.groupsCount || 1;
                document.getElementById('editGroupStageAdvanceK').value = tournament.settings.groupStage.advanceK || 1;
                document.getElementById('editGroupStagePointsWin').value = tournament.settings.groupStage.pointsWin || 3;
                document.getElementById('editGroupStagePointsDraw').value = tournament.settings.groupStage.pointsDraw || 1;
                document.getElementById('editGroupStagePointsLoss').value = tournament.settings.groupStage.pointsLoss || 0;
                document.getElementById('editGroupStageTieBreaker').value = tournament.settings.groupStage.tieBreaker || 'Points';
            } else if (tournament.type === TOURNAMENT_TYPES.MULTI_STAGE) { // NEW: Multi-Stage settings
                document.getElementById('editMultiStageSettings').classList.remove('hidden');
                document.getElementById('editMultiStageGroupsCount').value = tournament.settings.multiStage.groupsCount || 1;
                document.getElementById('editMultiStageAdvanceK').value = tournament.settings.multiStage.advanceK || 1;
                document.getElementById('editMultiStagePointsWin').value = tournament.settings.multiStage.pointsWin || 3;
                document.getElementById('editMultiStagePointsDraw').value = tournament.settings.multiStage.pointsDraw || 1;
                document.getElementById('editMultiStagePointsLoss').value = tournament.settings.multiStage.pointsLoss || 0;
                document.getElementById('editMultiStageTieBreaker').value = tournament.settings.multiStage.tieBreaker || 'Points';
                document.getElementById('editMultiStageKnockoutBestOf').value = tournament.settings.multiStage.knockoutBestOf || 1;
            } else if (tournament.type === TOURNAMENT_TYPES.SWISS_SYSTEM) {
                document.getElementById('editSwissSettings').classList.remove('hidden');
                document.getElementById('editSwissRounds').value = tournament.settings.swissRounds || 5;
            }
            // Show/hide settings for other new types here

            openModal('editTournamentModal');
        }

        function saveEditedTournament(event) {
            event.preventDefault();
            const id = document.getElementById('editTournamentId').value;
            const tournament = tournaments.find(t => t.id === id);
            if (!tournament) return;

            tournament.name = document.getElementById('editTournamentName').value;
            tournament.sport = document.getElementById('editTournamentSport').value;
            tournament.startDate = document.getElementById('editTournamentStartDate').value;
            tournament.endDate = document.getElementById('editTournamentEndDate').value;
            tournament.maxParticipants = parseInt(document.getElementById('editTournamentMaxParticipants').value) || null;
            tournament.entryFee = parseFloat(document.getElementById('editTournamentEntryFee').value) || 0;
            tournament.prizePool = parseFloat(document.getElementById('editTournamentPrizePool').value) || 0;
            tournament.description = document.getElementById('editTournamentDescription').value;
            tournament.settings.setBasedScoring = document.getElementById('editTournamentSetBasedScoring').checked;
            tournament.settings.playerStatsFields = document.getElementById('editTournamentPlayerStatsFields').value.split(',').map(s => s.trim()).filter(s => s);

            if (tournament.type === TOURNAMENT_TYPES.SINGLE_ELIMINATION || tournament.type === TOURNAMENT_TYPES.DOUBLE_ELIMINATION) {
                tournament.settings.bestOf = parseInt(document.getElementById('editTournamentBestOf').value) || 1;
            } else if (tournament.type === TOURNAMENT_TYPES.ROUND_ROBIN) {
                tournament.settings.enableHomeAway = document.getElementById('editRrEnableHomeAway').checked;
                tournament.settings.pointsWin = parseInt(document.getElementById('editRrPointsWin').value) || 3;
                tournament.settings.pointsDraw = parseInt(document.getElementById('editRrPointsDraw').value) || 1;
                tournament.settings.pointsLoss = parseInt(document.getElementById('editRrPointsLoss').value) || 0;
                tournament.settings.tieBreaker = document.getElementById('editRrTieBreaker').value || 'Points';
            } else if (tournament.type === TOURNAMENT_TYPES.GROUP_STAGE) {
                tournament.settings.groupStage.groupsCount = parseInt(document.getElementById('editGroupStageGroupsCount').value) || 1;
                tournament.settings.groupStage.advanceK = parseInt(document.getElementById('editGroupStageAdvanceK').value) || 1;
                tournament.settings.groupStage.pointsWin = parseInt(document.getElementById('editGroupStagePointsWin').value) || 3;
                tournament.settings.groupStage.pointsDraw = parseInt(document.getElementById('editGroupStagePointsDraw').value) || 1;
                tournament.settings.groupStage.pointsLoss = parseInt(document.getElementById('editGroupStagePointsLoss').value) || 0;
                tournament.settings.groupStage.tieBreaker = document.getElementById('editGroupStageTieBreaker').value || 'Points';
            } else if (tournament.type === TOURNAMENT_TYPES.MULTI_STAGE) { // NEW: Multi-Stage settings
                tournament.settings.multiStage.groupsCount = parseInt(document.getElementById('editMultiStageGroupsCount').value) || 1;
                tournament.settings.multiStage.advanceK = parseInt(document.getElementById('editMultiStageAdvanceK').value) || 1;
                tournament.settings.multiStage.pointsWin = parseInt(document.getElementById('editMultiStagePointsWin').value) || 3;
                tournament.settings.multiStage.pointsDraw = parseInt(document.getElementById('editMultiStagePointsDraw').value) || 1;
                tournament.settings.multiStage.pointsLoss = parseInt(document.getElementById('editMultiStagePointsLoss').value) || 0;
                tournament.settings.multiStage.tieBreaker = document.getElementById('editMultiStageTieBreaker').value || 'Points';
                tournament.settings.multiStage.knockoutBestOf = parseInt(document.getElementById('editMultiStageKnockoutBestOf').value) || 1;

                // Update settings for the predefined stages if they exist
                const groupStage = tournament.stages.find(s => s.name === 'Group Stage' && s.type === TOURNAMENT_TYPES.GROUP_STAGE);
                if (groupStage) {
                    Object.assign(groupStage.settings, {
                        groupsCount: tournament.settings.multiStage.groupsCount,
                        advanceK: tournament.settings.multiStage.advanceK,
                        pointsWin: tournament.settings.multiStage.pointsWin,
                        pointsDraw: tournament.settings.multiStage.pointsDraw,
                        pointsLoss: tournament.settings.multiStage.pointsLoss,
                        tieBreaker: tournament.settings.multiStage.tieBreaker,
                        setBasedScoring: tournament.settings.setBasedScoring,
                        playerStatsFields: tournament.settings.playerStatsFields
                    });
                }
                const knockoutStage = tournament.stages.find(s => s.name === 'Knockout Stage' && s.type === TOURNAMENT_TYPES.SINGLE_ELIMINATION);
                if (knockoutStage) {
                    Object.assign(knockoutStage.settings, {
                        bestOf: tournament.settings.multiStage.knockoutBestOf,
                        setBasedScoring: tournament.settings.setBasedScoring,
                        playerStatsFields: tournament.settings.playerStatsFields
                    });
                }
            } else if (tournament.type === TOURNAMENT_TYPES.SWISS_SYSTEM) {
                tournament.settings.swissRounds = parseInt(document.getElementById('editSwissRounds').value) || 5;
            }
            // Save settings for other new types here

            saveData();
            showAlert('Tournament updated successfully!');
            closeModal('editTournamentModal');
            viewTournamentDetails(id); // Re-render details
        }

        function deleteTournament() {
            if (!confirm('Are you sure you want to delete this tournament and all its data?')) {
                return;
            }
            tournaments = tournaments.filter(t => t.id !== currentTournamentId);
            saveData();
            showAlert('Tournament deleted successfully!', 'danger');
            showSection('dashboardSection');
        }

        function changeTournamentStatus(event) {
            const newStatus = event.target.value;
            const tournament = tournaments.find(t => t.id === currentTournamentId);
            if (tournament) {
                tournament.status = newStatus;
                saveData();
                showAlert(`Tournament status changed to ${newStatus}.`);
                viewTournamentDetails(currentTournamentId); // Re-render details
            }
        }

        // --- Participant (Team) Management ---
        function renderParticipantsList(tournament) {
            const listDiv = document.getElementById('participantsList');
            listDiv.innerHTML = '';
            document.getElementById('participantCount').textContent = tournament.participants.length;
            document.getElementById('maxParticipants').textContent = tournament.maxParticipants || '∞';

            if (tournament.participants.length === 0) {
                listDiv.innerHTML = '<p class="no-data">No teams added yet.</p>';
                return;
            }

            tournament.participants.sort((a, b) => (a.seed || Infinity) - (b.seed || Infinity)); // Sort by seed

            tournament.participants.forEach(p => {
                const item = document.createElement('div');
                item.className = 'participant-item';
                item.innerHTML = `
                    <div>
                        <strong>${p.name}</strong>
                        ${p.seed ? ` (Seed: ${p.seed})` : ''}
                        ${p.rating ? ` (Rating: ${p.rating})` : ''}
                        ${p.contact ? `<br><small>${p.contact}</small>` : ''}
                        <br><small>Players: ${p.players.length}</small>
                    </div>
                    <div class="actions">
                        <button class="btn btn-secondary" onclick="editParticipant('${p.id}')">Edit</button>
                        <button class="btn btn-danger" onclick="deleteParticipant('${p.id}')">Delete</button>
                    </div>
                `;
                listDiv.appendChild(item);
            });
        }

        function openAddParticipantModal() {
            document.getElementById('participantModalTitle').textContent = 'Add Team';
            document.getElementById('participantForm').reset();
            document.getElementById('participantId').value = '';
            document.getElementById('managePlayersBtnForTeam').classList.add('hidden'); // Hide for new team
            openModal('participantModal');
        }

        function editParticipant(participantId) {
            const tournament = tournaments.find(t => t.id === currentTournamentId);
            const participant = tournament.participants.find(p => p.id === participantId);
            if (!participant) return;

            document.getElementById('participantModalTitle').textContent = 'Edit Team';
            document.getElementById('participantId').value = participant.id;
            document.getElementById('participantName').value = participant.name;
            document.getElementById('participantSeed').value = participant.seed;
            document.getElementById('participantRating').value = participant.rating;
            document.getElementById('participantContact').value = participant.contact;
            document.getElementById('participantNotes').value = participant.notes;
            document.getElementById('managePlayersBtnForTeam').classList.remove('hidden'); // Show for existing team
            openModal('participantModal');
        }

        function addOrUpdateParticipant(event) {
            event.preventDefault();
            const tournament = tournaments.find(t => t.id === currentTournamentId);
            if (!tournament) return;

            const participantId = document.getElementById('participantId').value;
            const name = document.getElementById('participantName').value;
            const seed = parseInt(document.getElementById('participantSeed').value) || null;
            const rating = parseFloat(document.getElementById('participantRating').value) || null;
            const contact = document.getElementById('participantContact').value;
            const notes = document.getElementById('participantNotes').value;

            if (!name) {
                showAlert('Team name is required.', 'error');
                return;
            }

            if (tournament.maxParticipants && tournament.participants.length >= tournament.maxParticipants && !participantId) {
                showAlert(`Cannot add more teams. Max is ${tournament.maxParticipants}.`, 'error');
                return;
            }

            if (participantId) {
                // Update existing participant (team)
                const participant = tournament.participants.find(p => p.id === participantId);
                if (participant) {
                    participant.name = name;
                    participant.seed = seed;
                    participant.rating = rating;
                    participant.contact = contact;
                    participant.notes = notes;
                    showAlert('Team updated successfully!');
                }
            } else {
                // Add new participant (team)
                const newParticipant = {
                    id: generateUniqueId(),
                    name, seed, rating, contact, notes,
                    wins: 0, losses: 0, draws: 0, scoreFor: 0, scoreAgainst: 0, points: 0,
                    teamStats: { matchesPlayed: 0, custom: {} }, // Team-level aggregated stats
                    players: [] // Individual players within this team
                };
                tournament.settings.playerStatsFields.forEach(field => newParticipant.teamStats.custom[field] = 0);
                tournament.participants.push(newParticipant);
                showAlert('Team added successfully!');
            }

            saveData();
            renderParticipantsList(tournament);
            closeModal('participantModal');
        }

        function deleteParticipant(participantId) {
            if (!confirm('Are you sure you want to delete this team? This will also clear all generated brackets/matches and player stats.')) {
                return;
            }
            const tournament = tournaments.find(t => t.id === currentTournamentId);
            if (tournament) {
                tournament.participants = tournament.participants.filter(p => p.id !== participantId);
                // Reset all brackets/matches if participants change
                tournament.rounds = [];
                tournament.winnerBracket = [];
                tournament.loserBracket = [];
                tournament.grandFinal = [];
                tournament.matches = [];
                tournament.swissRounds = [];
                tournament.gslGroups = [];
                tournament.ladderRanks = [];
                tournament.groups = [];
                tournament.stages.forEach(stage => {
                    stage.participants = stage.participants.filter(pId => pId !== participantId);
                    stage.matches = [];
                    stage.rounds = [];
                    stage.groups = [];
                });
                saveData();
                showAlert('Team deleted successfully!', 'danger');
                viewTournamentDetails(currentTournamentId); // Re-render details
            }
        }

        function openBulkImportModal() {
            document.getElementById('bulkImportFileInput').value = '';
            openModal('bulkImportModal');
        }

        function processBulkImport() {
            const fileInput = document.getElementById('bulkImportFileInput');
            const file = fileInput.files[0];
            if (!file) {
                showAlert('Please select a CSV file.', 'error');
                return;
            }

            const reader = new FileReader();
            reader.onload = (e) => {
                const csv = e.target.result;
                const names = csv.split('\n').map(line => line.trim()).filter(line => line);
                const tournament = tournaments.find(t => t.id === currentTournamentId);

                if (!tournament) {
                    showAlert('Tournament not found.', 'error');
                    return;
                }

                let addedCount = 0;
                names.forEach(name => {
                    if (tournament.maxParticipants && tournament.participants.length >= tournament.maxParticipants) {
                        showAlert(`Max teams reached. Stopped importing at "${name}".`, 'error');
                        return;
                    }
                    const newParticipant = {
                        id: generateUniqueId(),
                        name, seed: null, rating: null, contact: '', notes: '',
                        wins: 0, losses: 0, draws: 0, scoreFor: 0, scoreAgainst: 0, points: 0,
                        teamStats: { matchesPlayed: 0, custom: {} },
                        players: []
                    };
                    tournament.settings.playerStatsFields.forEach(field => newParticipant.teamStats.custom[field] = 0);
                    tournament.participants.push(newParticipant);
                    addedCount++;
                });

                saveData();
                showAlert(`${addedCount} teams imported successfully!`);
                renderParticipantsList(tournament);
                closeModal('bulkImportModal');
            };
            reader.readAsText(file);
        }

        function openCopyParticipantsModal() {
            const select = document.getElementById('copyFromTournamentSelect');
            select.innerHTML = '<option value="">-- Select a Tournament --</option>';
            tournaments.forEach(t => {
                if (t.id !== currentTournamentId) {
                    const option = document.createElement('option');
                    option.value = t.id;
                    option.textContent = t.name;
                    select.appendChild(option);
                }
            });
            openModal('copyParticipantsModal');
        }

        function processCopyParticipants() {
            const fromTournamentId = document.getElementById('copyFromTournamentSelect').value;
            if (!fromTournamentId) {
                showAlert('Please select a tournament to copy teams from.', 'error');
                return;
            }

            const sourceTournament = tournaments.find(t => t.id === fromTournamentId);
            const targetTournament = tournaments.find(t => t.id === currentTournamentId);

            if (!sourceTournament || !targetTournament) {
                showAlert('Source or target tournament not found.', 'error');
                return;
            }

            let copiedCount = 0;
            sourceTournament.participants.forEach(p => {
                if (targetTournament.maxParticipants && targetTournament.participants.length >= targetTournament.maxParticipants) {
                    showAlert(`Max teams reached in target tournament. Stopped copying.`, 'error');
                    return;
                }
                // Only copy if participant name doesn't already exist to avoid duplicates
                if (!targetTournament.participants.some(tp => tp.name === p.name)) {
                    const newParticipant = {
                        id: generateUniqueId(), // New ID for the copied participant
                        name: p.name,
                        seed: p.seed,
                        rating: p.rating,
                        contact: p.contact,
                        notes: p.notes,
                        wins: 0, losses: 0, draws: 0, scoreFor: 0, scoreAgainst: 0, points: 0,
                        teamStats: { matchesPlayed: 0, custom: {} },
                        players: JSON.parse(JSON.stringify(p.players)) // Deep copy players
                    };
                    // Initialize custom stats for new participant
                    targetTournament.settings.playerStatsFields.forEach(field => newParticipant.teamStats.custom[field] = 0);
                    newParticipant.players.forEach(player => {
                        if (!player.stats) player.stats = { matchesPlayed: 0, custom: {} };
                        targetTournament.settings.playerStatsFields.forEach(field => player.stats.custom[field] = 0);
                    });

                    targetTournament.participants.push(newParticipant);
                    copiedCount++;
                }
            });

            saveData();
            showAlert(`${copiedCount} teams copied successfully!`);
            renderParticipantsList(targetTournament);
            closeModal('copyParticipantsModal');
        }

        // --- Player Management within a Team ---
        function openManagePlayersModal(teamId) {
            const tournament = tournaments.find(t => t.id === currentTournamentId);
            const team = tournament.participants.find(p => p.id === teamId);
            if (!team) return;

            currentTeamIdForPlayers = teamId;
            document.getElementById('managePlayersModalTitle').textContent = `Manage Players for ${team.name}`;
            document.getElementById('managePlayersTeamId').value = teamId;
            renderPlayersListForTeam(team);
            openModal('managePlayersModal');
        }

        function renderPlayersListForTeam(team) {
            const playersListDiv = document.getElementById('playersList');
            playersListDiv.innerHTML = '';

            if (team.players.length === 0) {
                playersListDiv.innerHTML = '<p class="no-data">No players added to this team yet.</p>';
                return;
            }

            team.players.forEach(player => {
                const item = document.createElement('div');
                item.className = 'player-item';
                item.innerHTML = `
                    <div>
                        <strong>${player.name}</strong>
                    </div>
                    <div class="actions">
                        <button class="btn btn-secondary btn-sm" onclick="editPlayer('${team.id}', '${player.id}')">Edit</button>
                        <button class="btn btn-danger btn-sm" onclick="deletePlayer('${team.id}', '${player.id}')">Delete</button>
                    </div>
                `;
                playersListDiv.appendChild(item);
            });
        }

        function openAddPlayerModal() {
            const tournament = tournaments.find(t => t.id === currentTournamentId);
            document.getElementById('addEditPlayerModalTitle').textContent = 'Add Player';
            document.getElementById('addEditPlayerForm').reset();
            document.getElementById('addEditPlayerTeamId').value = currentTeamIdForPlayers;
            document.getElementById('addEditPlayerId').value = '';

            const playerInitialStatsDiv = document.getElementById('playerInitialStats');
            playerInitialStatsDiv.innerHTML = '';
            tournament.settings.playerStatsFields.forEach(field => {
                playerInitialStatsDiv.innerHTML += `
                    <div class="form-group">
                        <label for="player_initial_stat_${field}">${field}</label>
                        <input type="number" id="player_initial_stat_${field}" value="0" data-stat-field="${field}">
                    </div>
                `;
            });

            openModal('addEditPlayerModal');
        }

        function editPlayer(teamId, playerId) {
            const tournament = tournaments.find(t => t.id === currentTournamentId);
            const team = tournament.participants.find(p => p.id === teamId);
            const player = team.players.find(pl => pl.id === playerId);
            if (!player) return;

            document.getElementById('addEditPlayerModalTitle').textContent = `Edit Player: ${player.name}`;
            document.getElementById('addEditPlayerForm').reset();
            document.getElementById('addEditPlayerTeamId').value = teamId;
            document.getElementById('addEditPlayerId').value = playerId;
            document.getElementById('playerName').value = player.name;

            const playerInitialStatsDiv = document.getElementById('playerInitialStats');
            playerInitialStatsDiv.innerHTML = '';
            tournament.settings.playerStatsFields.forEach(field => {
                playerInitialStatsDiv.innerHTML += `
                    <div class="form-group">
                        <label for="player_initial_stat_${field}">${field}</label>
                        <input type="number" id="player_initial_stat_${field}" value="${player.stats.custom[field] !== undefined ? player.stats.custom[field] : 0}" data-stat-field="${field}">
                    </div>
                `;
            });

            openModal('addEditPlayerModal');
        }

        function addOrUpdatePlayer(event) {
            event.preventDefault();
            const tournament = tournaments.find(t => t.id === currentTournamentId);
            const teamId = document.getElementById('addEditPlayerTeamId').value;
            const team = tournament.participants.find(p => p.id === teamId);
            if (!team) return;

            const playerId = document.getElementById('addEditPlayerId').value;
            const playerName = document.getElementById('playerName').value;

            if (!playerName) {
                showAlert('Player name is required.', 'error');
                return;
            }

            const playerCustomStats = {};
            tournament.settings.playerStatsFields.forEach(field => {
                playerCustomStats[field] = parseInt(document.getElementById(`player_initial_stat_${field}`).value) || 0;
            });

            if (playerId) {
                // Update existing player
                const player = team.players.find(p => p.id === playerId);
                if (player) {
                    player.name = playerName;
                    // Update initial custom stats, aggregated stats will be recalculated
                    Object.assign(player.stats.custom, playerCustomStats);
                    showAlert('Player updated successfully!');
                }
            } else {
                // Add new player
                const newPlayer = {
                    id: generateUniqueId(),
                    name: playerName,
                    stats: { matchesPlayed: 0, custom: playerCustomStats } // Initial stats
                };
                team.players.push(newPlayer);
                showAlert('Player added successfully!');
            }

            saveData();
            renderPlayersListForTeam(team);
            closeModal('addEditPlayerModal');
            updateAggregatedPlayerStats(tournament); // Re-aggregate all stats
            renderPlayerLeaderboards(tournament);
        }

        function deletePlayer(teamId, playerId) {
            if (!confirm('Are you sure you want to delete this player? This will also remove their stats from leaderboards.')) {
                return;
            }
            const tournament = tournaments.find(t => t.id === currentTournamentId);
            const team = tournament.participants.find(p => p.id === teamId);
            if (team) {
                team.players = team.players.filter(p => p.id !== playerId);
                saveData();
                showAlert('Player deleted successfully!', 'danger');
                renderPlayersListForTeam(team);
                updateAggregatedPlayerStats(tournament); // Re-aggregate all stats
                renderPlayerLeaderboards(tournament);
            }
        }


        // --- Elimination Bracket Logic (Common for SE & DE) ---
        function generateEliminationBracket(tournament, bracketType, stageId = null) {
            let participantsInScope;
            let targetBracket;
            let bestOf;
            let confirmMessage;

            if (stageId) {
                const stage = tournament.stages.find(s => s.id === stageId);
                if (!stage) return;
                participantsInScope = tournament.participants.filter(p => stage.participants.includes(p.id));
                targetBracket = stage.rounds;
                bestOf = stage.settings.bestOf || tournament.settings.bestOf || 1;
                confirmMessage = `Bracket for stage "${stage.name}" already generated. Regenerating will clear all scores. Continue?`;
            } else {
                participantsInScope = tournament.participants;
                bestOf = tournament.settings.bestOf || 1;
                if (bracketType === TOURNAMENT_TYPES.DOUBLE_ELIMINATION) {
                    targetBracket = tournament.winnerBracket;
                } else {
                    targetBracket = tournament.rounds;
                }
                confirmMessage = 'Bracket already generated. Regenerating will clear all scores. Continue?';
            }

            if (participantsInScope.length < 2) {
                showAlert('Need at least 2 teams to generate a bracket.', 'error');
                return;
            }

            if (targetBracket.length > 0 && !confirm(confirmMessage)) {
                return;
            }

            // Clear existing brackets
            if (stageId) {
                const stage = tournament.stages.find(s => s.id === stageId);
                stage.rounds = [];
            } else {
                tournament.rounds = [];
                tournament.winnerBracket = [];
                tournament.loserBracket = [];
                tournament.grandFinal = [];
            }

            // Sort participants by seed, then randomly for unseeded
            let sortedParticipants = [...participantsInScope].sort((a, b) => {
                if (a.seed && b.seed) return a.seed - b.seed;
                if (a.seed) return -1; // Seeded teams first
                if (b.seed) return 1;
                return Math.random() - 0.5; // Random for unseeded
            });

            const numParticipants = sortedParticipants.length;
            let numRounds = Math.ceil(Math.log2(numParticipants));
            let totalSlots = Math.pow(2, numRounds);
            let byes = totalSlots - numParticipants;

            let tempParticipants = [...sortedParticipants];
            let byeParticipants = [];

            // Assign byes to highest seeds
            for(let i=0; i<byes; i++) {
                if (tempParticipants.length > 0) {
                    byeParticipants.push(tempParticipants.shift());
                }
            }

            // Standard bracket seeding for remaining participants (e.g., 1 vs N, 2 vs N-1)
            let seededOrder = [];
            let remaining = tempParticipants.length;
            if (remaining > 0) {
                let topHalf = tempParticipants.slice(0, Math.ceil(remaining / 2));
                let bottomHalf = tempParticipants.slice(Math.ceil(remaining / 2));
                bottomHalf.reverse(); // Reverse bottom half for pairing

                for (let i = 0; i < Math.max(topHalf.length, bottomHalf.length); i++) {
                    if (topHalf[i]) seededOrder.push(topHalf[i]);
                    if (bottomHalf[i]) seededOrder.push(bottomHalf[i]);
                }
            }

            // Combine byes and seeded participants for initial round
            let finalParticipantsForPairing = [];
            let currentSeededIndex = 0;
            let currentByeIndex = 0;

            // Fill slots, prioritizing seeded participants, then byes
            for (let i = 0; i < totalSlots; i++) {
                if (currentSeededIndex < seededOrder.length) {
                    finalParticipantsForPairing.push({ participant: seededOrder[currentSeededIndex++], bye: false });
                } else if (currentByeIndex < byeParticipants.length) {
                    finalParticipantsForPairing.push({ participant: byeParticipants[currentByeIndex++], bye: true });
                } else {
                    finalParticipantsForPairing.push({ participant: null, bye: false });
                }
            }
            // Shuffle the byes and seeded participants to ensure fair distribution of byes
            shuffleArray(finalParticipantsForPairing);


            // Create initial matches for Round 1
            let round1Matches = [];
            for (let i = 0; i < finalParticipantsForPairing.length; i += 2) {
                const p1Entry = finalParticipantsForPairing[i];
                const p2Entry = finalParticipantsForPairing[i + 1];

                const p1 = p1Entry?.participant;
                const p2 = p2Entry?.participant;

                if (p1Entry?.bye && p2Entry?.bye) {
                    round1Matches.push(createMatchObject(p1.id, null, tournament.settings.playerStatsFields, p1.id, 'Completed - Bye', bestOf, null, null, stageId));
                } else if (p1Entry?.bye) { // P1 has a bye, P2 advances
                    round1Matches.push(createMatchObject(p2.id, null, tournament.settings.playerStatsFields, p2.id, 'Completed - Bye', bestOf, null, null, stageId));
                } else if (p2Entry?.bye) { // P2 has a bye, P1 advances
                    round1Matches.push(createMatchObject(p1.id, null, tournament.settings.playerStatsFields, p1.id, 'Completed - Bye', bestOf, null, null, stageId));
                } else if (p1 && p2) {
                    round1Matches.push(createMatchObject(p1.id, p2.id, tournament.settings.playerStatsFields, null, 'Upcoming', bestOf, null, null, stageId));
                } else if (p1) { // Odd number of participants, last one gets a bye (should be handled by initial bye assignment)
                    round1Matches.push(createMatchObject(p1.id, null, tournament.settings.playerStatsFields, p1.id, 'Completed - Bye', bestOf, null, null, stageId));
                }
            }

            if (bracketType === TOURNAMENT_TYPES.SINGLE_ELIMINATION) {
                if (stageId) {
                    const stage = tournament.stages.find(s => s.id === stageId);
                    stage.rounds.push({ name: 'Round 1', matches: round1Matches });
                    for (let r = 1; r < numRounds; r++) {
                        let nextRoundMatches = [];
                        const numMatchesInRound = Math.ceil(round1Matches.length / Math.pow(2, r));
                        for (let i = 0; i < numMatchesInRound; i++) {
                            nextRoundMatches.push(createMatchObject(null, null, tournament.settings.playerStatsFields, null, 'Upcoming', bestOf, null, null, stageId));
                        }
                        if (nextRoundMatches.length > 0) {
                            stage.rounds.push({ name: `Round ${r + 1}`, matches: nextRoundMatches });
                        }
                    }
                } else {
                    tournament.rounds.push({ name: 'Round 1', matches: round1Matches });
                    for (let r = 1; r < numRounds; r++) {
                        let nextRoundMatches = [];
                        const numMatchesInRound = Math.ceil(round1Matches.length / Math.pow(2, r));
                        for (let i = 0; i < numMatchesInRound; i++) {
                            nextRoundMatches.push(createMatchObject(null, null, tournament.settings.playerStatsFields, null, 'Upcoming', bestOf));
                        }
                        if (nextRoundMatches.length > 0) {
                            tournament.rounds.push({ name: `Round ${r + 1}`, matches: nextRoundMatches });
                        }
                    }
                }
            } else if (bracketType === TOURNAMENT_TYPES.DOUBLE_ELIMINATION) {
                // Initialize Winner's Bracket
                tournament.winnerBracket.push({ name: 'Winner\'s Round 1', matches: round1Matches });
                for (let r = 1; r < numRounds; r++) {
                    let nextRoundMatches = [];
                    const numMatchesInRound = Math.ceil(round1Matches.length / Math.pow(2, r));
                    for (let i = 0; i < numMatchesInRound; i++) {
                        nextRoundMatches.push(createMatchObject(null, null, tournament.settings.playerStatsFields, null, 'Upcoming', bestOf));
                    }
                    if (nextRoundMatches.length > 0) {
                        tournament.winnerBracket.push({ name: `Winner\'s Round ${r + 1}`, matches: nextRoundMatches });
                    }
                }

                // Initialize Loser's Bracket (simplified structure)
                // Loser's bracket rounds are more complex, often having more matches and rounds.
                // This is a basic placeholder.
                const numLoserBracketRounds = numRounds * 2 - 2; // A common pattern
                for (let r = 0; r < numLoserBracketRounds; r++) {
                    tournament.loserBracket.push({ name: `Loser\'s Round ${r + 1}`, matches: [] });
                }

                // Grand Final
                tournament.grandFinal.push({ name: 'Grand Final', matches: [createMatchObject(null, null, tournament.settings.playerStatsFields, null, 'Upcoming', bestOf)] });
            }

            saveData();
            showAlert('Bracket generated successfully!');
            if (stageId) {
                renderMultiStages(tournament);
            } else if (bracketType === TOURNAMENT_TYPES.SINGLE_ELIMINATION) {
                renderBracket(tournament);
            } else {
                renderDoubleEliminationBracket(tournament);
            }
            updateAggregatedPlayerStats(tournament); // Update player stats after bracket generation
        }

        function createMatchObject(player1Id, player2Id, playerStatsFields, winnerId = null, status = 'Upcoming', bestOf = 1, homePlayerId = null, awayPlayerId = null, stageId = null, groupId = null) {
            const match = {
                id: generateUniqueId(),
                player1Id, // This is now a Team ID
                player2Id, // This is now a Team ID
                homePlayerId: homePlayerId || player1Id,
                awayPlayerId: awayPlayerId || player2Id,
                score1: null,
                score2: null,
                sets: null,
                winnerId,
                status,
                bestOf,
                date: null,
                time: null,
                venue: null,
                referee: null,
                stageId: stageId, // Store stage ID
                groupId: groupId,   // Store group ID
                team1MatchPlayerStats: [], // Array of player stats for Team 1 in this match
                team2MatchPlayerStats: []  // Array of player stats for Team 2 in this match
            };
            return match;
        }

        function renderBracket(tournament, targetElementId = 'bracketVisualizer', roundsArray = tournament.rounds, stageId = null) {
            const bracketVisualizer = document.getElementById(targetElementId);
            if (!bracketVisualizer) return; // Ensure element exists
            bracketVisualizer.innerHTML = '';

            if (!roundsArray || roundsArray.length === 0) {
                bracketVisualizer.innerHTML = '<p class="no-data">Bracket not generated. Add teams and click "Generate Bracket".</p>';
                return;
            }

            roundsArray.forEach((round, roundIndex) => {
                const roundDiv = document.createElement('div');
                roundDiv.className = 'bracket-round-simple';
                roundDiv.innerHTML = `<h4>${round.name}</h4>`;

                round.matches.forEach(match => {
                    roundDiv.appendChild(createMatchElementHTML(match, tournament, roundIndex, 'rounds'));
                });
                bracketVisualizer.appendChild(roundDiv);
            });

            // Check for overall winner
            const lastRound = roundsArray[roundsArray.length - 1];
            if (lastRound && lastRound.matches.length === 1 && lastRound.matches[0].winnerId) {
                const winner = tournament.participants.find(p => p.id === lastRound.matches[0].winnerId);
                bracketVisualizer.insertAdjacentHTML('beforeend', `<h3 class="text-center" style="margin-top: 30px; color: var(--accent-color);">🏆 Tournament Winner: ${winner.name} 🏆</h3>`);
            }
        }

        function renderDoubleEliminationBracket(tournament) {
            const deWrapper = document.getElementById('doubleEliminationWrapper');
            if (!deWrapper) return; // Ensure element exists
            deWrapper.innerHTML = '';

            if (!tournament.winnerBracket || tournament.winnerBracket.length === 0) {
                deWrapper.innerHTML = '<p class="no-data">Double Elimination Bracket not generated. Add teams and click "Generate DE Bracket".</p>';
                return;
            }

            // Render Winner's Bracket
            const wbDiv = document.createElement('div');
            wbDiv.innerHTML = '<h3>Winner\'s Bracket</h3>';
            const wbVisualizer = document.createElement('div');
            wbVisualizer.className = 'bracket-visualizer';
            tournament.winnerBracket.forEach((round, roundIndex) => {
                const roundDiv = document.createElement('div');
                roundDiv.className = 'bracket-round-simple';
                roundDiv.innerHTML = `<h4>${round.name}</h4>`;
                round.matches.forEach(match => {
                    roundDiv.appendChild(createMatchElementHTML(match, tournament, roundIndex, 'winnerBracket'));
                });
                wbVisualizer.appendChild(roundDiv);
            });
            wbDiv.appendChild(wbVisualizer);
            deWrapper.appendChild(wbDiv);

            // Render Loser's Bracket
            const lbDiv = document.createElement('div');
            lbDiv.innerHTML = '<h3>Loser\'s Bracket</h3>';
            const lbVisualizer = document.createElement('div');
            lbVisualizer.className = 'bracket-visualizer';
            tournament.loserBracket.forEach((round, roundIndex) => {
                const roundDiv = document.createElement('div');
                roundDiv.className = 'bracket-round-simple';
                roundDiv.innerHTML = `<h4>${round.name}</h4>`;
                round.matches.forEach(match => {
                    roundDiv.appendChild(createMatchElementHTML(match, tournament, roundIndex, 'loserBracket'));
                });
                lbVisualizer.appendChild(roundDiv);
            });
            lbDiv.appendChild(lbVisualizer);
            deWrapper.appendChild(lbDiv);

            // Render Grand Final
            const gfDiv = document.createElement('div');
            gfDiv.innerHTML = '<h3>Grand Final</h3>';
            const gfVisualizer = document.createElement('div');
            gfVisualizer.className = 'bracket-visualizer';
            tournament.grandFinal.forEach((round, roundIndex) => { // Grand Final is typically one round
                const roundDiv = document.createElement('div');
                roundDiv.className = 'bracket-round-simple';
                round.matches.forEach(match => {
                    roundDiv.appendChild(createMatchElementHTML(match, tournament, roundIndex, 'grandFinal'));
                });
                gfVisualizer.appendChild(roundDiv);
            });
            gfDiv.appendChild(gfVisualizer);
            deWrapper.appendChild(gfDiv);

            // Check for overall winner
            const grandFinalMatch = tournament.grandFinal[0]?.matches[0];
            if (grandFinalMatch && grandFinalMatch.winnerId) {
                const winner = tournament.participants.find(p => p.id === grandFinalMatch.winnerId);
                deWrapper.insertAdjacentHTML('beforeend', `<h3 class="text-center" style="margin-top: 30px; color: var(--accent-color);">🏆 Tournament Winner: ${winner.name} 🏆</h3>`);
            }
        }

        function createMatchElementHTML(match, tournament, roundIndex, bracketType) {
            // Determine participants in scope based on match.stageId and match.groupId
            let participantsInScope = tournament.participants;
            if (match.stageId) {
                const stage = tournament.stages.find(s => s.id === match.stageId);
                if (stage) participantsInScope = tournament.participants.filter(p => stage.participants.includes(p.id));
            } else if (match.groupId) { // Main tournament group
                const group = tournament.groups.find(g => g.id === match.groupId);
                if (group) participantsInScope = tournament.participants.filter(p => group.participants.includes(p.id));
            }

            const p1 = participantsInScope.find(p => p.id === match.player1Id); // p1 is now team1
            const p2 = participantsInScope.find(p => p.id === match.player2Id); // p2 is now team2

            const scoreInputHtml1 = p1 ? (tournament.settings.setBasedScoring ?
                `<input type="text" class="sets-input" value="${match.sets !== null ? match.sets.split('-')[0] : ''}" data-player="1" ${match.status !== 'Upcoming' ? 'disabled' : ''}>` :
                `<input type="number" class="score-input" value="${match.score1 !== null ? match.score1 : ''}" data-player="1" ${match.status !== 'Upcoming' ? 'disabled' : ''}>`) : '';
            const scoreInputHtml2 = p2 ? (tournament.settings.setBasedScoring ?
                `<input type="text" class="sets-input" value="${match.sets !== null ? match.sets.split('-')[1] : ''}" data-player="2" ${match.status !== 'Upcoming' ? 'disabled' : ''}>` :
                `<input type="number" class="score-input" value="${match.score2 !== null ? match.score2 : ''}" data-player="2" ${match.status !== 'Upcoming' ? 'disabled' : ''}>`) : '';

            const matchDiv = document.createElement('div');
            matchDiv.className = `bracket-match-simple ${match.winnerId ? 'winner' : ''}`;
            matchDiv.innerHTML = `
                <div class="player-line ${match.winnerId === p1?.id ? 'winner-player' : ''}">
                    <span>${p1 ? p1.name : 'TBD'}</span>
                    ${scoreInputHtml1}
                </div>
                <div class="player-line ${match.winnerId === p2?.id ? 'winner-player' : ''}">
                    <span>${p2 ? p2.name : 'TBD'}</span>
                    ${scoreInputHtml2}
                </div>
                <div class="match-actions">
                    <button class="btn btn-outline" onclick="openMatchDetailsModal('${match.id}', ${roundIndex}, '${bracketType}', '${match.stageId || ''}', '${match.groupId || ''}')">Details</button>
                    ${match.status === 'Upcoming' && p1 && p2 ? `<button class="btn btn-primary" onclick="recordScore('${match.id}', ${roundIndex}, '${bracketType}', '${match.stageId || ''}', '${match.groupId || ''}')">Record Score</button>` : ''}
                    ${match.status === 'Completed' ? `<span style="color: var(--primary-color); font-weight: bold;">Winner: ${participantsInScope.find(p => p.id === match.winnerId)?.name || 'N/A'}</span>` : ''}
                    ${match.status === 'Completed - Bye' ? `<span style="color: var(--secondary-color); font-weight: bold;">BYE - ${p1?.name || 'N/A'} Advances</span>` : ''}
                </div>
            `;
            return matchDiv;
        }

        // Consolidated record score function for all types
        async function recordScore(matchId, roundIndex, bracketType, stageId = null, groupId = null) {
            const tournament = tournaments.find(t => t.id === currentTournamentId);
            if (!tournament) return;

            let matchesArray, bracket, rrSettings;
            let participantsForMatch = tournament.participants; // Default to all tournament participants
            let currentStage = null;
            let currentGroup = null;
            let bestOf = tournament.settings.bestOf || 1; // Default bestOf from tournament settings

            if (stageId) {
                currentStage = tournament.stages.find(s => s.id === stageId);
                if (!currentStage) { showAlert('Stage not found for match score.', 'error'); return; }
                participantsForMatch = tournament.participants.filter(p => currentStage.participants.includes(p.id));
                bestOf = currentStage.settings.bestOf || bestOf; // Use stage bestOf if available
                if (bracketType === 'matches') { // RR stage
                    matchesArray = currentStage.matches;
                    rrSettings = currentStage.settings;
                } else if (bracketType === 'groupMatches') { // Group Stage within a Multi-Stage
                    currentGroup = currentStage.groups.find(g => g.id === groupId);
                    if (!currentGroup) { showAlert('Group not found for match score.', 'error'); return; }
                    matchesArray = currentGroup.matches;
                    participantsForMatch = tournament.participants.filter(p => currentGroup.participants.includes(p.id));
                    rrSettings = currentStage.settings; // Use stage settings for RR within groups
                } else { // SE stage
                    bracket = currentStage.rounds;
                }
            } else if (groupId) { // Group Stage tournament type
                currentGroup = tournament.groups.find(g => g.id === groupId);
                if (!currentGroup) { showAlert('Group not found for match score.', 'error'); return; }
                matchesArray = currentGroup.matches;
                participantsForMatch = tournament.participants.filter(p => currentGroup.participants.includes(p.id));
                rrSettings = tournament.settings.groupStage; // Use group stage specific settings
                bestOf = 1; // Group stage matches are typically best of 1
            } else { // Main tournament (SE, DE, RR)
                if (bracketType === 'matches') {
                    matchesArray = tournament.matches;
                    rrSettings = tournament.settings;
                } else {
                    bracket = tournament[bracketType];
                }
            }

            let match;
            if (bracketType === 'matches' || bracketType === 'groupMatches') { // RR or Group Stage matches
                if (!matchesArray) { showAlert('Matches array not found for score recording.', 'error'); return; }
                match = matchesArray.find(m => m.id === matchId);
            } else { // Elimination brackets
                if (!bracket || !bracket[roundIndex]) { showAlert('Bracket round not found for score recording.', 'error'); return; }
                match = bracket[roundIndex].matches.find(m => m.id === matchId);
            }

            if (!match) { showAlert('Match not found for score recording.', 'error'); return; }

            const matchElement = document.querySelector(`[onclick*="recordScore('${matchId}'"]`).closest('.bracket-match-simple, tr');
            let score1, score2;

            if (tournament.settings.setBasedScoring) {
                const setsInput1 = matchElement.querySelector('input[data-player="1"]');
                const setsInput2 = matchElement.querySelector('input[data-player="2"]');
                const sets1 = parseInt(setsInput1.value);
                const sets2 = parseInt(setsInput2.value);

                if (isNaN(sets1) || isNaN(sets2)) {
                    showAlert('Please enter valid set scores for both teams.', 'error');
                    return;
                }
                match.sets = `${sets1}-${sets2}`;
                score1 = sets1; // Use sets for winner determination
                score2 = sets2;
            } else {
                const scoreInput1 = matchElement.querySelector('input[data-player="1"]');
                const scoreInput2 = matchElement.querySelector('input[data-player="2"]');
                score1 = parseInt(scoreInput1.value);
                score2 = parseInt(scoreInput2.value);

                if (isNaN(score1) || isNaN(score2)) {
                    showAlert('Please enter valid scores for both teams.', 'error');
                    return;
                }
                match.score1 = score1;
                match.score2 = score2;
            }

            let loserId = null;
            if (score1 > score2) {
                match.winnerId = match.player1Id;
                loserId = match.player2Id;
            } else if (score2 > score1) {
                match.winnerId = match.player2Id;
                loserId = match.player1Id;
            } else {
                if (bracketType === 'rounds' || bracketType === 'winnerBracket' || bracketType === 'loserBracket' || bracketType === 'grandFinal') {
                    showAlert('Scores cannot be tied in elimination brackets. Please enter a clear winner.', 'error');
                    return;
                }
                match.winnerId = null; // Draw for RR/Group Stage
            }
            match.status = 'Completed';

            // Update aggregated player and team stats
            updateAggregatedPlayerStats(tournament); // Call with tournament to re-aggregate all

            // Logic for advancing winners/losers (only for elimination brackets)
            if (bracketType === 'rounds') { // Single Elimination
                if (roundIndex < bracket.length - 1) {
                    advanceWinner(bracket[roundIndex + 1].matches, match.winnerId);
                }
            } else if (bracketType === 'winnerBracket') { // Double Elimination - Winner's Bracket
                if (roundIndex < tournament.winnerBracket.length - 1) {
                    advanceWinner(tournament.winnerBracket[roundIndex + 1].matches, match.winnerId);
                } else { // Winner of WB goes to Grand Final
                    const grandFinalMatch = tournament.grandFinal[0]?.matches[0];
                    if (grandFinalMatch) {
                        grandFinalMatch.player1Id = match.winnerId; // WB winner is P1 in GF
                    }
                }
                if (loserId) {
                    const lbRoundIndex = roundIndex;
                    if (tournament.loserBracket[lbRoundIndex]) {
                        let foundSlot = false;
                        for (const lbMatch of tournament.loserBracket[lbRoundIndex].matches) {
                            if (!lbMatch.player1Id) { lbMatch.player1Id = loserId; foundSlot = true; break; }
                            if (!lbMatch.player2Id) { lbMatch.player2Id = loserId; foundSlot = true; break; }
                        }
                        if (!foundSlot) {
                            tournament.loserBracket[lbRoundIndex].matches.push(createMatchObject(loserId, null, tournament.settings.playerStatsFields, null, 'Upcoming', bestOf));
                        }
                    } else {
                        tournament.loserBracket.push({ name: `Loser's Round ${tournament.loserBracket.length + 1}`, matches: [createMatchObject(loserId, null, tournament.settings.playerStatsFields, null, 'Upcoming', bestOf)] });
                    }
                }
            } else if (bracketType === 'loserBracket') { // Double Elimination - Loser's Bracket
                if (roundIndex < tournament.loserBracket.length - 1) {
                    advanceWinner(tournament.loserBracket[roundIndex + 1].matches, match.winnerId);
                } else { // Winner of LB goes to Grand Final
                    const grandFinalMatch = tournament.grandFinal[0]?.matches[0];
                    if (grandFinalMatch) {
                        grandFinalMatch.player2Id = match.winnerId; // LB winner is P2 in GF
                    }
                }
            } else if (bracketType === 'grandFinal') {
                // Grand Final winner is tournament winner
            }

            saveData();
            showAlert(`Score recorded for match. ${participantsForMatch.find(p => p.id === match.winnerId)?.name || 'Draw'}!`);

            // Re-render relevant sections
            if (stageId) {
                renderMultiStages(tournament);
                // Check if all group stage matches are completed for auto-advancement
                if (currentStage.type === TOURNAMENT_TYPES.GROUP_STAGE) {
                    const allGroupMatchesCompleted = currentStage.groups.every(group =>
                        group.matches.every(m => m.status === 'Completed')
                    );
                    if (allGroupMatchesCompleted) {
                        showAlert(`All matches in ${currentStage.name} completed. Advancing qualifiers to next stage...`, 'info');
                        await advanceQualifiersToKnockout(tournament, stageId);
                    }
                }
            } else if (groupId) {
                generateGroupStage(tournament); // Re-render group stage to update standings
            } else if (bracketType === 'rounds') {
                renderBracket(tournament);
            } else if (bracketType === 'winnerBracket' || bracketType === 'loserBracket' || bracketType === 'grandFinal') {
                renderDoubleEliminationBracket(tournament);
            } else if (bracketType === 'matches') { // For Round Robin
                renderRoundRobinMatches(tournament);
                renderRoundRobinStandings(tournament);
            }
            renderPlayerLeaderboards(tournament); // Always re-render player leaderboards
        }

        function advanceWinner(nextRoundMatches, winnerId) {
            let foundSlot = false;
            for (const nextMatch of nextRoundMatches) {
                if (!nextMatch.player1Id) {
                    nextMatch.player1Id = winnerId;
                    foundSlot = true;
                    break;
                } else if (!nextMatch.player2Id) {
                    nextMatch.player2Id = winnerId;
                    foundSlot = true;
                    break;
                }
            }
        }

        // --- Match Details Modal ---
        function openMatchDetailsModal(matchId, roundIndex, bracketType, stageId = null, groupId = null) {
            const tournament = tournaments.find(t => t.id === currentTournamentId);
            if (!tournament) return;

            let match;
            let participantsForMatch; // Teams in scope for this match

            // Find the match object
            if (stageId) {
                const stage = tournament.stages.find(s => s.id === stageId);
                if (!stage) { showAlert('Stage not found for match details.', 'error'); return; }
                participantsForMatch = tournament.participants.filter(p => stage.participants.includes(p.id));
                if (bracketType === 'matches') { // RR stage
                    if (!stage.matches) { showAlert('Stage matches not found for details.', 'error'); return; }
                    match = stage.matches.find(m => m.id === matchId);
                } else if (bracketType === 'groupMatches') {
                    const group = stage.groups.find(g => g.id === groupId);
                    if (!group) { showAlert('Group not found for match details.', 'error'); return; }
                    if (!group.matches) { showAlert('Group matches not found for details.', 'error'); return; }
                    match = group.matches.find(m => m.id === matchId);
                    participantsForMatch = tournament.participants.filter(p => group.participants.includes(p.id));
                } else { // SE stage
                    if (!stage.rounds || !stage.rounds[roundIndex]) { showAlert('Stage round not found for match details.', 'error'); return; }
                    match = stage.rounds[roundIndex].matches.find(m => m.id === matchId);
                }
            } else if (groupId) { // Main tournament group
                const group = tournament.groups.find(g => g.id === groupId);
                if (!group) { showAlert('Group not found for match details.', 'error'); return; }
                if (!group.matches) { showAlert('Group matches not found for details.', 'error'); return; }
                match = group.matches.find(m => m.id === matchId);
                participantsForMatch = tournament.participants.filter(p => group.participants.includes(p.id));
            } else { // Main tournament (SE, DE, RR)
                if (bracketType === 'matches') {
                    if (!tournament.matches) { showAlert('Tournament matches not found for details.', 'error'); return; }
                    match = tournament.matches.find(m => m.id === matchId);
                } else {
                    if (!tournament[bracketType] || !tournament[bracketType][roundIndex]) { showAlert('Tournament bracket round not found for match details.', 'error'); return; }
                    match = tournament[bracketType][roundIndex].matches.find(m => m.id === matchId);
                }
                participantsForMatch = tournament.participants;
            }

            if (!match) { showAlert('Match not found for details.', 'error'); return; }

            const team1 = participantsForMatch.find(p => p.id === match.player1Id);
            const team2 = participantsForMatch.find(p => p.id === match.player2Id);

            document.getElementById('matchDetailsModalTitle').textContent = `Match: ${team1?.name || 'TBD'} vs ${team2?.name || 'TBD'}`;
            document.getElementById('matchDetailsMatchId').value = match.id;
            document.getElementById('matchDetailsRoundIndex').value = roundIndex;
            document.getElementById('matchDetailsBracketType').value = bracketType;
            document.getElementById('matchDetailsStageId').value = stageId || '';
            document.getElementById('matchDetailsGroupId').value = groupId || '';

            document.getElementById('matchDetailsPlayer1').value = team1?.name || 'BYE';
            document.getElementById('matchDetailsPlayer2').value = team2?.name || 'BYE';
            document.getElementById('matchDetailsBestOf').value = match.bestOf || 1;
            document.getElementById('matchDetailsDate').value = match.date || '';
            document.getElementById('matchDetailsTime').value = match.time || '';
            document.getElementById('matchDetailsVenue').value = match.venue || '';
            document.getElementById('matchDetailsReferee').value = match.referee || '';

            // Render individual player stats inputs
            const team1PlayerStatsInputsDiv = document.getElementById('team1PlayerStatsInputs');
            const team2PlayerStatsInputsDiv = document.getElementById('team2PlayerStatsInputs');
            team1PlayerStatsInputsDiv.innerHTML = '';
            team2PlayerStatsInputsDiv.innerHTML = '';

            if (tournament.settings.playerStatsFields && tournament.settings.playerStatsFields.length > 0) {
                document.getElementById('matchDetailsPlayerStats').classList.remove('hidden');
                if (team1 && team1.players.length > 0) {
                    team1PlayerStatsInputsDiv.innerHTML += `<h4>${team1.name} Players</h4>`;
                    team1.players.forEach(player => {
                        const playerMatchStats = match.team1MatchPlayerStats.find(s => s.playerId === player.id) || {};
                        let playerHtml = `<div style="margin-bottom: 10px; border: 1px dashed var(--border-color); padding: 10px; border-radius: var(--radius);"><strong>${player.name}</strong><div class="form-grid">`;
                        tournament.settings.playerStatsFields.forEach(field => {
                            playerHtml += `
                                <div class="form-group">
                                    <label for="p1_${player.id}_stat_${field}">${field}</label>
                                    <input type="number" id="p1_${player.id}_stat_${field}" value="${playerMatchStats[field] !== undefined ? playerMatchStats[field] : ''}" data-team-id="${team1.id}" data-player-id="${player.id}" data-stat="${field}">
                                </div>
                            `;
                        });
                        playerHtml += `</div></div>`;
                        team1PlayerStatsInputsDiv.innerHTML += playerHtml;
                    });
                } else if (team1) {
                    team1PlayerStatsInputsDiv.innerHTML = `<p>No players registered for ${team1.name}.</p>`;
                }

                if (team2 && team2.players.length > 0) {
                    team2PlayerStatsInputsDiv.innerHTML += `<h4>${team2.name} Players</h4>`;
                    team2.players.forEach(player => {
                        const playerMatchStats = match.team2MatchPlayerStats.find(s => s.playerId === player.id) || {};
                        let playerHtml = `<div style="margin-bottom: 10px; border: 1px dashed var(--border-color); padding: 10px; border-radius: var(--radius);"><strong>${player.name}</strong><div class="form-grid">`;
                        tournament.settings.playerStatsFields.forEach(field => {
                            playerHtml += `
                                <div class="form-group">
                                    <label for="p2_${player.id}_stat_${field}">${field}</label>
                                    <input type="number" id="p2_${player.id}_stat_${field}" value="${playerMatchStats[field] !== undefined ? playerMatchStats[field] : ''}" data-team-id="${team2.id}" data-player-id="${player.id}" data-stat="${field}">
                                </div>
                            `;
                        });
                        playerHtml += `</div></div>`;
                        team2PlayerStatsInputsDiv.innerHTML += playerHtml;
                    });
                } else if (team2) {
                    team2PlayerStatsInputsDiv.innerHTML = `<p>No players registered for ${team2.name}.</p>`;
                }
            } else {
                document.getElementById('matchDetailsPlayerStats').classList.add('hidden');
            }


            openModal('matchDetailsModal');
        }

        function saveMatchDetails(event) {
            event.preventDefault();
            const tournament = tournaments.find(t => t.id === currentTournamentId);
            if (!tournament) return;

            const matchId = document.getElementById('matchDetailsMatchId').value;
            const roundIndex = parseInt(document.getElementById('matchDetailsRoundIndex').value);
            const bracketType = document.getElementById('matchDetailsBracketType').value;
            const stageId = document.getElementById('matchDetailsStageId').value;
            const groupId = document.getElementById('matchDetailsGroupId').value;

            let match;
            if (stageId) {
                const stage = tournament.stages.find(s => s.id === stageId);
                if (!stage) return;
                if (bracketType === 'matches') {
                    match = stage.matches.find(m => m.id === matchId);
                } else if (bracketType === 'groupMatches') {
                    const group = stage.groups.find(g => g.id === groupId);
                    if (!group) return;
                    match = group.matches.find(m => m.id === matchId);
                } else {
                    match = stage.rounds[roundIndex].matches.find(m => m.id === matchId);
                }
            } else if (groupId) {
                const group = tournament.groups.find(g => g.id === groupId);
                if (!group) return;
                match = group.matches.find(m => m.id === matchId);
            } else {
                if (bracketType === 'matches') {
                    match = tournament.matches.find(m => m.id === matchId);
                } else {
                    match = tournament[bracketType][roundIndex].matches.find(m => m.id === matchId);
                }
            }

            if (!match) return;

            match.bestOf = parseInt(document.getElementById('matchDetailsBestOf').value) || 1;
            match.date = document.getElementById('matchDetailsDate').value;
            match.time = document.getElementById('matchDetailsTime').value;
            match.venue = document.getElementById('matchDetailsVenue').value;
            match.referee = document.getElementById('matchDetailsReferee').value;

            // Save individual player stats for the match
            match.team1MatchPlayerStats = [];
            match.team2MatchPlayerStats = [];

            document.querySelectorAll('#team1PlayerStatsInputs input[data-player-id]').forEach(input => {
                const playerId = input.dataset.playerId;
                const statField = input.dataset.stat;
                let playerStatsEntry = match.team1MatchPlayerStats.find(s => s.playerId === playerId);
                if (!playerStatsEntry) {
                    playerStatsEntry = { playerId: playerId };
                    match.team1MatchPlayerStats.push(playerStatsEntry);
                }
                playerStatsEntry[statField] = parseInt(input.value) || 0;
            });

            document.querySelectorAll('#team2PlayerStatsInputs input[data-player-id]').forEach(input => {
                const playerId = input.dataset.playerId;
                const statField = input.dataset.stat;
                let playerStatsEntry = match.team2MatchPlayerStats.find(s => s.playerId === playerId);
                if (!playerStatsEntry) {
                    playerStatsEntry = { playerId: playerId };
                    match.team2MatchPlayerStats.push(playerStatsEntry);
                }
                playerStatsEntry[statField] = parseInt(input.value) || 0;
            });

            saveData();
            showAlert('Match details updated successfully!');
            closeModal('matchDetailsModal');
            updateAggregatedPlayerStats(tournament); // Re-aggregate all stats
            if (stageId) {
                renderMultiStages(tournament);
            } else if (groupId) {
                generateGroupStage(tournament); // Re-render group stage to update standings
            } else if (bracketType === 'rounds') {
                renderBracket(tournament);
            } else if (bracketType === 'winnerBracket' || bracketType === 'loserBracket' || bracketType === 'grandFinal') {
                renderDoubleEliminationBracket(tournament);
            } else if (bracketType === 'matches') { // For Round Robin
                renderRoundRobinMatches(tournament);
                renderRoundRobinStandings(tournament);
            }
            renderPlayerLeaderboards(tournament); // Always re-render player leaderboards
        }

        // --- Round Robin Logic ---
        // Implements the "Circle Method" for scheduling
        function generateRoundRobinMatches(tournament, stageId = null, group = null) {
            let participantsInScope;
            let matchesArray;
            let rrSettings;
            let playerStatsFields = tournament.settings.playerStatsFields;
            let confirmMessage;

            if (group) { // For a specific group (either Group Stage tournament or Multi-Stage Group Stage)
                participantsInScope = tournament.participants.filter(p => group.participants.includes(p.id));
                matchesArray = group.matches;
                // Determine rrSettings based on context
                if (stageId) { // Multi-Stage Group Stage
                    const stage = tournament.stages.find(s => s.id === stageId);
                    rrSettings = stage.settings;
                } else { // Group Stage tournament type
                    rrSettings = tournament.settings.groupStage;
                }
                confirmMessage = `Matches for group "${group.name}" already generated. Regenerating will clear all scores. Continue?`;
            } else if (stageId) { // For a specific stage (e.g., a Round Robin stage in Multi-Stage)
                const stage = tournament.stages.find(s => s.id === stageId);
                if (!stage) return;
                participantsInScope = tournament.participants.filter(p => stage.participants.includes(p.id));
                matchesArray = stage.matches;
                rrSettings = stage.settings;
                confirmMessage = `Matches for stage "${stage.name}" already generated. Regenerating will clear all scores. Continue?`;
            } else { // Main tournament RR
                participantsInScope = tournament.participants;
                matchesArray = tournament.matches;
                rrSettings = tournament.settings;
                confirmMessage = 'Matches already generated. Regenerating will clear all scores. Continue?';
            }

            if (participantsInScope.length < 2) {
                showAlert('Need at least 2 teams to generate matches.', 'error');
                return [];
            }

            if (matchesArray.length > 0 && !confirm(confirmMessage)) {
                return matchesArray;
            }

            // Clear existing matches
            if (group) {
                group.matches = [];
            } else if (stageId) {
                const stage = tournament.stages.find(s => s.id === stageId);
                stage.matches = [];
            } else {
                tournament.matches = [];
            }

            let teams = [...participantsInScope];
            shuffleArray(teams); // Randomize the order of teams before scheduling

            let numTeams = teams.length;
            let tempTeams = [...teams];

            // If odd number of teams, add a "BYE" placeholder
            const hasBye = numTeams % 2 !== 0;
            if (hasBye) {
                tempTeams.push({ id: 'BYE', name: 'BYE' });
                numTeams++; // Adjust count for scheduling
            }

            const rounds = numTeams - 1;
            const allMatches = [];

            for (let r = 0; r < rounds; r++) {
                for (let i = 0; i < numTeams / 2; i++) {
                    const t1 = tempTeams[i];
                    const t2 = tempTeams[numTeams - 1 - i];

                    if (t1.id === 'BYE' || t2.id === 'BYE') {
                        continue;
                    }

                    // Match 1: t1 vs t2
                    allMatches.push(createMatchObject(t1.id, t2.id, playerStatsFields, null, 'Upcoming', 1, t1.id, t2.id, stageId, group?.id));
                    if (rrSettings.enableHomeAway) {
                        // Match 2: t2 vs t1 (home/away swapped)
                        allMatches.push(createMatchObject(t2.id, t1.id, playerStatsFields, null, 'Upcoming', 1, t2.id, t1.id, stageId, group?.id));
                    }
                }

                // Rotate teams (except the first one)
                const fixed = tempTeams[0];
                const last = tempTeams.pop();
                tempTeams.splice(1, 0, last);
                tempTeams[0] = fixed;
            }

            if (group) {
                group.matches = allMatches;
            } else if (stageId) {
                const stage = tournament.stages.find(s => s.id === stageId);
                stage.matches = allMatches;
            } else {
                tournament.matches = allMatches;
            }

            saveData();
            showAlert('Round Robin matches generated successfully!');
            updateAggregatedPlayerStats(tournament); // Update player stats after match generation
            return allMatches;
        }

        function renderRoundRobinMatches(tournament, targetElementId = 'roundRobinMatches', matchesArray = tournament.matches, participantsArray = tournament.participants, rrSettings = tournament.settings, stageId = null, groupId = null) {
            const matchesDiv = document.getElementById(targetElementId);
            if (!matchesDiv) return; // Ensure element exists
            matchesDiv.innerHTML = '';

            if (!matchesArray || matchesArray.length === 0) {
                matchesDiv.innerHTML = '<p class="no-data">Matches not generated. Add teams and click "Generate Matches".</p>';
                return;
            }

            const table = document.createElement('table');
            table.className = 'round-robin-table';
            table.innerHTML = `
                <thead>
                    <tr>
                        <th>Match</th>
                        <th>Home Team</th>
                        <th>Score</th>
                        <th>Away Team</th>
                        <th>Status</th>
                        <th>Schedule</th>
                        <th>Actions</th>
                    </tr>
                </thead>
                <tbody></tbody>
            `;
            const tbody = table.querySelector('tbody');

            matchesArray.forEach(match => {
                const homeTeam = participantsArray.find(p => p.id === match.homePlayerId);
                const awayTeam = participantsArray.find(p => p.id === match.awayPlayerId);

                const scoreInputHtml1 = tournament.settings.setBasedScoring ?
                    `<input type="text" class="sets-input" value="${match.sets !== null ? match.sets.split('-')[0] : ''}" data-match-id="${match.id}" data-player="1" ${match.status !== 'Upcoming' ? 'disabled' : ''}>` :
                    `<input type="number" class="score-input" value="${match.score1 !== null ? match.score1 : ''}" data-match-id="${match.id}" data-player="1" ${match.status !== 'Upcoming' ? 'disabled' : ''}>`;
                const scoreInputHtml2 = tournament.settings.setBasedScoring ?
                    `<input type="text" class="sets-input" value="${match.sets !== null ? match.sets.split('-')[1] : ''}" data-match-id="${match.id}" data-player="2" ${match.status !== 'Upcoming' ? 'disabled' : ''}>` :
                    `<input type="number" class="score-input" value="${match.score2 !== null ? match.score2 : ''}" data-match-id="${match.id}" data-player="2" ${match.status !== 'Upcoming' ? 'disabled' : ''}>`;

                const row = document.createElement('tr');
                row.innerHTML = `
                    <td>${homeTeam?.name || 'N/A'} vs ${awayTeam?.name || 'N/A'}</td>
                    <td>${homeTeam?.name || 'N/A'}</td>
                    <td>
                        ${scoreInputHtml1}
                        -
                        ${scoreInputHtml2}
                    </td>
                    <td>${awayTeam?.name || 'N/A'}</td>
                    <td>${match.status}</td>
                    <td>${match.date || 'N/A'} ${match.time || ''}</td>
                    <td>
                        <button class="btn btn-outline btn-sm" onclick="openMatchDetailsModal('${match.id}', 0, 'matches', '${stageId || ''}', '${groupId || ''}')">Details</button>
                        ${match.status === 'Upcoming' ? `<button class="btn btn-primary btn-sm" onclick="recordScore('${match.id}', 0, 'matches', '${stageId || ''}', '${groupId || ''}')">Record</button>` : ''}
                        ${match.status === 'Completed' ? `<span style="color: var(--primary-color); font-weight: bold;">Winner: ${participantsArray.find(p => p.id === match.winnerId)?.name || 'Draw'}</span>` : ''}
                    </td>
                `;
                tbody.appendChild(row);
            });
            matchesDiv.appendChild(table);
        }

        function renderRoundRobinStandings(tournament, targetElementId = 'roundRobinStandings', matchesArray = tournament.matches, participantsArray = tournament.participants, rrSettings = tournament.settings) {
            const standingsDiv = document.getElementById(targetElementId);
            if (standingsDiv) standingsDiv.innerHTML = ''; // Only clear if targetElementId is provided

            if (!matchesArray || matchesArray.length === 0) {
                if (standingsDiv) standingsDiv.innerHTML = '<p class="no-data">Standings will appear after matches are generated and scores recorded.</p>';
                return []; // Return empty array if no matches
            }

            const teamStats = {};
            participantsArray.forEach(p => {
                teamStats[p.id] = {
                    id: p.id,
                    name: p.name,
                    played: 0, wins: 0, losses: 0, draws: 0,
                    scoreFor: 0, scoreAgainst: 0,
                    scoreDiff: 0,
                    points: 0,
                    headToHead: {} // Store head-to-head results
                };
            });

            matchesArray.forEach(match => {
                if (match.status === 'Completed') {
                    const t1Stats = teamStats[match.player1Id];
                    const t2Stats = teamStats[match.player2Id];

                    if (!t1Stats || !t2Stats) return; // Should not happen (e.g., BYE participant)

                    let score1 = tournament.settings.setBasedScoring ? parseInt(match.sets.split('-')[0]) : match.score1;
                    let score2 = tournament.settings.setBasedScoring ? parseInt(match.sets.split('-')[1]) : match.score2;

                    t1Stats.played++;
                    t2Stats.played++;

                    t1Stats.scoreFor += score1;
                    t1Stats.scoreAgainst += score2;
                    t2Stats.scoreFor += score2;
                    t2Stats.scoreAgainst += score1;

                    if (match.winnerId === match.player1Id) {
                        t1Stats.wins++;
                        t2Stats.losses++;
                        t1Stats.points += rrSettings.pointsWin;
                        t2Stats.points += rrSettings.pointsLoss;
                        t1Stats.headToHead[t2Stats.id] = (t1Stats.headToHead[t2Stats.id] || 0) + 1;
                        t2Stats.headToHead[t1Stats.id] = (t2Stats.headToHead[t1Stats.id] || 0) - 1;
                    } else if (match.winnerId === match.player2Id) {
                        t2Stats.wins++;
                        t1Stats.losses++;
                        t2Stats.points += rrSettings.pointsWin;
                        t1Stats.points += rrSettings.pointsLoss;
                        t2Stats.headToHead[t1Stats.id] = (t2Stats.headToHead[t1Stats.id] || 0) + 1;
                        t1Stats.headToHead[t2Stats.id] = (t1Stats.headToHead[t2Stats.id] || 0) - 1;
                    } else { // Draw
                        t1Stats.draws++;
                        t2Stats.draws++;
                        t1Stats.points += rrSettings.pointsDraw;
                        t2Stats.points += rrSettings.pointsDraw;
                    }
                }
            });

            let standings = Object.values(teamStats);

            // Calculate score difference
            standings.forEach(stats => {
                stats.scoreDiff = stats.scoreFor - stats.scoreAgainst;
            });

            // Sort standings
            standings.sort((a, b) => {
                if (b.points !== a.points) return b.points - a.points;

                // Tie-breaking rules
                switch (rrSettings.tieBreaker) {
                    case 'Head-to-Head':
                        const h2h_a = a.headToHead[b.id] || 0;
                        const h2h_b = b.headToHead[a.id] || 0;
                        if (h2h_a !== h2h_b) return h2h_a - h2h_b;
                        return b.scoreDiff - a.scoreDiff; // Fallback
                    case 'Score Difference':
                        return b.scoreDiff - a.scoreDiff;
                    case 'Score For':
                        return b.scoreFor - a.scoreFor;
                    case 'Random':
                    default:
                        return Math.random() - 0.5;
                }
            });

            const table = document.createElement('table');
            table.className = 'standings-table';
            let headerHtml = `
                <thead>
                    <tr>
                        <th>Rank</th>
                        <th>Team</th>
                        <th>P</th>
                        <th>W</th>
                        <th>L</th>
                        <th>D</th>
                        <th>GF</th>
                        <th>GA</th>
                        <th>GD</th>
                        <th>Pts</th>
                    </tr>
                </thead>
                <tbody></tbody>
            `;
            table.innerHTML = headerHtml;
            const tbody = table.querySelector('tbody');

            standings.forEach((stats, index) => {
                let rowHtml = `
                    <td class="rank">${index + 1}</td>
                    <td>${stats.name}</td>
                    <td>${stats.played}</td>
                    <td>${stats.wins}</td>
                    <td>${stats.losses}</td>
                    <td>${stats.draws}</td>
                    <td>${stats.scoreFor}</td>
                    <td>${stats.scoreAgainst}</td>
                    <td>${stats.scoreDiff}</td>
                    <td>${stats.points}</td>
                `;

                const row = document.createElement('tr');
                row.innerHTML = rowHtml;
                tbody.appendChild(row);
            });
            if (standingsDiv) standingsDiv.appendChild(table);
            return standings;
        }

        // --- NEW: Group Stage Logic (for Group Stage tournament type AND Multi-Stage Group Stage) ---
        function generateGroupStage(tournament, targetElementId = 'groupsDisplay', groupsArray = tournament.groups, groupStageSettings = tournament.settings.groupStage, stageId = null) {
            const groupsDisplayDiv = document.getElementById(targetElementId);
            if (!groupsDisplayDiv) return; // Ensure element exists
            groupsDisplayDiv.innerHTML = '';

            let participantsInScope = tournament.participants;
            if (stageId) { // If this is a Group Stage within a Multi-Stage tournament
                const stage = tournament.stages.find(s => s.id === stageId);
                if (!stage) return;
                participantsInScope = tournament.participants.filter(p => stage.participants.includes(p.id));
                groupStageSettings = stage.settings; // Use stage-specific settings
                groupsArray = stage.groups;
            }

            const groupsCount = groupStageSettings.groupsCount;
            const advanceK = groupStageSettings.advanceK;

            if (participantsInScope.length < groupsCount * 2 && groupsArray.length === 0) { // Only check if no groups generated yet
                showAlert(`Not enough teams (${participantsInScope.length}) for ${groupsCount} groups. Need at least ${groupsCount * 2}.`, 'error');
                return;
            }

            if (groupsArray.length === 0) { // Only generate if not already generated
                if (!confirm('Groups not generated. Generate now? This will clear existing matches if any.')) {
                    return;
                }

                // 1. Split into groups (serpentine seeding)
                const sortedParticipants = [...participantsInScope].sort((a, b) => {
                    if (a.seed && b.seed) return a.seed - b.seed;
                    if (a.seed) return -1;
                    if (b.seed) return 1;
                    return Math.random() - 0.5;
                });
                const newGroups = Array.from({ length: groupsCount }, (_, i) => ({
                    id: generateUniqueId(),
                    name: `Group ${String.fromCharCode(65 + i)}`, // A, B, C...
                    participants: [], // Participant IDs
                    matches: [],
                    standings: []
                }));

                for (let i = 0; i < sortedParticipants.length; i++) {
                    const groupIndex = i % groupsCount;
                    newGroups[groupIndex].participants.push(sortedParticipants[i].id);
                }

                if (stageId) {
                    const stage = tournament.stages.find(s => s.id === stageId);
                    stage.groups = newGroups;
                    groupsArray = stage.groups; // Update local reference
                } else {
                    tournament.groups = newGroups;
                    groupsArray = tournament.groups; // Update local reference
                }

                // 2. Schedule matches (round robin inside each group)
                groupsArray.forEach(group => {
                    group.matches = generateRoundRobinMatches(tournament, stageId, group); // Pass group object and stageId
                });

                saveData();
                showAlert('Group Stage generated successfully!');
            }

            if (!groupsArray || groupsArray.length === 0) {
                groupsDisplayDiv.innerHTML = '<p class="no-data">Groups not generated. Add teams and click "Generate Groups".</p>';
                return;
            }

            groupsArray.forEach(group => {
                const groupCard = document.createElement('div');
                groupCard.className = 'group-card';
                groupCard.innerHTML = `
                    <h4>${group.name}</h4>
                    <p>Teams: ${group.participants.length}</p>
                    <div class="group-content">
                        <h5>Matches</h5>
                        <div id="groupMatches_${group.id}"></div>
                        <h5 style="margin-top: 20px;">Team Standings</h5>
                        <div id="groupStandings_${group.id}"></div>
                    </div>
                `;
                groupsDisplayDiv.appendChild(groupCard);

                const groupParticipants = tournament.participants.filter(p => group.participants.includes(p.id));
                renderRoundRobinMatches(tournament, `groupMatches_${group.id}`, group.matches, groupParticipants, groupStageSettings, stageId, group.id);
                group.standings = renderRoundRobinStandings(tournament, `groupStandings_${group.id}`, group.matches, groupParticipants, groupStageSettings);
            });

            // Determine qualifiers (optional, can be done after all matches are played)
            const qualifiers = [];
            groupsArray.forEach(group => {
                const topK = group.standings.slice(0, advanceK);
                qualifiers.push(...topK.map(p => p.name));
            });
            if (qualifiers.length > 0) {
                groupsDisplayDiv.insertAdjacentHTML('beforeend', `<h3 style="margin-top: 30px;">Qualifiers for Next Stage:</h3><p>${qualifiers.join(', ')}</p>`);
            }
            updateAggregatedPlayerStats(tournament); // Update player stats after group stage generation
        }

        // NEW: Function to generate groups for Multi-Stage tournament's Group Stage
        function generateMultiStageGroups(tournament, stageId) {
            const stage = tournament.stages.find(s => s.id === stageId);
            if (!stage || stage.type !== TOURNAMENT_TYPES.GROUP_STAGE) {
                showAlert('Invalid stage for group generation.', 'error');
                return;
            }
            // Ensure all tournament participants are in this stage
            stage.participants = tournament.participants.map(p => p.id);
            generateGroupStage(tournament, `stageGroupsDisplay_${stage.id}`, stage.groups, stage.settings, stage.id);
            saveData();
            renderMultiStages(tournament);
        }

        // NEW: Function to advance qualifiers from Group Stage to Knockout Stage
        async function advanceQualifiersToKnockout(tournament, groupStageId) {
            const groupStage = tournament.stages.find(s => s.id === groupStageId);
            const knockoutStage = tournament.stages.find(s => s.name === 'Knockout Stage' && s.type === TOURNAMENT_TYPES.SINGLE_ELIMINATION);

            if (!groupStage || !knockoutStage) {
                showAlert('Group Stage or Knockout Stage not found for advancement.', 'error');
                return;
            }

            if (!groupStage.groups || groupStage.groups.length === 0) {
                showAlert('Group Stage has not been generated yet. Please generate groups first.', 'error');
                return;
            }

            // Check if all group matches are completed
            const allMatchesCompleted = groupStage.groups.every(group =>
                group.matches && group.matches.every(match => match.status === 'Completed')
            );

            if (!allMatchesCompleted) {
                if (!confirm('Not all group stage matches are completed. Advancing qualifiers now might lead to an unfair bracket. Continue anyway?')) {
                    return;
                }
            }

            const qualifiers = [];
            groupStage.groups.forEach(group => {
                // Ensure standings are up-to-date before getting qualifiers
                const groupParticipants = tournament.participants.filter(p => group.participants.includes(p.id));
                const currentStandings = renderRoundRobinStandings(tournament, null, group.matches, groupParticipants, groupStage.settings);
                const topK = currentStandings.slice(0, groupStage.settings.advanceK);
                qualifiers.push(...topK.map(p => p.id));
            });

            if (qualifiers.length < 2) {
                showAlert('Not enough qualifiers to form a knockout bracket (need at least 2).', 'error');
                return;
            }

            knockoutStage.participants = qualifiers;
            generateEliminationBracket(tournament, TOURNAMENT_TYPES.SINGLE_ELIMINATION, knockoutStage.id);
            saveData();
            showAlert(`${qualifiers.length} teams advanced to Knockout Stage!`);
            renderMultiStages(tournament);
        }


        // --- Multi-Stage Management ---
        function renderMultiStages(tournament) {
            const stagesListDiv = document.getElementById('stagesList');
            if (!stagesListDiv) return; // Ensure element exists
            stagesListDiv.innerHTML = '';
            const manageStagesActionsDiv = document.getElementById('manageStagesActions');
            if (manageStagesActionsDiv) manageStagesActionsDiv.innerHTML = ''; // Clear generic buttons

            if (!tournament.stages || tournament.stages.length === 0) {
                stagesListDiv.innerHTML = '<p class="no-data">No stages defined. This tournament type expects predefined stages. Please edit tournament settings or recreate.</p>';
                return;
            }

            tournament.stages.forEach(stage => {
                const stageCard = document.createElement('div');
                stageCard.className = 'stage-card';
                let stageActionsHtml = '';

                if (stage.type === TOURNAMENT_TYPES.GROUP_STAGE) {
                    stageActionsHtml = `
                        <button class="btn btn-primary btn-sm" onclick="generateMultiStageGroups(tournaments.find(t => t.id === currentTournamentId), '${stage.id}')">Generate Groups</button>
                        <button class="btn btn-secondary btn-sm" onclick="advanceQualifiersToKnockout(tournaments.find(t => t.id === currentTournamentId), '${stage.id}')">Advance Qualifiers</button>
                    `;
                } else if (stage.type === TOURNAMENT_TYPES.SINGLE_ELIMINATION) {
                    // For Knockout Stage in Multi-Stage, the bracket is auto-generated.
                    // The button is hidden here.
                    // stageActionsHtml = `<button class="btn btn-primary btn-sm" onclick="generateEliminationBracket(tournaments.find(t => t.id === currentTournamentId), '${TOURNAMENT_TYPES.SINGLE_ELIMINATION}', '${stage.id}')">Generate Bracket</button>`;
                } else if (stage.type === TOURNAMENT_TYPES.ROUND_ROBIN) {
                    stageActionsHtml = `<button class="btn btn-primary btn-sm" onclick="generateRoundRobinMatches(tournaments.find(t => t.id === currentTournamentId), '${stage.id}')">Generate Matches</button>`;
                }


                stageCard.innerHTML = `
                    <div class="flex-between">
                        <h4>${stage.name} (${stage.type})</h4>
                        <div class="btn-group">
                            <button class="btn btn-outline btn-sm" onclick="openAdvanceParticipantsModal('${stage.id}')">Add Teams</button>
                            ${stageActionsHtml}
                        </div>
                    </div>
                    <p>Teams: ${stage.participants.length} / ${tournament.participants.length}</p>
                    <div class="stage-content" id="stageContent_${stage.id}">
                        <!-- Stage specific content will be rendered here -->
                    </div>
                `;
                stagesListDiv.appendChild(stageCard);

                const stageContentDiv = document.getElementById(`stageContent_${stage.id}`);
                const stageParticipants = tournament.participants.filter(p => stage.participants.includes(p.id));

                if (stage.type === TOURNAMENT_TYPES.ROUND_ROBIN) {
                    const matchesDiv = document.createElement('div');
                    matchesDiv.id = `stageMatches_${stage.id}`;
                    stageContentDiv.appendChild(matchesDiv);
                    renderRoundRobinMatches(tournament, `stageMatches_${stage.id}`, stage.matches, stageParticipants, stage.settings, stage.id);

                    const standingsDiv = document.createElement('div');
                    standingsDiv.id = `stageStandings_${stage.id}`;
                    stageContentDiv.appendChild(standingsDiv);
                    renderRoundRobinStandings(tournament, `stageStandings_${stage.id}`, stage.matches, stageParticipants, stage.settings);
                } else if (stage.type === TOURNAMENT_TYPES.SINGLE_ELIMINATION) {
                    const bracketDiv = document.createElement('div');
                    bracketDiv.className = 'bracket-visualizer';
                    bracketDiv.id = `stageBracket_${stage.id}`;
                    stageContentDiv.appendChild(bracketDiv);
                    renderBracket(tournament, `stageBracket_${stage.id}`, stage.rounds, stage.id);
                } else if (stage.type === TOURNAMENT_TYPES.GROUP_STAGE) {
                    const groupsDisplayDiv = document.createElement('div');
                    groupsDisplayDiv.id = `stageGroupsDisplay_${stage.id}`;
                    stageContentDiv.appendChild(groupsDisplayDiv);
                    generateGroupStage(tournament, `stageGroupsDisplay_${stage.id}`, stage.groups, stage.settings, stage.id);
                }
            });
        }

        function openManageStagesModal() {
            const tournament = tournaments.find(t => t.id === currentTournamentId);
            if (tournament.type === TOURNAMENT_TYPES.MULTI_STAGE) {
                // For Multi-Stage, stages are predefined, so we just render them
                renderMultiStages(tournament);
                // Hide generic add/delete buttons
                const manageStagesActionsDiv = document.getElementById('manageStagesActions');
                if (manageStagesActionsDiv) manageStagesActionsDiv.innerHTML = '';
            } else {
                // For other types, allow generic stage management
                renderCurrentStagesList();
                const manageStagesActionsDiv = document.getElementById('manageStagesActions');
                if (manageStagesActionsDiv) {
                    manageStagesActionsDiv.innerHTML = '<button id="addStageBtn" class="btn btn-primary">Add New Stage</button>';
                    document.getElementById('addStageBtn').onclick = openAddStageModal;
                }
            }
            openModal('manageStagesModal');
        }

        function renderCurrentStagesList() {
            const listDiv = document.getElementById('currentStagesList');
            if (!listDiv) return; // Ensure element exists
            listDiv.innerHTML = '';
            const tournament = tournaments.find(t => t.id === currentTournamentId);
            if (!tournament || !tournament.stages || tournament.stages.length === 0) {
                listDiv.innerHTML = '<p class="no-data">No stages added yet.</p>';
                return;
            }

            tournament.stages.forEach(stage => {
                const item = document.createElement('div');
                item.className = 'participant-item'; // Reusing style
                item.innerHTML = `
                    <div>
                        <strong>${stage.name}</strong> (${stage.type})
                        <br><small>Teams: ${stage.participants.length}</small>
                    </div>
                    <div class="actions">
                        <button class="btn btn-secondary" onclick="editStage('${stage.id}')">Edit</button>
                        <button class="btn btn-danger" onclick="deleteStage('${stage.id}')">Delete</button>
                    </div>
                `;
                listDiv.appendChild(item);
            });
        }

        function openAddStageModal() {
            document.getElementById('stageModalTitle').textContent = 'Add Stage';
            document.getElementById('stageForm').reset();
            document.getElementById('stageId').value = '';
            document.getElementById('stageEliminationSettings').classList.add('hidden');
            document.getElementById('stageRoundRobinSettings').classList.add('hidden');
            document.getElementById('stageGroupStageSettings').classList.add('hidden'); // NEW
            openModal('stageModal');
        }

        function addOrUpdateStage(event) {
            event.preventDefault();
            const tournament = tournaments.find(t => t.id === currentTournamentId);
            if (!tournament) return;

            const stageId = document.getElementById('stageId').value;
            const name = document.getElementById('stageName').value;
            const type = document.getElementById('stageType').value;

            if (!name || !type) {
                showAlert('Stage name and type are required.', 'error');
                return;
            }

            const stageSettings = {
                setBasedScoring: tournament.settings.setBasedScoring, // Inherit from tournament
                playerStatsFields: tournament.settings.playerStatsFields // Inherit from tournament
            };

            if (type === TOURNAMENT_TYPES.SINGLE_ELIMINATION) {
                stageSettings.bestOf = parseInt(document.getElementById('stageBestOf').value) || 1;
            } else if (type === TOURNAMENT_TYPES.ROUND_ROBIN) {
                stageSettings.enableHomeAway = document.getElementById('stageRrEnableHomeAway').checked;
                stageSettings.pointsWin = parseInt(document.getElementById('stageRrPointsWin').value) || 3;
                stageSettings.pointsDraw = parseInt(document.getElementById('stageRrPointsDraw').value) || 1;
                stageSettings.pointsLoss = parseInt(document.getElementById('stageRrPointsLoss').value) || 0;
                stageSettings.tieBreaker = document.getElementById('stageRrTieBreaker').value || 'Points';
            } else if (type === TOURNAMENT_TYPES.GROUP_STAGE) { // NEW
                stageSettings.groupsCount = parseInt(document.getElementById('stageGroupStageGroupsCount').value) || 1;
                stageSettings.advanceK = parseInt(document.getElementById('stageGroupStageAdvanceK').value) || 1;
                stageSettings.pointsWin = parseInt(document.getElementById('stageGroupStagePointsWin').value) || 3;
                stageSettings.pointsDraw = parseInt(document.getElementById('stageGroupStagePointsDraw').value) || 1;
                stageSettings.pointsLoss = parseInt(document.getElementById('stageGroupStagePointsLoss').value) || 0;
                stageSettings.tieBreaker = document.getElementById('stageGroupStageTieBreaker').value || 'Points';
            }

            if (stageId) {
                const stage = tournament.stages.find(s => s.id === stageId);
                if (stage) {
                    stage.name = name;
                    stage.type = type;
                    stage.settings = stageSettings;
                    showAlert('Stage updated successfully!');
                }
            } else {
                const newStage = {
                    id: generateUniqueId(),
                    name, type,
                    participants: [], // Teams for this specific stage
                    matches: [], // For RR
                    rounds: [], // For SE
                    groups: [], // For Group Stage
                    settings: stageSettings
                };
                tournament.stages.push(newStage);
                showAlert('Stage added successfully!');
            }

            saveData();
            renderMultiStages(tournament);
            renderCurrentStagesList();
            closeModal('stageModal');
        }

        function editStage(stageId) {
            const tournament = tournaments.find(t => t.id === currentTournamentId);
            const stage = tournament.stages.find(s => s.id === stageId);
            if (!stage) return;

            document.getElementById('stageModalTitle').textContent = 'Edit Stage';
            document.getElementById('stageId').value = stage.id;
            document.getElementById('stageName').value = stage.name;
            document.getElementById('stageType').value = stage.type;

            document.getElementById('stageEliminationSettings').classList.add('hidden');
            document.getElementById('stageRoundRobinSettings').classList.add('hidden');
            document.getElementById('stageGroupStageSettings').classList.add('hidden');

            if (stage.type === TOURNAMENT_TYPES.SINGLE_ELIMINATION) {
                document.getElementById('stageEliminationSettings').classList.remove('hidden');
                document.getElementById('stageBestOf').value = stage.settings.bestOf || 1;
            } else if (stage.type === TOURNAMENT_TYPES.ROUND_ROBIN) {
                document.getElementById('stageRoundRobinSettings').classList.remove('hidden');
                document.getElementById('stageRrEnableHomeAway').checked = stage.settings.enableHomeAway || false;
                document.getElementById('stageRrPointsWin').value = stage.settings.pointsWin;
                document.getElementById('stageRrPointsDraw').value = stage.settings.pointsDraw;
                document.getElementById('stageRrPointsLoss').value = stage.settings.pointsLoss;
                document.getElementById('stageRrTieBreaker').value = stage.settings.tieBreaker;
            } else if (stage.type === TOURNAMENT_TYPES.GROUP_STAGE) {
                document.getElementById('stageGroupStageSettings').classList.remove('hidden');
                document.getElementById('stageGroupStageGroupsCount').value = stage.settings.groupsCount || 1;
                document.getElementById('stageGroupStageAdvanceK').value = stage.settings.advanceK || 1;
                document.getElementById('stageGroupStagePointsWin').value = stage.settings.pointsWin || 3;
                document.getElementById('stageGroupStagePointsDraw').value = stage.settings.pointsDraw || 1;
                document.getElementById('stageGroupStagePointsLoss').value = stage.settings.pointsLoss || 0;
                document.getElementById('stageGroupStageTieBreaker').value = stage.settings.tieBreaker || 'Points';
            }

            openModal('stageModal');
        }

        function deleteStage(stageId) {
            if (!confirm('Are you sure you want to delete this stage and all its matches/brackets?')) {
                return;
            }
            const tournament = tournaments.find(t => t.id === currentTournamentId);
            if (tournament) {
                tournament.stages = tournament.stages.filter(s => s.id !== stageId);
                saveData();
                showAlert('Stage deleted successfully!', 'danger');
                renderMultiStages(tournament);
                renderCurrentStagesList();
                updateAggregatedPlayerStats(tournament); // Re-aggregate all stats
                renderPlayerLeaderboards(tournament);
            }
        }

        function openAdvanceParticipantsModal(stageId) {
            const tournament = tournaments.find(t => t.id === currentTournamentId);
            const stage = tournament.stages.find(s => s.id === stageId);
            if (!tournament || !stage) return;

            document.getElementById('advanceStageId').value = stageId;
            const availableParticipantsList = document.getElementById('availableParticipantsList');
            if (!availableParticipantsList) return; // Ensure element exists
            availableParticipantsList.innerHTML = '';

            tournament.participants.forEach(p => {
                const checkboxDiv = document.createElement('div');
                checkboxDiv.className = 'checkbox-group';
                checkboxDiv.innerHTML = `
                    <input type="checkbox" id="adv_p_${p.id}" value="${p.id}" ${stage.participants.includes(p.id) ? 'checked' : ''}>
                    <label for="adv_p_${p.id}">${p.name}</label>
                `;
                availableParticipantsList.appendChild(checkboxDiv);
            });

            openModal('advanceParticipantsModal');
        }

        function processAdvanceParticipants() {
            const tournament = tournaments.find(t => t.id === currentTournamentId);
            const stageId = document.getElementById('advanceStageId').value;
            const stage = tournament.stages.find(s => s.id === stageId);
            if (!tournament || !stage) return;

            const selectedParticipantIds = Array.from(document.querySelectorAll('#availableParticipantsList input[type="checkbox"]:checked'))
                                                .map(cb => cb.value);

            stage.participants = selectedParticipantIds;
            // Reset matches/rounds/groups for the stage if participants change
            stage.matches = [];
            stage.rounds = [];
            stage.groups = [];

            saveData();
            showAlert('Teams updated for stage successfully!');
            renderMultiStages(tournament);
            renderCurrentStagesList();
            closeModal('advanceParticipantsModal');
            updateAggregatedPlayerStats(tournament); // Re-aggregate all stats
            renderPlayerLeaderboards(tournament);
        }


        // --- NEW: Player Stats Management ---
        function updateAggregatedPlayerStats(tournament) {
            // Reset all player and team stats first
            tournament.participants.forEach(team => {
                // Reset team-level stats
                team.teamStats.matchesPlayed = 0;
                tournament.settings.playerStatsFields.forEach(field => team.teamStats.custom[field] = 0);

                // Reset individual player stats
                team.players.forEach(player => {
                    player.stats.matchesPlayed = 0;
                    tournament.settings.playerStatsFields.forEach(field => player.stats.custom[field] = 0);
                });
            });

            // Helper to process matches from any bracket/list
            const processMatches = (matches) => {
                if (!matches) return; // Ensure matches array exists
                matches.forEach(match => {
                    if (match.status === 'Completed') {
                        // Determine participants in scope for this specific match
                        let participantsInScope = tournament.participants;
                        if (match.stageId) {
                            const stage = tournament.stages.find(s => s.id === match.stageId);
                            if (stage) {
                                participantsInScope = tournament.participants.filter(p => stage.participants.includes(p.id));
                            }
                        }
                        if (match.groupId) {
                            let group;
                            if (match.stageId) { // Group within a stage
                                const stage = tournament.stages.find(s => s.id === match.stageId);
                                group = stage?.groups.find(g => g.id === match.groupId);
                            } else { // Group in main tournament
                                group = tournament.groups.find(g => g.id === match.groupId);
                            }
                            if (group) {
                                participantsInScope = tournament.participants.filter(p => group.participants.includes(p.id));
                            }
                        }

                        const team1 = participantsInScope.find(p => p.id === match.player1Id);
                        const team2 = participantsInScope.find(p => p.id === match.player2Id);

                        if (!team1 || !team2) return; // Skip if teams not found (e.g., BYE)

                        // Aggregate team-level matches played
                        team1.teamStats.matchesPlayed = (team1.teamStats.matchesPlayed || 0) + 1;
                        team2.teamStats.matchesPlayed = (team2.teamStats.matchesPlayed || 0) + 1;

                        // Aggregate individual player stats for Team 1
                        match.team1MatchPlayerStats.forEach(matchPlayerStat => {
                            const player = team1.players.find(p => p.id === matchPlayerStat.playerId);
                            if (player) {
                                player.stats.matchesPlayed = (player.stats.matchesPlayed || 0) + 1;
                                tournament.settings.playerStatsFields.forEach(field => {
                                    player.stats.custom[field] = (player.stats.custom[field] || 0) + (matchPlayerStat[field] || 0);
                                    team1.teamStats.custom[field] = (team1.teamStats.custom[field] || 0) + (matchPlayerStat[field] || 0); // Also aggregate to team total
                                });
                            }
                        });

                        // Aggregate individual player stats for Team 2
                        match.team2MatchPlayerStats.forEach(matchPlayerStat => {
                            const player = team2.players.find(p => p.id === matchPlayerStat.playerId);
                            if (player) {
                                player.stats.matchesPlayed = (player.stats.matchesPlayed || 0) + 1;
                                tournament.settings.playerStatsFields.forEach(field => {
                                    player.stats.custom[field] = (player.stats.custom[field] || 0) + (matchPlayerStat[field] || 0);
                                    team2.teamStats.custom[field] = (team2.teamStats.custom[field] || 0) + (matchPlayerStat[field] || 0); // Also aggregate to team total
                                });
                            }
                        });
                    }
                });
            };

            // Process matches from main tournament brackets/lists
            if (tournament.rounds) tournament.rounds.forEach(r => processMatches(r.matches));
            if (tournament.winnerBracket) tournament.winnerBracket.forEach(r => processMatches(r.matches));
            if (tournament.loserBracket) tournament.loserBracket.forEach(r => processMatches(r.matches));
            if (tournament.grandFinal) tournament.grandFinal.forEach(r => processMatches(r.matches));
            if (tournament.matches) processMatches(tournament.matches);
            if (tournament.groups) tournament.groups.forEach(g => processMatches(g.matches));

            // Process matches from stages
            if (tournament.stages) {
                tournament.stages.forEach(stage => {
                    if (stage.matches) processMatches(stage.matches);
                    if (stage.rounds) stage.rounds.forEach(r => processMatches(r.matches));
                    if (stage.groups) stage.groups.forEach(g => processMatches(g.matches));
                });
            }
            saveData(); // Save updated aggregated stats
        }

        function renderPlayerLeaderboards(tournament) {
            const leaderboardsDiv = document.getElementById('playerLeaderboardsDisplay');
            if (!leaderboardsDiv) return; // Ensure element exists
            leaderboardsDiv.innerHTML = '';

            if (tournament.participants.length === 0) {
                leaderboardsDiv.innerHTML = '<p class="no-data">No teams to display player leaderboards.</p>';
                return;
            }

            if (!tournament.settings.playerStatsFields || tournament.settings.playerStatsFields.length === 0) {
                leaderboardsDiv.innerHTML = '<p class="no-data">No custom player stats fields defined for this tournament.</p>';
                return;
            }

            // Collect all players from all teams
            const allPlayers = [];
            tournament.participants.forEach(team => {
                team.players.forEach(player => {
                    allPlayers.push({ ...player, teamName: team.name }); // Add team name for display
                });
            });

            if (allPlayers.length === 0) {
                leaderboardsDiv.innerHTML = '<p class="no-data">No players registered across all teams.</p>';
                return;
            }

            tournament.settings.playerStatsFields.forEach(field => {
                const fieldName = field.charAt(0).toUpperCase() + field.slice(1); // Capitalize for display
                const leaderboardTable = document.createElement('table');
                leaderboardTable.className = 'leaderboard-table';
                leaderboardTable.innerHTML = `
                    <thead>
                        <tr>
                            <th>Rank</th>
                            <th>Player</th>
                            <th>Team</th>
                            <th>${fieldName}</th>
                            <th>Matches Played</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                `;
                const tbody = leaderboardTable.querySelector('tbody');

                const sortedPlayers = [...allPlayers].sort((a, b) => {
                    const statA = a.stats.custom[field] || 0;
                    const statB = b.stats.custom[field] || 0;
                    return statB - statA; // Descending order
                });

                sortedPlayers.forEach((player, index) => {
                    const row = document.createElement('tr');
                    row.innerHTML = `
                        <td class="rank">${index + 1}</td>
                        <td>${player.name}</td>
                        <td>${player.teamName}</td>
                        <td>${player.stats.custom[field] || 0}</td>
                        <td>${player.stats.matchesPlayed || 0}</td>
                    `;
                    tbody.appendChild(row);
                });

                const fieldHeader = document.createElement('h4');
                fieldHeader.textContent = `${fieldName} Leaderboard`;
                leaderboardsDiv.appendChild(fieldHeader);
                leaderboardsDiv.appendChild(leaderboardTable);
            });
        }


        // --- Import/Export ---
        function exportData() {
            const dataStr = JSON.stringify(tournaments, null, 2);
            const blob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `tournament_manager_data_${new Date().toISOString().slice(0,10)}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            showAlert('Data exported successfully!');
        }

        function importData(event) {
            const file = event.target.files[0];
            if (!file) {
                showAlert('No file selected.', 'error');
                return;
            }

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const importedData = JSON.parse(e.target.result);
                    if (!Array.isArray(importedData)) {
                        throw new Error('Invalid JSON format. Expected an array of tournaments.');
                    }

                    if (confirm('Do you want to REPLACE all existing data with the imported data? Click Cancel to MERGE (add new, update existing by ID).')) {
                        tournaments = importedData;
                        showAlert('All data replaced successfully!', 'success');
                    } else {
                        importedData.forEach(importedTournament => {
                            const existingIndex = tournaments.findIndex(t => t.id === importedTournament.id);
                            if (existingIndex !== -1) {
                                tournaments[existingIndex] = importedTournament; // Update existing
                            } else {
                                tournaments.push(importedTournament); // Add new
                            }
                        });
                        showAlert('Data merged successfully!', 'success');
                    }

                    saveData();
                    loadData(); // Reload to ensure new fields are initialized for imported data
                    renderTournamentList();
                    showSection('dashboardSection');
                    document.getElementById('importFileInput').value = ''; // Clear file input
                } catch (error) {
                    showAlert(`Error importing data: ${error.message}`, 'error');
                }
            };
            reader.readAsText(file);
        }

        // --- QR Code ---
        function showQrCode() {
            const tournament = tournaments.find(t => t.id === currentTournamentId);
            if (!tournament) return;

            const qrCodeContainer = document.getElementById('qrCodeContainer');
            if (!qrCodeContainer) return; // Ensure element exists
            qrCodeContainer.innerHTML = ''; // Clear previous QR code

            // Use the inlined QRCode generator
            new QRCode({
                element: qrCodeContainer,
                value: tournament.id,
                size: 200,
                background: document.body.classList.contains('dark-mode') ? '#3a3a3a' : '#ffffff',
                foreground: document.body.classList.contains('dark-mode') ? '#e0e0e0' : '#000000'
            });

            document.getElementById('qrTournamentId').textContent = tournament.id;
            openModal('qrCodeModal');
        }


        // --- Event Listeners ---
        document.addEventListener('DOMContentLoaded', () => {
            // Load theme
            const savedTheme = localStorage.getItem(LS_THEME_KEY) || 'light';
            applyTheme(savedTheme);

            loadData();
            renderTournamentList(); // Initial render

            // Navigation
            document.getElementById('navDashboard').addEventListener('click', () => showSection('dashboardSection'));
            document.getElementById('navCreateTournament').addEventListener('click', () => {
                showSection('createTournamentSection');
                document.getElementById('createTournamentForm').reset();
                // Reset specific settings visibility
                document.getElementById('eliminationSettings').classList.add('hidden');
                document.getElementById('roundRobinSettings').classList.add('hidden');
                document.getElementById('groupStageSettings').classList.add('hidden');
                document.getElementById('multiStageSettings').classList.add('hidden'); // NEW
                document.getElementById('swissSettings').classList.add('hidden');
                document.getElementById('gslSettings').classList.add('hidden');
                document.getElementById('ladderSettings').classList.add('hidden');
                document.getElementById('tournamentSetBasedScoring').checked = false;
                document.getElementById('tournamentPlayerStatsFields').value = '';
            });
            document.getElementById('navImportExport').addEventListener('click', () => showSection('importExportSection'));

            // Theme Toggle
            document.getElementById('themeToggle').addEventListener('click', toggleTheme);

            // Create Tournament Form
            document.getElementById('createTournamentForm').addEventListener('submit', createTournament);
            document.getElementById('tournamentType').addEventListener('change', (e) => {
                // Hide all specific settings first
                document.getElementById('eliminationSettings').classList.add('hidden');
                document.getElementById('roundRobinSettings').classList.add('hidden');
                document.getElementById('groupStageSettings').classList.add('hidden');
                document.getElementById('multiStageSettings').classList.add('hidden'); // NEW
                document.getElementById('swissSettings').classList.add('hidden');
                document.getElementById('gslSettings').classList.add('hidden');
                document.getElementById('ladderSettings').classList.add('hidden');

                // Show relevant settings based on type
                if (e.target.value === TOURNAMENT_TYPES.SINGLE_ELIMINATION || e.target.value === TOURNAMENT_TYPES.DOUBLE_ELIMINATION) {
                    document.getElementById('eliminationSettings').classList.remove('hidden');
                } else if (e.target.value === TOURNAMENT_TYPES.ROUND_ROBIN) {
                    document.getElementById('roundRobinSettings').classList.remove('hidden');
                } else if (e.target.value === TOURNAMENT_TYPES.GROUP_STAGE) {
                    document.getElementById('groupStageSettings').classList.remove('hidden');
                } else if (e.target.value === TOURNAMENT_TYPES.MULTI_STAGE) { // NEW
                    document.getElementById('multiStageSettings').classList.remove('hidden');
                } else if (e.target.value === TOURNAMENT_TYPES.SWISS_SYSTEM) {
                    document.getElementById('swissSettings').classList.remove('hidden');
                } else if (e.target.value === TOURNAMENT_TYPES.GSL_FORMAT) {
                    document.getElementById('gslSettings').classList.remove('hidden');
                } else if (e.target.value === TOURNAMENT_TYPES.LADDER) {
                    document.getElementById('ladderSettings').classList.remove('hidden');
                }
            });

            // Tournament Detail Actions
            document.getElementById('backToDashboardBtn').addEventListener('click', () => showSection('dashboardSection'));
            document.getElementById('editTournamentBtn').addEventListener('click', editTournamentDetails);
            document.getElementById('deleteTournamentBtn').addEventListener('click', deleteTournament);
            document.getElementById('changeTournamentStatus').addEventListener('change', changeTournamentStatus);
            document.getElementById('showQrCodeBtn').addEventListener('click', showQrCode);


            // Edit Tournament Modal Form
            document.getElementById('editTournamentForm').addEventListener('submit', saveEditedTournament);
            // The editTournamentType change listener is not needed as type is disabled for editing.
            // The logic for showing/hiding settings is handled by editTournamentDetails based on current type.


            // Participant (Team) Management
            document.getElementById('addParticipantBtn').addEventListener('click', openAddParticipantModal);
            document.getElementById('participantForm').addEventListener('submit', addOrUpdateParticipant);
            document.getElementById('bulkImportParticipantsBtn').addEventListener('click', openBulkImportModal);
            document.getElementById('processBulkImportBtn').addEventListener('click', processBulkImport);
            document.getElementById('copyParticipantsBtn').addEventListener('click', openCopyParticipantsModal);
            document.getElementById('processCopyParticipantsBtn').addEventListener('click', processCopyParticipants);

            // Player Management within a Team
            document.getElementById('managePlayersBtnForTeam').addEventListener('click', () => {
                const teamId = document.getElementById('participantId').value;
                if (teamId) {
                    openManagePlayersModal(teamId);
                } else {
                    showAlert('Please save the team first before managing players.', 'info');
                }
            });
            document.getElementById('addPlayerBtn').addEventListener('click', openAddPlayerModal);
            document.getElementById('addEditPlayerForm').addEventListener('submit', addOrUpdatePlayer);


            // Bracket/Match Generation
            document.getElementById('generateBracketBtn').addEventListener('click', () => {
                const tournament = tournaments.find(t => t.id === currentTournamentId);
                if (tournament) generateEliminationBracket(tournament, TOURNAMENT_TYPES.SINGLE_ELIMINATION);
            });
            document.getElementById('generateDoubleEliminationBracketBtn').addEventListener('click', () => {
                const tournament = tournaments.find(t => t.id === currentTournamentId);
                if (tournament) generateEliminationBracket(tournament, TOURNAMENT_TYPES.DOUBLE_ELIMINATION);
            });
            document.getElementById('generateRoundRobinBtn').addEventListener('click', () => {
                const tournament = tournaments.find(t => t.id === currentTournamentId);
                if (tournament) generateRoundRobinMatches(tournament);
            });
            document.getElementById('generateGroupStageBtn').addEventListener('click', () => {
                const tournament = tournaments.find(t => t.id === currentTournamentId);
                if (tournament) generateGroupStage(tournament);
            });
            // New format generation buttons (placeholders)
            document.getElementById('generateSwissBtn').addEventListener('click', () => showAlert('Swiss System generation not yet implemented.', 'info'));
            document.getElementById('generateGSLBtn').addEventListener('click', () => showAlert('GSL Format generation not yet implemented.', 'info'));
            document.getElementById('manageLadderBtn').addEventListener('click', () => showAlert('Ladder management not yet implemented.', 'info'));


            // Multi-Stage Management
            document.getElementById('manageStagesBtn').addEventListener('click', openManageStagesModal);
            // The addStageBtn and stageForm listeners are now dynamically attached/detached based on tournament type in openManageStagesModal
            document.getElementById('stageType').addEventListener('change', (e) => {
                document.getElementById('stageEliminationSettings').classList.add('hidden');
                document.getElementById('stageRoundRobinSettings').classList.add('hidden');
                document.getElementById('stageGroupStageSettings').classList.add('hidden');
                if (e.target.value === TOURNAMENT_TYPES.SINGLE_ELIMINATION) {
                    document.getElementById('stageEliminationSettings').classList.remove('hidden');
                } else if (e.target.value === TOURNAMENT_TYPES.ROUND_ROBIN) {
                    document.getElementById('stageRoundRobinSettings').classList.remove('hidden');
                } else if (e.target.value === TOURNAMENT_TYPES.GROUP_STAGE) {
                    document.getElementById('stageGroupStageSettings').classList.remove('hidden');
                }
            });
            document.getElementById('processAdvanceParticipantsBtn').addEventListener('click', processAdvanceParticipants);


            // Match Details Modal
            document.getElementById('matchDetailsForm').addEventListener('submit', saveMatchDetails);

            // Search and Filter
            document.getElementById('tournamentSearch').addEventListener('input', renderTournamentList);
            document.getElementById('tournamentFilterStatus').addEventListener('change', renderTournamentList);
            document.getElementById('tournamentFilterSport').addEventListener('change', renderTournamentList);
            document.getElementById('tournamentFilterType').addEventListener('change', renderTournamentList);

            // Import/Export
            document.getElementById('exportDataBtn').addEventListener('click', exportData);
            document.getElementById('importFileInput').addEventListener('change', importData);
        });
    </script>
</body>
</html>
